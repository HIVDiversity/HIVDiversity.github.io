<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phylotagger</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
        }

        #main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        #top-panel {
            padding: 10px;
            border-bottom: 1px solid #ccc;
            flex-shrink: 0;
        }

        #head-panel {
            padding: 10px;
            border-bottom: 1px solid #ccc;
            flex-shrink: 0;
        }

        #newickInput {
            width: calc(100% - 840px);
            margin-right: 10px;
        }

        #controls-container {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #ccc;
        }

        #scale-container {
            display: flex;
            align-items: center;
        }

        #scale-container label {
            margin-right: 10px;
        }

        #horizontalScale {
            width: 200px;
        }

        #tag-buttons {
            margin-left: 20px;
        }

        #content-container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
        }

        #left-panel {
            width: 100%;
            padding: 10px;
            border-bottom: 1px solid #ccc;
            flex-shrink: 0;
        }

        
        .horizontal-slider-container {
            display: flex;
            flex-direction: row;
            align-items: left;
            margin-right: 20px;
        }

        .horizontal-slider-container input {
            width: 150px;
        }


        #mode-controls {
            display: flex;
            flex-direction: row;
            align-items: center;
        }

        #mode-controls button {
            margin-right: 5px;
        }

        #canvasContainer {
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: auto;
        }

        #treeCanvas {
            /* Canvas size will be set dynamically */
        }

        #visualization-container {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }

        #canvasContainer, #alignmentContainer {
            flex: 1;
            overflow-y: scroll;
            overflow-x: scroll;
        }

        #alignmentSVG {
            /* Size will be set dynamically */
        }
    </style>
</head>

<body>
    <div id="main-container">
        <div id="head-panel">
            <strong>Phylotagger (from HIVDiversity group)</strong>
        </div>
        <div id="top-panel">
            <medium>Input Newick:</medium>
            <input type="text" id="newickInput" placeholder="Enter Newick string here..."
            value="(((EELA:0.150276,CONGERA:0.213019):0.230956,(EELB:0.263487,CONGERB:0.202633):0.246917):0.094785,((CAVEFISH:0.451027,(GOLDFISH:0.340495,ZEBRAFISH:0.390163):0.220565):0.067778,((((NSAM:0.008113,NARG:0.014065):0.052991,SPUN:0.061003,(SMIC:0.027806,SDIA:0.015298,SXAN:0.046873):0.046977):0.009822,(NAUR:0.081298,(SSPI:0.023876,STIE:0.013652):0.058179):0.091775):0.073346,(MVIO:0.012271,MBER:0.039798):0.178835):0.147992,((BFNKILLIFISH:0.317455,(ONIL:0.029217,XCAU:0.084388):0.201166):0.055908,THORNYHEAD:0.252481):0.061905):0.157214,LAMPFISH:0.717196,((SCABBARDA:0.189684,SCABBARDB:0.362015):0.282263,((VIPERFISH:0.318217,BLACKDRAGON:0.109912):0.123642,LOOSEJAW:0.3971):0.287152):0.140663):0.206729):0.222485,(COELACANTH:0.558103,((CLAWEDFROG:0.441842,SALAMANDER:0.299607):0.135307,((CHAMELEON:0.771665,((PIGEON:0.150909,CHICKEN:0.172733):0.082163,ZEBRAFINCH:0.099172):0.272338):0.014055,((BOVINE:0.167569,DOLPHIN:0.15745):0.104783,ELEPHANT:0.166557):0.367205):0.050892):0.114731):0.295021):0;">
            <button onclick="document.getElementById('newickFile').click()" title="Load a Newick string from a file">Load Newick File</button>
             <button id="exportNewickButton">Export Tagged Tree </button>
             <input type="file" id="newickFile" accept=".newick,.txt,.tree" style="display: none;">
            <input type="file" id="alignmentFile" accept=".fasta,.fa,.aln" style="display: none;">
            <button onclick="document.getElementById('alignmentFile').click()" title="Load alignment file">Load Alignment</button>
            <button onclick="exportAlignment()">Export Tagged Alignment </button>
            <button onclick="exportSVG()" title="Export the current tree view as an SVG image file">Export SVG</button>
           <button onclick="drawTree()" title="Reload the tree from the Newick string">Reload Tree</button>
        </div>
        <div id="controls-container">
                    <strong>Selection Mode: </strong>
                    <button onclick="setSelectionMode('clade')" id="cladeMode"
                        title="Set selection mode to Clade: clicking a node selects all its descendant leaves">Clade</button>
                    <button onclick="setSelectionMode('node')" id="nodeMode" style="display: none;"
                        title="Set selection mode to Node: clicking a node selects only that node">Node</button>
                    <button onclick="setSelectionMode('nodeToRoot')" id="nodeToRootMode" style="display: none;"
                        title="Set selection mode to Node to Root: clicking a node selects it and all its ancestors up to the root">Node2Root</button>
                    <button onclick="setSelectionMode('nodeToTag')" id="nodeToTagMode" style="display: none;"
                        title="Set selection mode to Node to Tag: clicking a node selects it and all its ancestors up to the first tagged node">Node2Tag</button>
                    <button onclick="setSelectionMode('box')" id="boxMode"
                        title="Set selection mode to Box: click and drag to select multiple leaves within a rectangular area">Box
                        Select</button>
<!--
                    <medium>Expand:</medium>
                    <button onclick="expandSelectionDown()"
                        title="Expand the current selection to include all descendants of selected nodes">Down</button>
                    <button onclick="expandSelectionUp()"
                        title="Expand the current selection upwards, selecting parent nodes if all their children are selected">Up</button>
-->
                    <strong> Tag Selected: </strong>
                    <input type="text" id="regexInput" placeholder="Enter regex" style="display: none;"
                        title="Enter a regular expression to match node names">
                    <button onclick="selectRegexMatches()" style="display: none;"
                            title="Select all nodes whose names match the entered regular expression">Select
                            Matches</button>

                        <select id="tagDropdown" style="display: inline-block;"
                            title="Select a tag to apply to the selected nodes">
                            <option value="Tag">Tag</option>
                            <option value="NoTag">NoTag</option>
                            <option value="HM">HM</option>
                            <option value="Rec">Rec</option>
                            <option value="MxL1">MxL1</option>
                            <option value="MxL2">MxL2</option>
                            <option value="MxL3">MxL3</option>
                            <option value="MxL4">MxL4</option>
                            <option value="MxL5">MxL5</option>
                        </select>
                        <button onclick="showTagDropdown()" title="Tag selected nodes" style="display: none;">Tag Selection </button>
                        <button onclick="tagSelection('')" title="Remove tags from all currently selected nodes" style="display: none;">Tag
                                None</button>

                        <button onclick="clearSelection()" title="Accept tagging and clear current selection">Accept and Clear</button>
                        <button onclick="rejectTagsAndClearSelection()" title="Reject new tags, restore original tags, and clear selection">Revert and Clear</button>
        </div>
        <div id="content-container">
            <div id="left-panel">
                <div id="sliders-container" class="horizontal-slider-container">
                    <label for="verticalScale" title="Adjust the vertical spacing between nodes">Vertical:</label>
                    <input type="range" id="verticalScale" min="1" max="100" value="20"
                        title="Adjust the vertical spacing between nodes">
               
                    <label for="horizontalScale" title="Adjust the horizontal spacing between nodes">Horizontal:</label>
                    <input type="range" id="horizontalScale" min="1" max="2000" value="200"
                        title="Adjust the horizontal spacing between nodes">
                
                    <label for="textSize" title="Adjust the size of the node labels">Text Size:</label>
                    <input type="range" id="textSize" min="0" max="40" value="10"
                        title="Adjust the size of the node labels">
                    <label for="boxWidth" title="Adjust the width of alignment boxes">Box Width:</label>
                    <input type="range" id="boxWidth" min="1" max="25" value="1" step="1" disabled
                            title="Adjust the width of alignment boxes">
                    <span id="boxWidthValue">1</span>
                </div>
                
            </div>
            <div id="visualization-container">
                <div id="canvasContainer">
                    <canvas id="treeCanvas"></canvas>
                </div>
                <div id="alignmentContainer">
                    <svg id="alignmentSVG"></svg>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Add these near the top of your script with other global variables
        let originalNewickFileName = 'phylogenetic_tree.nwk';
        let originalAlignmentFileName = 'alignment.fasta';

        class Node {
            constructor(name = "", length = 0) {
                this.name = name;
                this.length = length;
                this.children = [];
                this.x = 0;
                this.y = 0;
                this.depth = 0;
                this.selected = false;
                this.tag = "";
            }
        }

        let root;
        let horizontalScale = 200;
        let verticalScale = 20;
        let textSize = 10;
        let selectionMode = 'clade';
        let maxTreeDistance = 1; // New variable to store the maximum tree distance

        let isBoxSelecting = false;
        let boxStartX, boxStartY, boxEndX, boxEndY;
        let drawBoxStartX, drawBoxStartY, drawBoxEndX, drawBoxEndY;
        let isMouseDown = false;

        let alignment = null;
        let alignmentAlphabet = null;
        let alignmentColorMap = null;

        let boxWidth = 1;

        // Define the tags array at the top of your script
        const TAGS = ['NoTag', 'HM', 'Rec', 'MxL1', 'MxL2', 'MxL3', 'MxL4', 'MxL5'];

        // Define colors for tags
        const TAG_COLORS = {
            default: 'rgba(0,0,0,1.0)',
            defaultSelected: 'rgba(100,100,100,0.4)',
            NoTag: 'rgba(0,0,0,1.0)',
            NoTagSelected: 'rgba(100,100,100,0.4)',
            HM: 'rgba(255,0,0,1.0)',
            HMSelected: 'rgba(255,100,100,0.4)',
            Rec: 'rgba(0,0,255,1.0)',
            RecSelected: 'rgba(100,100,255,0.4)',
            MxL1: 'rgba(0,255,0,1.0)',
            MxL1Selected: 'rgba(100,255,100,0.4)',
            MxL2: 'rgba(255,165,0,1.0)',
            MxL2Selected: 'rgba(255,200,100,0.4)',
            MxL3: 'rgba(128,0,128,1.0)',
            MxL3Selected: 'rgba(200,100,200,0.4)',
            MxL4: 'rgba(0,128,128,1.0)',  // Teal
            MxL4Selected: 'rgba(100,200,200,0.4)',
            MxL5: 'rgba(128,128,0,1.0)',  // Olive
            MxL5Selected: 'rgba(200,200,100,0.4)'
        };

        function handleMouseDown(event) {
            isMouseDown = true;
            const canvas = document.getElementById('treeCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            if (selectionMode === 'box') {
                isBoxSelecting = true;
                boxStartX = x;
                boxStartY = y;
                boxEndX = x;
                boxEndY = y;
                drawBoxStartX = event.clientX - rect.left - 50;
                drawBoxStartY = event.clientY - rect.top - 50;
                drawBoxEndX = event.clientX - rect.left - 50;
                drawBoxEndY = event.clientY - rect.top - 50;
            }
        }

        function createTaggedNewick(node) {
            if (node.children.length === 0) {
                let name = node.name;
                if (node.tag) {
                    // name += (name ? "{" + node.tag + "}" : "{" + node.tag + "}");
                    name += (name ? "_" + node.tag : node.tag );
                }
                return name + ":" + node.length;
            } else {
                let newick = "(";
                newick += node.children.map(child => createTaggedNewick(child)).join(",");
                newick += ")";
                if (node.name || node.tag) {
                    let name = node.name;
                    // if (node.tag) {
                    //    name += (name ? "{" + node.tag + "}" : "{" + node.tag + "}");
                    // }
                    newick += name;
                }
                newick += ":" + node.length;
                return newick;
            }
        }

        function exportTaggedNewick() {
            const newickString = createTaggedNewick(root) + ";";
            const blob = new Blob([newickString], { type: "text/plain;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = "tagged_tree.newick";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function parseNewick(newickString) {
            function parseNode() {
                let node = new Node();
                if (newickString[index] === '(') {
                    index++;
                    while (newickString[index] !== ')') {
                        node.children.push(parseNode());
                        if (newickString[index] === ',') index++;
                    }
                    index++;
                }
                let nameAndLength = '';
                while (index < newickString.length && ![',', ')', ';'].includes(newickString[index])) {
                    nameAndLength += newickString[index];
                    index++;
                }
                let [name, length] = nameAndLength.split(':');
                
                // Check for tag in the name
                let tag = '';
                let lastUnderscoreIndex = name.lastIndexOf('_');
                if (lastUnderscoreIndex !== -1) {
                    let possibleTag = name.substring(lastUnderscoreIndex + 1);
                    if (TAGS.includes(possibleTag)) {
                        tag = possibleTag;
                        name = name.substring(0, lastUnderscoreIndex);
                    }
                }
                
                node.name = name || '';
                node.length = length ? parseFloat(length) : 0;
                node.tag = tag;
                return node;
            }
            let index = 0;
            return parseNode();
        }

        function calculateDepths(node, depth = 0) {
            node.depth = depth;
            let maxChildDepth = depth;
            for (let child of node.children) {
                maxChildDepth = Math.max(maxChildDepth, calculateDepths(child, depth + child.length));
            }
            return maxChildDepth;
        }

        // New function to calculate the maximum tree distance
        function calculateMaxTreeDistance(node, currentDistance = 0) {
            if (node.children.length === 0) {
                return currentDistance;
            }
            let maxDistance = 0;
            for (let child of node.children) {
                const childDistance = calculateMaxTreeDistance(child, currentDistance + child.length);
                maxDistance = Math.max(maxDistance, childDistance);
            }
            return maxDistance;
        }

        function calculatePositions(node, y = 0, leafCount = { count: 0 }, maxDepth) {
            const normalizedLength = node.length / maxTreeDistance;
            node.y = (y + normalizedLength) * horizontalScale;
            if (node.children.length === 0) {
                node.x = leafCount.count * verticalScale;
                leafCount.count++;
            } else {
                for (let child of node.children) {
                    calculatePositions(child, y + normalizedLength, leafCount, maxDepth);
                }
                node.x = node.children.reduce((sum, child) => sum + child.x, 0) / node.children.length;
            }
        }

        function drawNode(node, ctx) {
            const defaultWidth = 1;
            const selWidth = 3;
            ctx.lineWidth = node.selected ? selWidth : defaultWidth;

            let nodeColor = TAG_COLORS.default;
            if (node.tag && TAG_COLORS[node.tag]) {
                nodeColor = node.selected ? TAG_COLORS[node.tag + 'Selected'] : TAG_COLORS[node.tag];
            } else {
                nodeColor = node.selected ? TAG_COLORS.defaultSelected : TAG_COLORS.default;
            }

            ctx.fillStyle = nodeColor;
            ctx.strokeStyle = nodeColor;

            const circsize = node.selected ? 3 : 2;
            ctx.beginPath();
            ctx.arc(node.y, node.x, circsize, 0, 2 * Math.PI);
            ctx.fill();

            if (node.children.length > 0) {
                for (let child of node.children) {
                    let childColor = TAG_COLORS.default;
                    if (child.tag && TAG_COLORS[child.tag]) {
                        childColor = child.selected ? TAG_COLORS[child.tag + 'Selected'] : TAG_COLORS[child.tag];
                    } else {
                        childColor = child.selected ? TAG_COLORS.defaultSelected : TAG_COLORS.default;
                    }
                    ctx.strokeStyle = childColor;
                    ctx.lineWidth = child.selected ? selWidth : defaultWidth;
                    ctx.beginPath();
                    ctx.moveTo(node.y, node.x);
                    ctx.lineTo(node.y, child.x);
                    ctx.lineTo(child.y, child.x);
                    ctx.stroke();
                    drawNode(child, ctx);
                }
            }

            if (node.name && textSize > 0) {
                ctx.save();
                ctx.translate(node.y, node.x);
                ctx.font = `${textSize}px Arial`;
                ctx.fillStyle = nodeColor;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                let textNode = node.name;
                if (node.tag) {
                    textNode = textNode + "_" + node.tag;
                }
                ctx.fillText(textNode, 5, 0);
                ctx.restore();
            }
        }

        function getAllNodes(node) {
            let nodes = [node];
            for (let child of node.children) {
                nodes = nodes.concat(getAllNodes(child));
            }
            return nodes;
        }

        function draw(root) {
            const maxDepth = calculateDepths(root);
            calculatePositions(root, 0, { count: 0 }, maxDepth);

            const canvas = document.getElementById('treeCanvas');
            const ctx = canvas.getContext('2d');

            const maxY = Math.max(...getAllNodes(root).map(n => n.y)) + 500;
            const maxX = Math.max(...getAllNodes(root).map(n => n.x)) + 200;
            canvas.width = maxY;
            canvas.height = maxX;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.translate(50, 50);

            drawNode(root, ctx);

            if (selectionMode === 'box' && isBoxSelecting && drawBoxStartX !== undefined) {
                ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
                ctx.fillStyle = 'rgba(0, 0, 255, 0.1)';
                ctx.lineWidth = 2;
                const width = drawBoxEndX - drawBoxStartX;
                const height = drawBoxEndY - drawBoxStartY;
                // Adjust for the canvas translation
                ctx.strokeRect(drawBoxStartX, drawBoxStartY, width, height);
                ctx.fillRect(drawBoxStartX, drawBoxStartY, width, height);
            }

            if (alignment) {
                drawAlignment();
            }
        }
        function drawTree() {
            const newickString = document.getElementById('newickInput').value.trim();
            if (!newickString) {
                alert('Please enter a valid Newick string.');
                return;
            }
            root = parseNewick(newickString);

            // Calculate the maximum tree distance
            maxTreeDistance = calculateMaxTreeDistance(root);

            draw(root);
        }

        function updateScales() {
            horizontalScale = parseInt(document.getElementById('horizontalScale').value);
            verticalScale = parseInt(document.getElementById('verticalScale').value);
            textSize = parseInt(document.getElementById('textSize').value);
            draw(root);
        }

        function selectSubtree(node) {
            node.selected = !node.selected;
            if (node.children) {
                for (let child of node.children) {
                    selectSubtree(child);
                }
            }
        }

        function tagSelection(tag) {
            function tagSubtree(node) {
                if (node.selected) {
                    node.tag = tag === 'NoTag' ? '' : tag;
                }
                if (node.children) {
                    for (let child of node.children) {
                        tagSubtree(child);
                    }
                }
            }
            tagSubtree(root);
            draw(root);
        }

        function clearSelection() {
            function clearSubtree(node) {
                node.selected = false;
                if (node.children) {
                    for (let child of node.children) {
                        clearSubtree(child);
                    }
                }
            }
            clearSubtree(root);
            draw(root);
        }

        function setSelectionMode(mode) {
            selectionMode = mode;
            document.querySelectorAll('#mode-controls button').forEach(btn => {
                btn.style.fontWeight = btn.id === mode + 'Mode' ? 'bold' : 'normal';
            });

            // Reset box selection variables when changing modes
            isBoxSelecting = false;
            boxStartX = boxStartY = boxEndX = boxEndY = undefined;
            drawBoxStartX = drawBoxStartY = drawBoxEndX = drawBoxEndY = undefined;
        }

        function selectNode(node) {
            node.selected = !node.selected;
        }

        function selectClade(node) {
            function selectLeaves(currentNode) {
                if (currentNode.children.length === 0) {
                    currentNode.selected = !currentNode.selected;
                } else {
                    for (let child of currentNode.children) {
                        selectLeaves(child);
                    }
                }
            }
            selectLeaves(node);
        }

        function selectNodeToRoot(node) {
            while (node) {
                node.selected = !node.selected;
                node = findParent(root, node);
            }
        }

        function selectNodeToTag(node) {
            while (node && !node.tag) {
                node.selected = !node.selected;
                node = findParent(root, node);
            }
        }

        function findParent(currentNode, targetNode) {
            if (currentNode === targetNode) {
                return null;
            }
            for (let child of currentNode.children) {
                if (child === targetNode) {
                    return currentNode;
                }
                const found = findParent(child, targetNode);
                if (found) {
                    return found;
                }
            }
            return null;
        }

        function exportSVG() {
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            const maxDepth = calculateDepths(root);
            calculatePositions(root, 0, { count: 0 }, maxDepth);

            const allNodes = getAllNodes(root);
            const maxY = Math.max(...allNodes.map(n => n.x)) + 200;
            let maxX = Math.max(...allNodes.map(n => n.y)) + 500;

            // If alignment is loaded, add space for it
            if (alignment) {
                maxX += Object.values(alignment)[0].length * boxWidth;
            }

            svg.setAttribute("width", maxX);
            svg.setAttribute("height", maxY);
            svg.setAttribute("viewBox", `0 0 ${maxX} ${maxY}`);

            function drawNodeSVG(node) {
                let nodeColor = TAG_COLORS.default;
                if (node.tag && TAG_COLORS[node.tag]) {
                    nodeColor = node.selected ? TAG_COLORS[node.tag + 'Selected'] : TAG_COLORS[node.tag];
                } else {
                    nodeColor = node.selected ? TAG_COLORS.defaultSelected : TAG_COLORS.default;
                }

                const circSize = node.selected ? 3 : 2;
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", node.y + 50);
                circle.setAttribute("cy", node.x + 50);
                circle.setAttribute("r", circSize);
                circle.setAttribute("fill", nodeColor);
                svg.appendChild(circle);

                if (node.children.length > 0) {
                    for (let child of node.children) {
                        let childColor = TAG_COLORS.default;
                        if (child.tag && TAG_COLORS[child.tag]) {
                            childColor = child.selected ? TAG_COLORS[child.tag + 'Selected'] : TAG_COLORS[child.tag];
                        } else {
                            childColor = child.selected ? TAG_COLORS.defaultSelected : TAG_COLORS.default;
                        }

                        const line = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        line.setAttribute("d", `M${node.y + 50},${node.x + 50} V${child.x + 50} H${child.y + 50}`);
                        line.setAttribute("stroke", childColor);
                        line.setAttribute("stroke-width", child.selected ? 3 : 1);
                        line.setAttribute("fill", "none");
                        svg.appendChild(line);

                        drawNodeSVG(child);
                    }
                }

                if (node.name && textSize > 0) {
                    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    text.setAttribute("x", node.y + 50 + textSize/2);
                    text.setAttribute("y", node.x + 50);
                    text.setAttribute("font-family", "Arial");
                    text.setAttribute("font-size", textSize);
                    text.setAttribute("text-anchor", "start");
                    text.setAttribute("dominant-baseline", "middle");
                    text.setAttribute("fill", nodeColor);  // Set the text color to match the node color
                    let textNode = node.name;
                    if (node.tag) {
                        textNode = textNode + "_" + node.tag;
                    }   
                    text.textContent = textNode;
                    svg.appendChild(text);
                }
            }

            drawNodeSVG(root);

            // Draw alignment if it exists
            if (alignment) {
                const treeWidth = Math.max(...allNodes.map(n => n.y)) + 500;
                const leafNodes = getLeafNodes(root);
                const seqLength = Object.values(alignment)[0].length;
                const referenceSeq = Object.values(alignment)[0].toUpperCase();

                leafNodes.forEach((node, index) => {
                    const seq = alignment[node.name];
                    if (!seq) return;

                    const upperSeq = seq.toUpperCase();
                    const yPosition = node.x + 50 - verticalScale / 2;

                    if (index === 0) {
                        // Draw the full reference sequence
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', treeWidth);
                        rect.setAttribute('y', yPosition);
                        rect.setAttribute('width', seqLength * boxWidth);
                        rect.setAttribute('height', textSize);
                        rect.setAttribute('fill', '#F0F0F0'); // Light gray background
                        svg.appendChild(rect);

                    for (let x = 0; x < seqLength; x++) {
                        const charRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        charRect.setAttribute('x', treeWidth + x * boxWidth);
                        charRect.setAttribute('y', yPosition);
                        charRect.setAttribute('width', boxWidth);
                        charRect.setAttribute('height', textSize);
                        charRect.setAttribute('fill', alignmentColorMap[upperSeq[x]] || '#F0F0F0');
                    svg.appendChild(charRect);
                }
            } else {
                // Draw only differences from the reference sequence
                for (let x = 0; x < seqLength; x++) {
                    if (upperSeq[x] !== referenceSeq[x]) {
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        rect.setAttribute('x', treeWidth + x * boxWidth);
                        rect.setAttribute('y', yPosition);
                        rect.setAttribute('width', boxWidth);
                        rect.setAttribute('height', textSize);
                        rect.setAttribute('fill', alignmentColorMap[upperSeq[x]] || '#F0F0F0');
                        svg.appendChild(rect);
                    }
                }
            }

                });
            }

            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svg);
            const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = originalNewickFileName.replace(/\.[^/.]+$/, ".svg");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function handleCanvasClick(event) {
            const canvas = document.getElementById('treeCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left - 50;
            const y = event.clientY - rect.top - 50;

            if (selectionMode === 'box') {
                if (!isBoxSelecting) {
                    // Start box selection
                    isBoxSelecting = true;
                    boxStartX = x;
                    boxStartY = y;
                    drawBoxStartX = x;
                    drawBoxStartY = y;
                } else {
                    // End box selection
                    isBoxSelecting = false;
                    boxEndX = x;
                    boxEndY = y;
                    drawBoxEndX = x;
                    drawBoxEndY = y;
                    selectNodesInBox();
                }
            } else {
                // Existing node selection logic
                function findClickedNode(node) {
                    const tolerance = 5;
                    if (Math.abs(node.y - x) < tolerance && Math.abs(node.x - y) < tolerance) {
                        return node;
                    }
                    for (let child of node.children) {
                        const found = findClickedNode(child);
                        if (found) return found;
                    }
                    return null;
                }

                const clickedNode = findClickedNode(root);
                if (clickedNode) {
                    switch (selectionMode) {
                        case 'clade':
                            selectClade(clickedNode);
                            break;
                        case 'node':
                            selectNode(clickedNode);
                            break;
                        case 'nodeToRoot':
                            selectNodeToRoot(clickedNode);
                            break;
                        case 'nodeToTag':
                            selectNodeToTag(clickedNode);
                            break;
                    }
                }
            }
            draw(root);
        }

        function handleMouseMove(event) {
            if (selectionMode === 'box' && isBoxSelecting) {
                const canvas = document.getElementById('treeCanvas');
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                boxEndX = (event.clientX - rect.left) * scaleX;
                boxEndY = (event.clientY - rect.top) * scaleY;
                drawBoxEndX = event.clientX - rect.left - 50;
                drawBoxEndY = event.clientY - rect.top - 50;
                draw(root);
            }
        }

        function handleMouseUp(event) {
            isMouseDown = false;
            const canvas = document.getElementById('treeCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            if (selectionMode === 'box') {
                isBoxSelecting = false;
                boxEndX = x;
                boxEndY = y;
                drawBoxEndX = event.clientX - rect.left - 50;
                drawBoxEndY = event.clientY - rect.top - 50;
                selectNodesInBox();
            } else {
                // Only handle selection for non-box modes on mouseup
                handleNodeSelection(x, y);
            }
            draw(root);
        }

        function handleNodeSelection(x, y) {
            function findClickedNode(node) {
                const tolerance = 5;
                // Adjust node coordinates to match canvas coordinates
                const nodeX = node.x + 50;
                const nodeY = node.y + 50;
                if (Math.abs(nodeY - x) < tolerance && Math.abs(nodeX - y) < tolerance) {
                    return node;
                }
                for (let child of node.children) {
                    const found = findClickedNode(child);
                    if (found) return found;
                }
                return null;
            }

            const clickedNode = findClickedNode(root);
            if (clickedNode) {
                switch (selectionMode) {
                    case 'clade':
                        selectClade(clickedNode);
                        break;
                    case 'node':
                        selectNode(clickedNode);
                        break;
                    case 'nodeToRoot':
                        selectNodeToRoot(clickedNode);
                        break;
                    case 'nodeToTag':
                        selectNodeToTag(clickedNode);
                        break;
                }
            }
        }

        function selectNodesInBox() {
            const canvas = document.getElementById('treeCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const left = Math.min(boxStartX, boxEndX) * scaleX;
            const right = Math.max(boxStartX, boxEndX) * scaleX;
            const top = Math.min(boxStartY, boxEndY) * scaleY;
            const bottom = Math.max(boxStartY, boxEndY) * scaleY;

            function checkNodeInBox(node) {
                // Adjust node coordinates to match canvas coordinates
                const nodeX = node.x + 50;
                const nodeY = node.y + 50;

                if (node.children.length === 0) {  // Only select leaf nodes
                    if (nodeY >= left && nodeY <= right && nodeX >= top && nodeX <= bottom) {
                        node.selected = !node.selected;  // Toggle selection
                    }
                } else {
                    for (let child of node.children) {
                        checkNodeInBox(child);
                    }
                }
            }

            checkNodeInBox(root);
        }

        function expandSelectionDown() {
            function selectDescendants(node) {
                if (node.selected) {
                    for (let child of node.children) {
                        child.selected = true;
                    }
                }
                for (let child of node.children) {
                    selectDescendants(child);
                }
            }
            selectDescendants(root);
            draw(root);
        }

        function expandSelectionUp() {
            let changed = true;
            while (changed) {
                changed = false;
                function checkAndSelectParent(node) {
                    if (node.children.length > 0 && !node.selected) {
                        if (node.children.every(child => child.selected)) {
                            node.selected = true;
                            changed = true;
                        }
                    }
                }

                function traverseUp(node) {
                    for (let child of node.children) {
                        traverseUp(child);
                    }
                    checkAndSelectParent(node);
                }

                traverseUp(root);
            }
            draw(root);
        }

        function selectRegexMatches() {
            const regexString = document.getElementById('regexInput').value;
            try {
                const regex = new RegExp(regexString);

                function searchNodes(node) {
                    if (node.name && regex.test(node.name)) {
                        node.selected = true;
                    }
                    for (let child of node.children) {
                        searchNodes(child);
                    }
                }

                searchNodes(root);
                draw(root);
            } catch (error) {
                alert('Invalid regular expression');
            }
        }

        function loadNewickFile(event) {
            const file = event.target.files[0];
            if (file) {
                originalNewickFileName = file.name;
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById('newickInput').value = e.target.result.trim();
                    drawTree();
                };
                reader.readAsText(file);
            }
        }

        function loadAlignmentFile(event) {
            const file = event.target.files[0];
            if (file) {
                originalAlignmentFileName = file.name;
                const reader = new FileReader();
                reader.onload = function(e) {
                    parseAlignment(e.target.result);
                };
                reader.readAsText(file);
            }
        }

        function showTagDropdown() {
            const tagDropdown = document.getElementById('tagDropdown');
            tagDropdown.innerHTML = ''; // Clear existing options

            TAGS.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                tagDropdown.appendChild(option);
            });

            tagDropdown.style.display = 'inline-block';
            tagDropdown.onchange = function() {
                // Store previous tags before applying new ones
                storePreviousTags();
                tagSelection(this.value);
                this.value = 'NoTag';  // Reset to NoTag after selection
                // this.style.display = 'none';
            };
        }

        let selectedNodesPreviousTags = new Map();

        function storePreviousTags() {
            selectedNodesPreviousTags.clear();
            function storeTagsSubtree(node) {
                if (node.selected) {
                    selectedNodesPreviousTags.set(node, node.tag);
                }
                if (node.children) {
                    for (let child of node.children) {
                        storeTagsSubtree(child);
                    }
                }
            }
            storeTagsSubtree(root);
        }

        function rejectTagsAndClearSelection() {
            function rejectTagsSubtree(node) {
                if (node.selected) {
                    if (selectedNodesPreviousTags.has(node)) {
                        node.tag = selectedNodesPreviousTags.get(node);
                    }
                    node.selected = false;
                }
                if (node.children) {
                    for (let child of node.children) {
                        rejectTagsSubtree(child);
                    }
                }
            }
            rejectTagsSubtree(root);
            selectedNodesPreviousTags.clear();
            draw(root);
        }

        // Modify the existing clearSelection function
        function clearSelection() {
            function clearSubtree(node) {
                if (node.selected) {
                    node.selected = false;
                }
                if (node.children) {
                    for (let child of node.children) {
                        clearSubtree(child);
                    }
                }
            }
            clearSubtree(root);
            selectedNodesPreviousTags.clear();
            draw(root);
        }

        function enableBoxWidthSlider() {
            const boxWidthSlider = document.getElementById('boxWidth');
            boxWidthSlider.disabled = false;
        }

        function updateBoxWidth() {
            boxWidth = parseInt(document.getElementById('boxWidth').value);
            document.getElementById('boxWidthValue').textContent = boxWidth;
            if (alignment) {
                drawAlignment();
            }
        }

        function parseAlignment(data) {
            const sequences = {};
            let currentSeq = '';
            let currentName = '';

            data.split('\n').forEach(line => {
                line = line.trim();
                if (line.startsWith('>')) {
                    if (currentName) {
                        let lastUnderscoreIndex = currentName.lastIndexOf('_');
                        let possibleTag = currentName.substring(lastUnderscoreIndex + 1);
                        if (TAGS.includes(possibleTag)) {
                            currentName = currentName.substring(0, lastUnderscoreIndex);
                        }
                        sequences[currentName] = currentSeq;
                    }
                    currentName = line.substring(1);
                    currentSeq = '';
                } else {
                    currentSeq += line;
                }
            });
            if (currentName) {
                let lastUnderscoreIndex = currentName.lastIndexOf('_');
                let possibleTag = currentName.substring(lastUnderscoreIndex + 1);
                if (TAGS.includes(possibleTag)) {
                    currentName = currentName.substring(0, lastUnderscoreIndex);
                }
                sequences[currentName] = currentSeq;
            }

            // Check if it's an alignment
            const lengths = Object.values(sequences).map(seq => seq.length);
            if (new Set(lengths).size !== 1) {
                alert('The uploaded file is not a valid alignment. All sequences must have the same length.');
                return;
            }

            // Check if sequence names match leaf names
            const leafNames = getLeafNames(root);
            if (!leafNames.every(name => name in sequences)) {
                alert('Sequence names in the alignment do not match leaf names in the tree.');
                return;
            }

            const seqLength = Object.values(sequences)[0].length;

            // Remove invariant columns
            const variantColumns = [];
            for (let i = 0; i < seqLength; i++) {
                const column = Object.values(sequences).map(seq => seq[i].toUpperCase());
                if (new Set(column).size > 1) {
                    variantColumns.push(i);
                }
            }

            // console.log(`Number of variant columns: ${variantColumns.length}`);

            for (const name in sequences) {
                sequences[name] = variantColumns.map(i => sequences[name][i]).join('');
            }

            // console.log(`New alignment length: ${sequences[Object.keys(sequences)[0]].length}`);

            alignment = sequences;
            alignmentAlphabet = getAlphabet();
            alignmentColorMap = getColorMap(alignmentAlphabet);
            
            enableBoxWidthSlider(); // Create the slider after parsing the alignment
            drawAlignment();
        }

        // Modify your existing loadAlignmentFile function
        function loadAlignmentFile(event) {
            const file = event.target.files[0];
            if (file) {
                originalAlignmentFileName = file.name;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    parseAlignment(e.target.result);
                };
                reader.readAsText(file);
            }
        }

        // Use event delegation for the alignment file input
        document.addEventListener('change', function(event) {
            if (event.target && event.target.id === 'alignmentFile') {
                loadAlignmentFile(event);
            }
        });

        function getLeafNames(node) {
            if (node.children.length === 0) {
                return [node.name];
            }
            return node.children.flatMap(getLeafNames);
        }

        function getAlphabet() {
            const nucs = new Set(['A', 'T', 'C', 'G', 'N', '-']);
            const allChars = new Set(Object.values(alignment).join('').toUpperCase());
            if (allChars.isSubsetOf(nucs)) {
                return 'ACGTN-';
            }
            return 'ACDEFGHIKLMNPQRSTVWY-';
        }

        function getColorMap(alphabet) {
            const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#800000', '#008000', '#000080', '#808000', '#800080', '#008080', '#C0C0C0', '#808080', '#9999FF', '#993366', '#FFFFCC', '#CCFFFF', '#660066', '#FF8080', '#0066CC', '#CCCCFF'];
            const colorMap = {};
            alphabet.split('').forEach((char, i) => {
                if (char === '-') {
                    colorMap[char] = '#808080'; // Gray for gap character
                } else {
                    colorMap[char] = colors[i % colors.length];
                }
            });
            return colorMap;
        }

        const ALIGNMENT_TOP_PADDING = 50; // You can adjust this value as needed
        const ALIGNMENT_BOTTOM_PADDING = 50;

        function drawAlignment() {
            if (!alignment || !alignmentAlphabet || !alignmentColorMap) return;

            const svg = document.getElementById('alignmentSVG');
            const seqLength = Object.values(alignment)[0].length;
            const leafNodes = getLeafNodes(root);
            const treeHeight = Math.max(...leafNodes.map(node => node.x)) + 100; // Keep existing padding

            svg.setAttribute('width', seqLength * boxWidth);
            svg.setAttribute('height', treeHeight + ALIGNMENT_TOP_PADDING + ALIGNMENT_BOTTOM_PADDING);

            svg.innerHTML = ''; // Clear previous content

            const referenceSeq = Object.values(alignment)[0].toUpperCase();

            leafNodes.forEach((node, index) => {
                const seq = alignment[node.name];
                if (!seq) return;

                const upperSeq = seq.toUpperCase();
                const yPosition = node.x - textSize / 2+ ALIGNMENT_TOP_PADDING; // Add padding to y-position

                if (index === 0) {
                    // Draw the full reference sequence
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', 0);
                    rect.setAttribute('y', yPosition);
                    rect.setAttribute('width', seqLength * boxWidth);
                    rect.setAttribute('height', textSize); //verticalScale);
                    rect.setAttribute('fill', '#F0F0F0'); // Light gray background
                    svg.appendChild(rect);

                    for (let x = 0; x < seqLength; x++) {
                        const charRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        charRect.setAttribute('x', x * boxWidth);
                        charRect.setAttribute('y', yPosition);
                        charRect.setAttribute('width', boxWidth);
                        charRect.setAttribute('height', textSize); // verticalScale / 2);
                        charRect.setAttribute('fill', alignmentColorMap[upperSeq[x]] || '#F0F0F0');
                        svg.appendChild(charRect);
                    }
                } else {
                    // Draw only differences from the reference sequence
                    for (let x = 0; x < seqLength; x++) {
                        if (upperSeq[x] !== referenceSeq[x]) {
                            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            rect.setAttribute('x', x * boxWidth);
                            rect.setAttribute('y', yPosition);
                            rect.setAttribute('width', boxWidth);
                            rect.setAttribute('height', textSize); // verticalScale / 2);
                            rect.setAttribute('fill', alignmentColorMap[upperSeq[x]] || '#F0F0F0');
                            svg.appendChild(rect);
                        }
                    }
                }
            });

            synchronizeScrolling();
        }

        function getLeafNodes(node) {
            if (node.children.length === 0) {
                return [node];
            }
            return node.children.flatMap(getLeafNodes);
        }

        function synchronizeScrolling() {
            const canvasContainer = document.getElementById('canvasContainer');
            const alignmentContainer = document.getElementById('alignmentContainer');

            canvasContainer.onscroll = function() {
                alignmentContainer.scrollTop = this.scrollTop;
            };

            alignmentContainer.onscroll = function() {
                canvasContainer.scrollTop = this.scrollTop;
            };
        }

        function exportAlignment() {
            if (!alignment) {
                alert('No alignment loaded. Please load an alignment first.');
                return;
            }

            let fastaContent = '';
            const leafNodes = getLeafNodes(root);

            leafNodes.forEach(node => {
                if (alignment[node.name]) {
                    let name = node.name;
                    if (node.tag && node.tag !== 'NoTag') {
                        name += '_' + node.tag;
                    }
                    fastaContent += '>' + name + '\n';
                    fastaContent += alignment[node.name] + '\n';
                }
            });

            const blob = new Blob([fastaContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = originalAlignmentFileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function exportNewick() {
            
            function generateNewick(node) {
                if (node.children.length === 0) {
                    let name = node.name;
                    if (node.tag && node.tag !== 'NoTag') {
                        name += '_' + node.tag;
                    }
                    return name + ':' + node.length;
                } else {
                    const childrenNewick = node.children.map(generateNewick).join(',');
                    let nodeNewick = '(' + childrenNewick + ')';
                    if (node.name || node.tag) {
                        let name = node.name || '';
                        if (node.tag && node.tag !== 'NoTag') {
                            name += (name ? '_' : '') + node.tag;
                        }
                        nodeNewick += name;
                    }
                    return nodeNewick + ':' + node.length;
                }
            }

            const newickString = generateNewick(root) + ';';
            const blob = new Blob([newickString], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = originalNewickFileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Ensure the function is accessible globally
        window.exportNewick = exportNewick;


        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('horizontalScale').addEventListener('input', updateScales);
            document.getElementById('verticalScale').addEventListener('input', updateScales);
            document.getElementById('textSize').addEventListener('input', updateScales);
            document.getElementById('boxWidth').addEventListener('input', updateBoxWidth);
            document.getElementById('treeCanvas').addEventListener('mousedown', handleMouseDown);
            document.getElementById('treeCanvas').addEventListener('mousemove', handleMouseMove);
            document.getElementById('treeCanvas').addEventListener('mouseup', handleMouseUp);
            document.getElementById('newickFile').addEventListener('change', loadNewickFile);
            document.getElementById('boxWidthValue').textContent = boxWidth;

            // Initial draw
            drawTree();
            setSelectionMode('clade');
            showTagDropdown();

            const exportNewickButton = document.getElementById('exportNewickButton');
            if (exportNewickButton) {
        exportNewickButton.addEventListener('click', exportNewick);
    }
        });

    </script>
</body>

</html>
