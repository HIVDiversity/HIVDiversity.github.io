<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <!-- Latest compiled and minified CSS -->
    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
    
    <link
      rel="stylesheet"
      href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"
      integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm"
      crossorigin="anonymous"
    />
    <!--
    <link
      href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css"
      rel="stylesheet"
    />
    -->

   
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0">   -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- need the following for implementing NNMF algorithm
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    -->
    <script src="js/phylotree.js"></script>
 
    <!-- <link href="css/phylotree.css" rel="stylesheet" /> -->
 
 <defs>
     <style type="text/css">
         @import url("css/phylotree.css");
     </style>
 </defs>
 
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 300px;
            text-align: center;
        }
        .grid-container {
            display: grid;
            grid-template-columns: 20px 1fr;
            grid-template-rows: 20px 1fr;
            gap: 5px;
            height: 400px;
            margin: 20px 0;
        }
        .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            border: 1px solid #ddd;
        }
        #results-container {
            display: flex;
            gap: 20px;
        }
        #results-container, #alignDifference-container {
            flex: 1;
            white-space: pre-wrap;
            border: 1px solid #ccc;
            padding: 10px;
            max-height: 600px;
            overflow-y: auto;
        }
        #alignDifference-container {
            overflow-x: auto;
        }
        #scatter-align-container {
            display: flex;
            width: 100%;
            overflow: hidden;
        }
        #scatter-container, #align-container {
            overflow-x: auto;
            overflow-y: scroll;
            height: 400px;
        }
        #scatter-container {
            width: 49%;
            margin-right: 1%;
        }
        #align-container {
            width: 48%;
            margin-left: 1%;
        }
    
      nav {
        margin-bottom: 25px;
      }
      .fa-rotate-45 {
        -webkit-transform: rotate(45deg);
        -moz-transform: rotate(45deg);
        -ms-transform: rotate(45deg);
        -o-transform: rotate(45deg);
        transform: rotate(45deg);
      }
      .fa-rotate-135 {
        -webkit-transform: rotate(135deg);
        -moz-transform: rotate(135deg);
        -ms-transform: rotate(135deg);
        -o-transform: rotate(135deg);
        transform: rotate(135deg);
      }

      @media (max-width: 1075px) {
        .container {
          padding-top: 50px;
          padding-bottom: 50px;
        }
      }

      .btn {
        height: 30px;
      }

      #toolbar {
        display: flex;
        justify-content: space-between;
        width: 800px;
      }

      #controls {
        position: fixed;
        left: 5px;
      }
        
        .branch {
        fill: none;
        stroke: #999;
        stroke-width: 2px;
        }

        .line {
           fill: none;
           stroke: #999;
           stroke-width: 2px;
        }
        
        .node circle, .node ellipse, .node rect {
        fill: steelblue;
        stroke: black;
        stroke-width: 0.5px;
        }
        
        #d3_layout_phylotree_context_menu.dropdown-menu{
          display: none;
          position: absolute;
        }
    </style>
  </head>

  <body>
    <!--
###############################################################################################################################
-->
    <h1>Alignment Clustering</h1>
    <h4>using <a href=https://en.wikipedia.org/wiki/DBSCAN target=blank>DBSCAN</a> on a 2D
        <a href=https://en.wikipedia.org/wiki/Principal_component_analysis target=blank>PCA</a> projection</h4>

            Load alignment in fasta format:<input type="file" id="fileInput" accept=".fasta,.fa">
                </input>
            <div id="fastaResults"></div>
            Load tree in newick format: <input type="file" id="treeFileInput" accept=".tree,.newick">
                </input>
            <div id="treeFileResults"></div>
            <button id="computeFeatures">Compute Feature Vectors</button>
            <div id="featureResults"></div>
            <div class="slider-container">
                <button id="decrease-s">-</button>
                <input type="range" id="s-slider" min="10" max="100" step="5" value="20">
                <button id="increase-s">+</button>&nbsp;
                s = <span id="s-value">20</span>%
            </div>
            <button id="subSample">Sample</button>
            <div id="sampleResults"></div>
    
            <button id="computePCA">Compute PCA</button>
            <div id="pcaResults"></div>
            <div id="scatterplot" style="display: none;"></div>
            
            
            <div id="slider-container">
                <button id="decrease-mp">-</button>
                <input type="range" id="mp-slider" min="3" max="7" value="5">
                <button id="increase-mp">+</button>&nbsp;
                mp = <span id="mp-value">5</span>&nbsp;
            </div>
            <div id="slider-container">
                <button id="decrease-r">-</button>
                <input type="range" id="rpc-slider" min="0.0" max="1.0" step="0.1" value="0.5">
                <button id="increase-r">+</button>&nbsp;
                r = <span id="r-value">1.0</span>&nbsp;
            </div>
            <button id="cluster">Cluster</button>&nbsp;
            <div id="clusterResults"></div>
            
            <div>
               <canvas id="alignment-canvas" style="display: none;"></canvas>
            </div>
            <button id="showClustersOnTree">Show Clusters on Tree</button>

     <!--
            <div id="scatter-align-container">
                <div id="scatter-container">
                    <div id="scatterplot"></div
                </div>
                <div id="align-container">
                    <canvas id="alignment-canvas"></canvas>
                </div>
            </div>
            <br><br>
       -->
    
    
      
 
       <!-- Old file loading button
              <a class="dropdown-item" href="#">
                <input type="file" id="newick_file"/>
              </a>
        <div id="histogram"></div>
        <div id="circle-canvas"></div>
        <div id="tree-canvas"></div>
        <br><br>
        -->
 <div id="treeDisplayBlock" style="display: none;">

 
    <div id="controls">
      <form id="controls_form" style="width:200px;"></form>
    </div>

        <div class="btn-toolbar" role="toolbar" id="toolbar">
            <div class="btn-group">
              <button
                type="button"
                class="btn btn-light btn-sm"
                data-direction="vertical"
                data-amount="1"
                title="Expand vertical spacing"
              >
                Expand
              </button>
              <button
                type="button"
                class="btn btn-light btn-sm"
                data-direction="vertical"
                data-amount="-1"
                title="Compress vertical spacing"
              >
                Compress
              </button>
            </div>
    
            <div class="btn-group">
              <button
                type="button"
                class="btn btn-light btn-sm"
                data-direction="horizontal"
                data-amount="1"
                title="Expand horizonal spacing"
              >
                Stretch
              </button>
              <button
                type="button"
                class="btn btn-light btn-sm"
                data-direction="horizontal"
                data-amount="-1"
                title="Compress horizonal spacing"
              >
                Shrink
              </button>
            </div>
            
            <div class="btn-group" style="display: none;">
              <button
                type="button"
                class="btn btn-light btn-sm"
                id="sort_ascending"
                title="Sort deepest clades to the bototm"
              >
                Ascend
              </button>
              <button
                type="button"
                class="btn btn-light btn-sm"
                id="sort_descending"
                title="Sort deepsest clades to the top"
              >
                Descend
              </button>
            </div>
            
            <div class="btn-group" role="group">
              <button
                class="btn btn-light btn-sm active phylotree-layout-mode"
                data-mode="linear"
              >
                Linear
              </button>
              <button
                class="btn btn-light btn-sm phylotree-layout-mode"
                data-mode="radial"
              >
                Radial
              </button>
            </div>
            
            <div class="btn-group">
              <button
                type="button"
                class="btn btn-light btn-sm"
                id="process_selected"
                title="Assign"
              >
                Assign
              </button>
              <button
                type="button"
                class="btn btn-light btn-sm"
                id="revert_selected"
                title="Revert"
              >
                Revert
              </button>
            </div>
            
            <div class="btn-group">
              <button
                type="button"
                class="btn btn-light btn-sm"
                id="save_image"
                title="Save image"
              >
                Download Image
              </button>
            </div>
            
            <div class="btn-group" role="group" id="align-group" style="display: none;">
              <button
                class="btn btn-light btn-sm active phylotree-align-toggler"
                data-align="left"
              >
                AlignLeft
              </button>
              <button
                class="btn btn-light btn-sm phylotree-align-toggler"
                data-align="right"
              >
                AlignRight
              </button>
            </div>
            
          </div>
        </div>
        
        <div>
          <label class="pull-right"
              ><b>Selected</b>
              <span class="badge badge-secondary" id="selected_branch_counter">0</span>
              <b>branches with current label</b>
          </label>
        </div>
        <div class="dropdown-menu" id="d3_layout_phylotree_context_menu">
       
      </div>
        <div id="result"></div>
      <div class="row">
        <div class="col-md-12">
            <!--- <svg id="tree_container" width="800" height="1600" style="display: none;"></svg>--->
            <div id="tree_container" class="phylotree-container"></div>
        </div>
      </div>
    </div>
</div>
    
    <button id="clusterAnnotate">Annotate and Download</button>
    <br><br>
    <a id="downloadLink" style="display: none;">Download Annotated FASTA</a>
    <br><br>
    
    <div id="dropdownModal" class="modal">
        <div class="modal-content">
            <h3>Select an Item</h3>
            <select id="itemList"></select>
        </div>
    </div>


    <!--
###############################################################################################################################
-->
    <script src="https://www.lactame.com/lib/ml/6.0.0/ml.min.js"></script>
    <script src="https://hivdiversity.github.io/webwidgets/js/DBSCAN.js"></script>

    <script>
  
  document.addEventListener('DOMContentLoaded', function() {
      
        let alignment=[];
        let reference="";
        let referenceName="";
        let founder="";
        let founderName="";
        let donerFile="";
        let treeFile="";
        let treeData="";
        let allSequences=[];
        let allFeatures=[];
        let subSampledFeatures=[];
        let sBound=100;
        let s=20;
        let projectedFeatures=[];
        let augmentedFeatures=[];
        let clusters=[];
        let clusterDict = {};
        let clusterColors=[];
        let manualClusterAssignment=0;
        let maxLineages=9;
        let lineageDict = {};
        let toBeReassigned = [];
        let visitNames = [];
        let rpcBound=1;
        let rpc=0.5;
        let pcMin=-1;
        let pcMax=1;
        let r=(pcMax-pcMin)*rpc;
        let mpBound=7;
        let mp=5;
        let alphabet="";
        let phyloCanvas=new Object();
        
        // Define the list of possible amino acids
        const aminoAcids = 'ACDEFGHIKLMNPQRSTVWY-';
        const nucleotides = 'ACGTN-'
        
        // needed to display alignment
        const aminoAcidColors = {
            'A': '#90A0CF', 'B': '#80CF98', 'C': '#CF90B0', 'D': '#CFCF70', 'E': '#CF90CF',
            'F': '#80C0C0', 'G': '#CFA060', 'H': '#C05070', 'I': '#C5AE83', 'J': '#00A7CF',
            'K': '#B54C4C', 'L': '#56B592', 'M': '#8AB52A', 'N': '#BE72BE', 'O': '#00B6A1',
            'P': '#00CF6F', 'Q': '#349B61', 'R': '#0000BB', 'S': '#A59F5B', 'T': '#009400',
            'U': '#B00000', 'V': '#B0B000', 'W': '#B000B0', 'X': '#00B0B0', 'Y': '#E8B613',
            'Z': '#C23232', '-': '#CFC9BB'
        };
        
        const nucleotideColors = {
            'A': '#458b00', 'C': '#6495ed', 'G': '#8b008b', 'T': '#ff7f50',
            'N': '#BE72BE', '-': '#CFC9BB'
        }
        
        let alphabetColors = {};

        
        
        // Check if PCA is available
        if (typeof ML === 'undefined' || typeof ML.PCA === 'undefined') {
            console.error('ML.PCA is not defined. The ml-pca library may not have loaded correctly.');
            return;
        }
       
        console.log(ML);       // for PCA
        console.log(DBSCAN);   // Density Based Clustering
        
        // function to shuffle an array
        function shuffle(array) {
            let currentIndex = array.length;
            // While there remain elements to shuffle...
            while (currentIndex != 0) {
                // Pick a remaining element...
                let randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                // And swap it with the current element.
                [array[currentIndex], array[randomIndex]] = [
                  array[randomIndex], array[currentIndex]];
            };
        };

        // Function to parse FASTA format
        function parseFasta(content) {
            const lines = content.split('\n');
            const sequences = [];
            alignment = [];
            maximum_node_name_length = 0;
            let visitNamesSet = new Set();
            let currentSequence = '';
            let currentName = '';
            let count=0;
            let alphaChars = new Set();
            for (const line of lines) {
                if (line.startsWith('>')) {
                    if (currentName) {
                        if (count<2 && currentName.toUpperCase().includes("HXB2")) {
                            referenceName = currentName;
                            reference = currentSequence;
                            count=0;
                        }
                        if (count<2 && currentName.toUpperCase().includes("CONSENSUS")) {
                            founderName = currentName;
                            founder = currentSequence;
                            count=1;
                        }
                        if (count>1) {
                            if (currentName.length > maximum_node_name_length) {
                                maximum_node_name_length = currentName.length;
                            }
                            visitNamesSet.add(currentName.split("_")[1]);
                            alignment.push({ name: currentName, sequence: currentSequence });
                            sequences.push(currentSequence);
                            currentSequence.split("").forEach(ch => alphaChars.add(ch))
                        }
                        count+=1;
                        currentSequence = '';
                    }
                    currentName = line.slice(1).trim();
                } else {
                    currentSequence += line.trim();
                }
            }

            if (currentName) {
                if (currentName.length > maximum_node_name_length) {
                    maximum_node_name_length = currentName.length;
                }
                visitNamesSet.add(currentName.split("_")[1]);
                alignment.push({ name: currentName, sequence: currentSequence });
                sequences.push(currentSequence);
                currentSequence.split("").forEach(ch => alphaChars.add(ch))
            }
            visitNames=[...visitNamesSet];
            // console.log(`visit names = ${visitNames}`);
            
            let testAlphabet = alphaChars.isSubsetOf(new Set(nucleotides));
            if (testAlphabet) {
                alphabet=nucleotides; // .substring(0,nucleotides.length-1);
                alphabetColors=aminoAcidColors;
                alert(`Nucleotide alignment with reference: ${referenceName}, founder: ${founderName} and ${sequences.length} sequences `);
            } else {
                alphabet=aminoAcids; // .substring(0,nucleotides.length-1);
                alphabetColors=nucleotideColors;
                alert(`Amino Acid alignment with reference: ${referenceName}, founder: ${founderName} and ${sequences.length} sequences `)
            }

            // referenceSequence = sequences[0].sequence
            return sequences;
        }
        
        function subSampleFeatures(features,pct) {
            let ret=features.slice(0,features.length);
            shuffle(ret);
            let rett=ret.slice(1,Math.floor((pct/100)*features.length));
            // rett.push(features[0])
            return rett
        };

       // Function to compute feature vectors
       // function computeFeatureVectors(sequences) {
       //     return sequences.map(seq => {
       //         const counts = new Array(20).fill(0);
       //         for (const aa of seq) {
       //             const index = alphabet.indexOf(aa.toUpperCase());
       //             if (index !== -1) counts[index]++;
       //         }
       //         return counts;
       //     });
       // }
        
       // function to compute one hot of an amino acid char
       function oneHotChar(aa) {
           onehot = new Array(alphabet.length).fill(0);
           const index = alphabet.indexOf(aa.toUpperCase());
           if (index !== -1) onehot[index]=1;
           return onehot;
       }
       
       // Function to degap one sequence wrt founder
       function degapSeq(s,f) {
           var sv = s.split('').map( (ch, index) => {
               return ( (ch == '-') ? f[index] : ch) ;
           });
           return sv.join("");
       }
       
        
        // Function to compute one-hot feature vectors
        function computeOneHot(sequences) {
            var degappedSequences =
                sequences.map(seq => {
                    return degapSeq(seq,founder)
                });
            return degappedSequences.map(seq => {
                let onehot = seq.split('').map(aa => {
                    return oneHotChar(aa)
                    });
                return onehot.flat()
            });
        }

       // Function to compute UMAP
       // async function computeUMAP(featureVectors) {
       //     fixed = new UMAP({
       //       nComponents: 2,
       //       minDist: 0.1,
       //       nNeighbors: 15
       //     }).fit(featureVectors)
       //     return fixed;
       // }
        
        // Function to compute PCA
        async function computePCA(featureVectors) {
            let data = featureVectors;
            const pca = new ML.PCA(data);
            const projectedData = pca.predict(data, { nComponents: 2 }).data;
            const features = pca.predict(allFeatures, { nComponents: 2 }).data;
            projectedFeatures = features; //centerData(features);
            pcMin=projectedFeatures[0][0]
            pcMax=projectedFeatures[0][0]
            for (let i=0; i<projectedFeatures.length; i++) {
                (projectedFeatures[i][0] < pcMin) ? pcMin = projectedFeatures[i][0] : null;
                (projectedFeatures[i][0] > pcMax) ? pcMax = projectedFeatures[i][0] : null;
            }
            pcMin=Math.floor(pcMin);
            pcMax=Math.ceil(pcMax);
            const slider = document.getElementById('rpc-slider');
            slider.value = 0.5;
            handleRpcSliderChange({ target: slider });
            return true; // projectedData;
        }
        
        // Function to compute clusters
        async function computeClusters(projections) {
            let data = projections;
            var dbscan = new DBSCAN();
            // parameters: 5 - neighborhood radius, 2 - number of points in neighborhood to form a cluster
            var cls = dbscan.run(data, r, mp);
            
            // the following commentedcode attempts to implement non-negative matrix factorisation method of clustering
            /*
            console.log(cls.length)
            
            var res = multiRestartMatrixFactorization(data, Math.max(2,cls.length), 0.1, 0.1);
            var Bhat = res[0];
            var What = res[1];
            var sos_loss = res[2];
            var pen_loss = res[3];
            var loss = res[4];
            var Shat = numeric.dot(Bhat, What);
            
            console.log(What);
            // assignpoints(W) = (maximum(W,dims = 1)[:] .> 0.975) .* [i[1] for i in argmax(W, dims = 1)[:]]
            cluster_assignments = assignClusters(What,0.7)
            console.log(cluster_assignments);
            console.log (sos_loss, pen_loss, loss);
            */
            
            clusters = new Array(data.length).fill(0);
            for (let i=0; i<cls.length; i++) {
                for (let j=0; j<cls[i].length; j++) {
                    clusters[cls[i][j]] = i+1;
                }
            }

            // have to do this to ensure noise is not in cluster.
            for (let p=0; p<dbscan.noise.length; p++) {
                clusters[dbscan.noise[p]] = 0;
            };
            
            clusterDict = {}
            for (let i=0; i<clusters.length; i++) {
                clusterDict[alignment[i].name]=clusters[i];
            };
            setTreeAttributes();
            var clsret={'c': cls, 'n':dbscan.noise};
            return clsret;
        }
        
        function setTreeAttributes() {
            for (let i=0; i<clusters.length; i++) {
                tree_attributes[alignment[i].name]=[ clusterDict[alignment[i].name] ];
                // use this for second attribute band  ,1+visitNames.indexOf(alignment[i].name.split("_")[0])];
            }
        }
        
        function distinctColors(count) {
            var colors = [];
            for(hue = 0; hue < 360; hue += 360 / count) {
                colors.push(hsvToRgb(hue, 100, 100));
            }
            return colors;
        }
        
        old_clusterColors = [
            // '#808080', //gray
            '#0000FF', //blue
            '#008000', //green
            '#FFA500', //orange
            '#FF0000', //red
            '#800080', //purple
            '#808000', //olive
            '#00FF00', //lime
            '#800000', //maroon
            '#00FFFF', //aqua
            '#008080', //team
            '#000080', //navy
            '#FF00FF'  //fushua
        ];
        
        clusterColors = [ '#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080', '#ffffff', '#000000']
        
        lineageDict[0]="HR";
        for (let i=1; i<=maxLineages; i++) {
            lineageDict[i]=`MxL${i}`;
        }
        
         
        // Function to plot scatterplot using D3
        function plotScatterplot(pcaResults) {
            
            // Clear previous scatterplot
            d3.select("#scatterplot").html("");

            // Set up dimensions
            const margin = {top: 30, right: 30, bottom: 50, left: 50};
            const width = 600 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            // Create SVG element
            const svg = d3.select("#scatterplot")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Set up scales
            const x = d3.scaleLinear()
                .domain(d3.extent(pcaResults, d => d[0]))
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain(d3.extent(pcaResults, d => d[1]))
                .range([height, 0]);

            // Create dots
            svg.selectAll("circle")
                .data(pcaResults)
                .enter()
                .append("circle")
                .attr("cx", d => x(d[0]))
                .attr("cy", d => y(d[1]))
                .attr("r", d => 3 )
                // ((d == pcaResults[pcaResults.length-1]) ? 10 : 3))
                .style('fill', d => clusterColors[d[2]] )
                .attr('fill-opacity', 0.2)
                // ((d == pcaResults[pcaResults.length-1]) ? clusterColors[0] : clusterColors[d[2]]))
                .attr("class", "dot");
                
            // show where the reference lies
            // svg.selectAll("oval")
            //     .data([pcaResults[0]])
            //     .enter()
            //     .append("circle")
            //     .attr("cx", d => x(d[0]))
            //     .attr("cy", d => y(d[1]))
            //     .attr("r", d => 4 )
            //     .style('fill', d => clusterColors[clusterColors.length-1] )
            //     .attr("class", "dot");

            // Add x-axis
            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x));

            // Add y-axis
            svg.append("g")
                .call(d3.axisLeft(y));

            // Add x-axis label
            svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", height + margin.bottom - 10)
                .text("PC1");

            // Add y-axis label
            svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("x", -height / 2)
                .attr("y", -margin.left + 15)
                .text("PC2");

            // Add title
            svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("x", width / 2)
                .attr("y", -margin.top / 2)
                .text(donorFile);
                
            document.getElementById("scatterplot").style.display = 'block';
        }
                
        // function to display alignment according to clustering
        
        function displayClusters(clusters,noise) {
                clusters.push(noise);
                const canvas = document.getElementById('alignment-canvas');
                canvas.style.display = 'block';
                const ctx = canvas.getContext('2d');
                const pixelSize = 1;
                const clusterSpacerHeight = 5;
                var width=founder.length;
                var noSeqs=0;
                var height=0;
                for (let i=0; i<clusters.length; i++) {
                    height += 2*clusterSpacerHeight;
                    height += clusters[i].length;
                };
                height += 2*clusterSpacerHeight;

                canvas.width = width * pixelSize;
                canvas.height = height * pixelSize;

                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                let currentRow = 0;
                for (let cl=0; cl<clusters.length; cl++) {
                    thisClusColor=((cl+1)%clusters.length)%clusterColors.length
                    // first display a start cluster spacer
                    ctx.fillStyle = clusterColors[thisClusColor];
                    ctx.fillRect(0, currentRow * pixelSize, canvas.width, clusterSpacerHeight * pixelSize);
                    currentRow += clusterSpacerHeight;
                       
                    // now display aa sequence for each sequence in this cluster
                    clusters[cl].forEach((si) => {
                        for (let col = 0; col < alignment[si].sequence.length; col++) {
                            const aa = alignment[si].sequence[col];
                            const caa = founder[col];
                            ctx.fillStyle = alphabetColors[aa] || '#FFFFFF';
                            if (aa==caa){
                                ctx.fillStyle = '#FFFFFF';
                            }
                            ctx.fillRect(col * pixelSize, currentRow * pixelSize, pixelSize, pixelSize);
                            }
                            currentRow++;
                        });
                           
                        // now display an end cluster spacer
                        ctx.fillStyle = clusterColors[thisClusColor];
                        ctx.fillRect(0, currentRow * pixelSize, canvas.width, clusterSpacerHeight * pixelSize);
                        currentRow += clusterSpacerHeight;
                       
                    };
                
                   // display end partition spacer
                   // ctx.fillStyle = '#000000';
                   // ctx.fillRect(0, currentRow * pixelSize, canvas.width, clusterSpacerHeight * pixelSize);
                   // currentRow += clusterSpacerHeight;
                   
        }

        
       // Functions to plot histograms using D3
       function plotHistogram(pcaResults, component) {
           var pcs = [];
        
           for (let i=0; i<pcaResults.length; i++) {
               pcs.push(pcaResults[i][component]);
           }
        
           // Clear previous histogram
           d3.select("#histogram").html("");

           // Set up dimensions
           const margin = {top: 30, right: 30, bottom: 50, left: 50};
           const width = 600 - margin.left - margin.right;
           const height = 400 - margin.top - margin.bottom;

           // Create SVG element
           const svg = d3.select("#histogram")
               .append("svg")
               .attr("width", width + margin.left + margin.right)
               .attr("height", height + margin.top + margin.bottom)
               .append("g")
               .attr("transform", `translate(${margin.left},${margin.top})`);

           // Create histogram bins
           const histogram = d3.histogram()
               .domain(d3.extent(pcs))
               .thresholds(40);

           const bins = histogram(pcs);

           // Set up scales
           const x = d3.scaleLinear()
               .domain([bins[0].x0, bins[bins.length - 1].x1])
               .range([0, width]);

           const y = d3.scaleLinear()
               .domain([0, d3.max(bins, d => d.length)])
               .range([height, 0]);

           // Create bars
           svg.selectAll("rect")
               .data(bins)
               .enter()
               .append("rect")
               .attr("x", d => x(d.x0) + 1)
               .attr("width", d => Math.max(0, x(d.x1) - x(d.x0) - 1))
               .attr("y", d => y(d.length))
               .attr("height", d => height - y(d.length))
               .attr("class", "bar");

           // Add x-axis
           svg.append("g")
               .attr("transform", `translate(0,${height})`)
               .call(d3.axisBottom(x));

           // Add y-axis
           svg.append("g")
               .call(d3.axisLeft(y));

           // Add x-axis label
           svg.append("text")
               .attr("class", "axis-label")
               .attr("text-anchor", "middle")
               .attr("x", width / 2)
               .attr("y", height + margin.bottom - 10)
               .text(`PC${component+1} Values`);

           // Add y-axis label
           svg.append("text")
               .attr("class", "axis-label")
               .attr("text-anchor", "middle")
               .attr("transform", "rotate(-90)")
               .attr("x", -height / 2)
               .attr("y", -margin.left + 15)
               .text("Frequency");

           // Add title
           svg.append("text")
               .attr("class", "axis-label")
               .attr("text-anchor", "middle")
               .attr("x", width / 2)
               .attr("y", -margin.top / 2)
               .text(`Histogram of Component PC${component+1} values`);
       }
       
       function annotateName(name,cl,mcl) {
           var newName=name;
           if (cl==1 && mcl==1) {
              newName+=`_SxL`;
           };
           if (cl>0 && mcl>1) {
              newName+=`_MxL${cl}`;
           }
           if (cl==0) {
              newName+=`_HR`;
           }
           return newName
       }
       
       function annotateAlignment(alignment) {
           // var max_cluster=Math.max( ...clusters );
           let max_cluster = 0;
           for(const [key, value] of Object.entries(clusterDict)) {
             if(value > max_cluster) {
               max_cluster = value;
             }
           }
           let annotated = alignment.map((seq, index) => ({
               name: `${annotateName(seq.name,clusterDict[seq.name],max_cluster)}`,
               sequence: seq.sequence
            }));
           annotated.unshift({name: founderName, sequence: founder});
           annotated.unshift({name: referenceName, sequence: reference});
           return(annotated);
       }

       function createFasta(alignment) {
           return alignment.map(seq => `>${seq.name}\n${seq.sequence}`).join('\n');
       }

       function createDownloadLink(content) {
           const blob = new Blob([content], { type: 'text/plain' });
           const url = URL.createObjectURL(blob);
           const downloadLink = document.getElementById('downloadLink');
           downloadLink.href = url;
           downloadLink.download = `${donorFile}_clustered.fasta`;
           downloadLink.style.display = 'inline';
           downloadLink.textContent = 'Download Annotated FASTA';
       }
       
       colorNodesByName = function (element, data) {
               nodeColorizer (element, data);
               var m = (data.data.name).split ("_");
               if (m.length > 10) {
                   element.style ("stroke", color_scale(_.lowerCase(m[0])));
               }
           };
       
       var test_newick='(((Espresso:2,(Milk Foam:2,Espresso Macchiato:5,((Steamed Milk:2,Cappuccino:2,(Whipped Cream:1,Chocolate Syrup:1,Cafe Mocha:3):5):5,Flat White:2):5):5):1,Coffee arabica:0.1,(Columbian:1.5,((Medium Roast:1,Viennese Roast:3,American Roast:5,Instant Coffee:9):2,Heavy Roast:0.1,French Roast:0.2,European Roast:1):5,Brazilian:0.1):1):1,Americano:10,Water:1);';
       tree = new phylotree.phylotree(test_newick);
       tree_attributes={};
       maximum_node_name_length=0
       
       function setLineageLabels(tree) {
           tips = tree.getTips();
           for (let ii=0; ii<tips.length; ii++) {
               if (clusterDict[tips[ii].data["name"]]>=0) {
                   tips[ii].data["annotation"] = "_" +
                        lineageDict[clusterDict[tips[ii].data["name"]]];
               }
           }
       }
       
       function treePlot() {
           tree = new phylotree.phylotree(treeData);
           
           // d3.select('tree_container')
           //            .attr('fill', 'none');
           treeTitle=treeFile.split(".")[0].split("_")[0];
           for (let v=0; v<visitNames.length; v++)  {
               treeTitle += `_${visitNames[v]}`;
           }
           
           setLineageLabels(tree);
                       
           tree.render({
             container: "#tree_container",
             "title": treeTitle,
             "max-radius": 200,
             "align-tips": true,
             "is-radial": false,
             "draw-size-bubbles": true,
             "bubble-styler":  bubble_sizer, //d => { return parseInt(d.d.name.split("_")[2]) }, //
             "node-styler": node_colorizer,
             "font-size": 12,
             "show-scale": false,
             "edge-styler": edge_colorizer      // "zoom": true,
           })
          
           
           d3.select("tree_container").attr("fill", "none");
           
            
           $('#tree_container').on('reroot', function (e) {
             update_selection_names();

             tree.display.countHandler(count => {
               $("#selected_branch_counter").text(function(d) {
                 return count[current_selection_name];
               });
             });

           });

           // console.log(current_selection_name);
           current_selection_name="selected";
           tree.display.selectionLabel(current_selection_name);

           tree.display.countHandler(count => {
             $("#selected_branch_counter").text(function(d) {
               return count[current_selection_name];
             });
           });

           // Get selection set names from parsed newick
           if (tree.parsed_tags.length) {
             selection_set = tree.parsed_tags;
           }

           // Until a cleaner solution to supporting both Observable and regular HTML
           $(tree.display.container).append(tree.display.show());

          

           update_selection_names();

           $("#save_image").on("click", function(e) {
             var downloadTreeTitle = treeTitle
             if (tree.display.radial()) {
                 downloadTreeTitle = treeTitle + "_radial"
             } else {
                 downloadTreeTitle = treeTitle + "_linear"
             }
             datamonkey_save_image("svg", "#tree_container", downloadTreeTitle);
             // downloadSVG();
           });
           
        }
       
       function downloadSVG() {
           const svgElement = document.querySelector('#tree_container svg');
           const svgData = new XMLSerializer().serializeToString(svgElement);
           const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
           const url = URL.createObjectURL(blob);
           const link = document.createElement('a');
           link.href = url;
           link.download = 'lineage_tree.svg';
           document.body.appendChild(link);
           link.click();
           document.body.removeChild(link);
       }
       
       // Event listener for file input
       document.getElementById('treeFileInput').addEventListener('change', (event) => {
           const file = event.target.files[0];
           treeFile=file['name'];
           const reader = new FileReader();
           reader.onload = function(e) {
               const content = e.target.result;
               treeData = content;
               document.getElementById('treeFileResults').innerHTML = `Loaded newick tree from ${treeFile}`;
           };
           reader.readAsText(file);
       });
 
       // Event listener for file input
       document.getElementById('fileInput').addEventListener('change', (event) => {
           const file = event.target.files[0];
           donorFile=file['name'];
           const reader = new FileReader();
           reader.onload = function(e) {
               const content = e.target.result;
               allSequences = parseFasta(content);
               document.getElementById('fastaResults').innerHTML = `Loaded ${allSequences.length} sequences`;
           };
           reader.readAsText(file);
       });
       
       // Slider event listeners
       
       document.getElementById('s-slider').addEventListener('input', handleSSliderChange);
       document.getElementById('decrease-s').addEventListener('click', () => changeS(-5));
       document.getElementById('increase-s').addEventListener('click', () => changeS(5));

       function handleSSliderChange(event) {
           s = parseInt(event.target.value);
           document.getElementById('s-value').textContent = `${s}`;
       }

       function changeS(delta) {
           const slider = document.getElementById('s-slider');
           const newS = Math.max(1, Math.min(sBound, parseInt(slider.value) + delta));
           slider.value = newS;
           handleSSliderChange({ target: slider });
       }
       
       document.getElementById('rpc-slider').addEventListener('input', handleRpcSliderChange);
       document.getElementById('decrease-r').addEventListener('click', () => changeRpc(-0.1));
       document.getElementById('increase-r').addEventListener('click', () => changeRpc(0.1));

       function handleRpcSliderChange(event) {
           rpc = parseFloat(event.target.value);
           r = Math.round( 10 * ( pcMax - pcMin ) * rpc ) / 10;
           document.getElementById('r-value').textContent =` ${r}`;
       }

       function changeRpc(delta) {
           const slider = document.getElementById('rpc-slider');
           const newRpc = Math.max(0.0, Math.min(rpcBound, parseFloat(slider.value) + delta));
           slider.value = newRpc;
           handleRpcSliderChange({ target: slider });
       }
       
       document.getElementById('mp-slider').addEventListener('input', handleMPSliderChange);
       document.getElementById('decrease-mp').addEventListener('click', () => changeMP(-1));
       document.getElementById('increase-mp').addEventListener('click', () => changeMP(1));

       function handleMPSliderChange(event) {
           mp = parseInt(event.target.value);
           document.getElementById('mp-value').textContent = ` ${mp}`;
       }

       function changeMP(delta) {
           const slider = document.getElementById('mp-slider');
           const newMP = Math.max(1, Math.min(mpBound, parseInt(slider.value) + delta));
           slider.value = newMP;
           handleMPSliderChange({ target: slider });
       }
       
       // Event listener for compute features button
       document.getElementById('computeFeatures').addEventListener('click', () => {
           if (allSequences.length==0) {
               alert('Please upload a FASTA file first');
               return;
           }
           allFeatures = computeOneHot(allSequences);
           document.getElementById('featureResults').innerHTML = `Computed feature vectors for ${allFeatures.length} sequences`;
       });

       
       // Add event listeners for subSample slider
       document.getElementById('s-slider').addEventListener('input', function() {
           document.getElementById('s-value').textContent = this.value;
       });
       
       // Event listener for compute subsample button
       document.getElementById('subSample').addEventListener('click', () => {
           if (allFeatures.length==0) {
               alert('Please upload a FASTA file and compute feature vectors first');
               return;
           }
           ssp = document.getElementById('s-value').textContent;
           subSampledFeatures = subSampleFeatures(allFeatures,ssp);
           document.getElementById('sampleResults').innerHTML = `Sampled ${subSampledFeatures.length} features`;
       });

      
       // Event listener for compute PCA button
       document.getElementById('computePCA').addEventListener('click', async () => {
           if (subSampledFeatures.length == 0) {
               alert('Please compute and subSample feature vectors first');
               return;
           }
           let proceed = confirm(`You are about to compute a PCA on ${subSampledFeatures.length} features, do you want to continue? `);
           if (proceed) {
               const pcaDone = await computePCA(subSampledFeatures);
               augmentedFeatures = [];
               for (let i=0; i<projectedFeatures.length; i++) {
                   let v=[];
                   v.push(projectedFeatures[i][0]);
                   v.push(projectedFeatures[i][1]);
                   v.push(1);
                   augmentedFeatures.push(v);
               }
               plotScatterplot(augmentedFeatures);
               document.getElementById('pcaResults').innerHTML = `PCA computed on sample of size ${subSampledFeatures.length} and projections of all features plotted`;
           } else {
               alert("PCA aborted, please press ok");
           }
       });
       
       // ans = kmeans(data, 2, { initialization: centers });
       
       // Event listener for cluster button
       document.getElementById('cluster').addEventListener('click', async () => {
           if (projectedFeatures.length == 0) {
               alert('Please run PCA first!');
               return;
           }
           let proceed = true;
           // confirm(`You are about to perform clustering on ${projectedFeatures.length} projections, do you want to continue? `);
           if (proceed) {
               const results = await computeClusters(projectedFeatures);
               
               augmentedFeatures = [];
               for (let i=0; i<projectedFeatures.length; i++) {
                   let v=[];
                   v.push(projectedFeatures[i][0]);
                   v.push(projectedFeatures[i][1]);
                   v.push(clusters[i]);
                   augmentedFeatures.push(v);
               }
               plotScatterplot(augmentedFeatures);
               let noiseCount = results['n'].length;
               // let noiseCount = projectedFeatures.length -
               //  results['c'].map( v => v.length ).reduce((a, b) => a + b, 0);
               document.getElementById('clusterResults').innerHTML = `${results['c'].length} clusters, each of lengths ${results['c'].map( v => v.length )}, with ${noiseCount} noise points, computed on ${projectedFeatures.length} projections.`;
               displayClusters(results['c'],results['n']);
               
           } else {
               alert("clustering aborted, please press ok");
           }
       });
       
       document.getElementById('showClustersOnTree').addEventListener('click',
                                                                   async () => {
           treePlot();
           document.getElementById("treeDisplayBlock").style.display = 'block';
        });
       
       document.getElementById('clusterAnnotate').addEventListener('click',
                                                                   async () => {
           const annotatedAlignment = annotateAlignment(alignment);
           const newFastaContent = createFasta(annotatedAlignment);
           createDownloadLink(newFastaContent);
        });
       
      
       
     //  var phylotree_extensions = new Object();

      $("#newick_export_modal").on("show.bs.modal", function(e) {
        $('textarea[id$="nwk_export_spec"]').val(
          tree.getNewick(function(node) {
            var tags = [];
            selection_set.forEach(function(d) {
              if (node[d]) {
                tags.push(d);
              }
            });
            if (tags.length) {
              return "{" + tags.join(",") + "}";
            }
            return "";
          })
        );
      });


      $("#newick_file").on("change", function(e) {
        var files = e.target.files; // FileList object

        if (files.length == 1) {
          var f = files[0];
          var reader = new FileReader();

          reader.onload = function(e) {
            var res = e.target.result;
            var warning_div = d3
              .select("#main_display")
              .insert("div", ":first-child");

            tree = new phylotree.phylotree(res);

            if (!tree["json"]) {
              warning_div
                .attr("class", "alert alert-danger alert-dismissable")
                .html(
                  "<strong>Newick parser error for file " +
                    f.name +
                    ": </strong> In file " +
                    res["error"]
                );
            } else {
              tree.render({
                container: "#tree_container",
                "draw-size-bubbles": false,
                "left-right-spacing": "fixed-step",
                "node-styler": node_colorizer,
                "edge-styler": edge_colorizer
              });

              tree.display.selectionLabel(current_selection_name);

              tree.display.countHandler(count => {
                $("#selected_branch_counter").text(function(d) {
                  return count[current_selection_name];
                });
              });

              // Get selection set names from parsed newick
              if (tree.parsed_tags.length) {
                selection_set = tree.parsed_tags;
              }

              update_selection_names();

              // $("#newick_modal").modal("hide");

              $(tree.display.container).empty();
              $(tree.display.container).html(tree.display.show());
            }
          };

          // $("#newick-dropdown").dropdown("toggle");
          reader.readAsText(f);
        }

      });
 

      function getNewickFromURL(url) {
				d3.text(url).then(res => {

					var warning_div = d3
						.select("#main_display")
						.insert("div", ":first-child");

					tree = new phylotree.phylotree(res);

					if (!tree["json"]) {
						warning_div
							.attr("class", "alert alert-danger alert-dismissable")
							.html(
								"<strong>Newick parser error for file " +
									f.name +
									": </strong> In file " +
									res["error"]
							);
					} else {
						tree.render({
							container: "#tree_container",
							"draw-size-bubbles": false,
							"left-right-spacing": "fixed-step",
							"node-styler": node_colorizer,
							"edge-styler": edge_colorizer
						});

						tree.display.selectionLabel(current_selection_name);

						tree.display.countHandler(count => {
							$("#selected_branch_counter").text(function(d) {
								return count[current_selection_name];
							});
						});

						// Get selection set names from parsed newick
						if (tree.parsed_tags.length) {
							selection_set = tree.parsed_tags;
						}

						update_selection_names();

						$("#newick_modal").modal("hide");

						$(tree.display.container).empty();
						$(tree.display.container).html(tree.display.show());
					}
          });
      }


      $("#newick_url_btn").on("click", function(e) {

        let url = $("#newick_url").val();
        getNewickFromURL(url);
        $("#newick-dropdown").dropdown("toggle");

      });


      $("#newick_url").on("change", function(e) {

        let url = $(e.target).val();
        getNewickFromURL(url);
        $("#newick-dropdown").dropdown("toggle");

      });


      $("#display_tree").on("click", function(e) {
        tree.options({ branches: "straight" }, true);
      });

      $("#mp_label").on("click", function(e) {
        tree.maxParsimony(true, "Foreground");
      });

      $("[data-direction]").on("click", function(e) {
        var which_function =
          $(this).data("direction") == "vertical"
            ? tree.display.spacing_x.bind(tree.display)
            : tree.display.spacing_y.bind(tree.display);
        which_function(which_function() + +$(this).data("amount")).update();
      });

      $(".phylotree-layout-mode").on("click", function(e) {
        if (tree.display.radial() != ($(this).data("mode") == "radial")) {
          $(".phylotree-layout-mode").toggleClass("active");
          tree.display.radial(!tree.display.radial()).update();
        }
      });

      $("#toggle_animation").on("click", function(e) {
        var current_mode = $(this).hasClass("active");
        $(this).toggleClass("active");
        tree.options({ transitions: !current_mode });
      });

      $(".phylotree-align-toggler").on("click", function(e) {
        var button_align = $(this).data("align");
        var tree_align = tree.display.options.alignTips;

        if (tree_align != button_align) {
          tree.display.alignTips(button_align == "right");
          $(".phylotree-align-toggler").toggleClass("active");
          tree.display.update();
        }
      });

      function sort_nodes(asc) {
        tree.resortChildren(function(a, b) {
          return (b.height - a.height || b.value - a.value) * (asc ? 1 : -1);
        });
      }

      $("#sort_original").on("click", function(e) {
        tree.resortChildren(function(a, b) {
          return a["original_child_order"] - b["original_child_order"];
        });
      });
      
      function populateDropdown() {
          var possibles = new Set();
          for ( var k in clusterDict ) {
              possibles.add(clusterDict[k])
          }
          var pa = [...possibles].sort();
          var max_pa = pa[pa.length-1] + 1;
          var items=['abort', 'HR' ]
          for (let i=1; i <= max_pa; i++) {
              items.push(`MxL${i}`);
          }
          const select = document.getElementById('itemList');
          
          // Clear existing options
          select.innerHTML = '';
          
          // Add a default option
          const defaultOption = document.createElement('option');
          defaultOption.text = 'Select an item';
          defaultOption.value = '';
          select.add(defaultOption);
          
          // Add items to the dropdown
          items.forEach(item => {
              const option = document.createElement('option');
              option.text = item;
              option.value = item.toLowerCase();
              select.add(option);
          });
          
      }
      
      // Function to handle selection change
      async function handleSelection() {
          const select = document.getElementById('itemList');
          const result = document.getElementById('result');
          const modal = document.getElementById('dropdownModal');
          
          if (select.value) {
              manualClusterAssignment=select.selectedIndex;
              result.textContent = `You selected: ${select.options[select.selectedIndex].text}`;
              modal.style.display = 'none';
              if ( manualClusterAssignment > 1 ) {
                  toBeReassigned.map(nam => {
                      clusterDict[nam]=manualClusterAssignment-2
                  });
              };
              setTreeAttributes();
              setLineageLabels(tree);
              tree.display.update();
          }
      }

      // Function to show dropdown modal
      async function showDropdownModal() {
          const modal = document.getElementById('dropdownModal');
          modal.style.display = 'block';
          populateDropdown();
      }
      
      document.getElementById('itemList').addEventListener('change', handleSelection);
      
      
      $("#process_selected").on("click", async function(e) {
        toBeReassigned = [];
        tree.display.modifySelection(function(d) {
            if (tree.isLeafNode(d.target)) {
                if (d.selected) {
                    toBeReassigned.push(d.target.data.name);
                }
            };
          return false;
        });
        showDropdownModal();
        
      });
      
      $("#revert_selected").on("click", async function(e) {
        const result = await computeClusters(projectedFeatures);
        setLineageLabels(tree);
        tree.display.update();
      });

      $("#sort_ascending").on("click", function(e) {
        sort_nodes(true);
        tree.display.update();
      });

      $("#sort_descending").on("click", function(e) {
        sort_nodes(false);
        tree.display.update();
      });

      $("#and_label").on("click", function(e) {
        tree.display.internalLabel(function(d) {
          return d.reduce(function(prev, curr) {
            return curr[current_selection_name] && prev;
          }, true);
        }, true);
      });

      $("#or_label").on("click", function(e) {
        tree.display.internalLabel(function(d) {
          return d.reduce(function(prev, curr) {
            return curr[current_selection_name] || prev;
          }, false);
        }, true);
      });

      $("#filter_add").on("click", function(e) {
        tree.display
          .modifySelection(function(d) {
            return d.tag || d[current_selection_name];
          })
          .modifySelection(
            function(d) {
              return false;
            },
            "tag",
            false,
            false
          );
      });

      $("#filter_remove").on("click", function(e) {
        tree.display.modifySelection(function(d) {
          return !d.tag;
        });
      });

      $("#select_all").on("click", function(e) {
        tree.display.modifySelection(function(d) {
          return true;
        });
      });

      $("#select_all_internal").on("click", function(e) {
        tree.display.modifySelection(function(d) {
          return !tree.isLeafNode(d.target);
        });
      });

      $("#select_all_leaves").on("click", function(e) {
        tree.display.modifySelection(function(d) {
          return tree.isLeafNode(d.target);
        });
      });

      $("#select_none").on("click", function(e) {
        tree.display.modifySelection(function(d) {
          return false;
        });
      });

      $("#clear_internal").on("click", function(e) {
        tree.display.modifySelection(function(d) {
          return tree.isLeafNode(d.target)
            ? d.target[current_selection_name]
            : false;
        });
      });

      $("#clear_leaves").on("click", function(e) {
        tree.display.modifySelection(function(d) {
          return !tree.isLeafNode(d.target)
            ? d.target[current_selection_name]
            : false;
        });
      });

      $("#display_dengrogram").on("click", function(e) {
        tree.display.options({ branches: "step" }, true);
      });

      $("#branch_filter").on("input propertychange", function(e) {
        var filter_value = $(this).val();

        var rx = new RegExp(filter_value, "i");

        tree.display.modifySelection(n => {
          if (!n.target.data.name) {
            return false;
          }
          m = n.target.data.name.search(rx);
          return filter_value.length && m != -1;
        }, "tag");
      });

      $("#validate_newick").on("click", function(e) {
        let test_string = $('textarea[id$="nwk_spec"]').val();

        tree = new phylotree.phylotree(test_string);

        if (!tree["json"]) {
          var warning_div = d3
            .select("#newick_body")
            .selectAll("div  .alert-danger")
            .data([res["error"]]);
          warning_div.enter().append("div");
          warning_div
            .html(function(d) {
              return d;
            })
            .attr("class", "alert-danger");
        } else {
          tree.render({
            container: "#tree_container",
            "draw-size-bubbles": false,
            "node-styler": node_colorizer,
            zoom: false,
            "edge-styler": edge_colorizer
          });

          tree.display.selectionLabel(current_selection_name);

          tree.display.countHandler(count => {
            $("#selected_branch_counter").text(function(d) {
              return count[current_selection_name];
            });
          });

          // Get selection set names from parsed newick
          if (tree.parsed_tags.length) {
            selection_set = tree.parsed_tags;
          }

          update_selection_names();

          // $("#newick_modal").modal("hide");
          $(tree.display.container).html(tree.display.show());
        }
      });

      function default_tree_settings() {
        tree = phylotree();
        tree.branchLength(null);
        tree.branchName(null);
        tree.display.radial(false).separation(function(a, b) {
          return 0;
        });
      }

      function attribute_to_color(d) {
          return clusterColors[d]
      }
      
      function bubble_sizer(data) {
        var ret = 1;
        try {
            ret = parseInt(data.data.name.split("_")[3]);
            if (ret > 1) {
                return 3 + Math.sqrt(ret); // Math.log2(8+ret);
            } else {
                return 3;
            }
        } catch (e) {
            console.log(`cought ${e} `)
            return 3;
        }
      }
      
      
      function node_colorizer(element, data) {

        try {
            // attempt to color leaf names

            if (data.data.name in tree_attributes) {   // see if the node has attributes
                var node_label = element.select("text");
                var font_size  = parseFloat (node_label.style ("font-size"));
                var move_past_label = maximum_node_name_length * 0.75 * font_size;
                var x_trans = this.right_most_leaf - data.screen_x;
                var r_trans = this.last_node.radius - data.radius;
                var attr_sep = 1.25
                
                var annotation = element.selectAll ("rect").data (tree_attributes[data.data.name]);
                
                annotation.enter().append ("rect");
                annotation.attr ("width", font_size)
                          .attr ("height", font_size)
                          // .attr ("x", x_place)
                          .attr ("y", -font_size/2).style ("fill", function(d, i) {
                            return attribute_to_color (d);
                           });
                          
                // annotation.enter().append ("text");
                // annotation.attr ("text", "MxL5");
               
                if (this.radial ()) {
                    var shifter =  r_trans;
                    ( (3 * Math.PI / 2) > data.angle) && (data.angle > (Math.PI / 2)) ? shifter=-r_trans : null;
                    annotation.attr ("transform", "rotate (" + data.text_angle + ")")
                              .attr ("x", function (d, i) { return   shifter >= 0 ?
                                  shifter + attr_sep * font_size * (i) + move_past_label + font_size * (attr_sep - 1) :
                                  shifter - attr_sep * font_size * (i+1) - move_past_label;})
                } else {
                    annotation.attr ("transform", null).attr ("x", function (d, i) {
                        return  x_trans + move_past_label + attr_sep * font_size * i;});
                }
                

                    
            }
            
            // end of attempt
            
            
          var count_class = 0;

          selection_set.forEach(function(d, i) {
            if (data[d]) {
              count_class++;
              element.style(
                "fill",
                color_scheme(i),
                i == current_selection_id ? "important" : null
              );
            }
          });

          if (count_class > 1) {
          } else {
            if (count_class == 0) {
              element.style("fill", null);
            }
          }
          
          
        } catch (e) {}
      }

      function edge_colorizer(element, data) {

        try {
            
          var count_class = 0;

          selection_set.forEach(function(d, i) {
            if (data[d]) {
              count_class++;
              element.style(
                "stroke",
                color_scheme(i),
                i == current_selection_id ? "important" : null
              );
            }
          });

          if (count_class > 1) {
            element.classed("branch-multiple", true);
          } else if (count_class == 0) {
            element.style("stroke", null).classed("branch-multiple", false);
          }
        } catch (e) {}
      }

      var valid_id = new RegExp("^[\\w]+$");

      $("#selection_name_box").on("input propertychange", function(e) {
        var name = $(this).val();

        var accept_name =
          selection_set.indexOf(name) < 0 && valid_id.exec(name);

        d3.select("#save_selection_button").classed(
          "disabled",
          accept_name ? null : true
        );
      });

      $("#selection_rename").on("click", function(e) {
        d3.select("#save_selection_button")
          .classed("disabled", true)
          .on("click", function(e) {
            // save selection handler
            var old_selection_name = current_selection_name;
            selection_set[current_selection_id] = current_selection_name = $(
              "#selection_name_box"
            ).val();

            if (old_selection_name != current_selection_name) {
              tree.update_key_name(old_selection_name, current_selection_name);
              update_selection_names(current_selection_id);
            }
            send_click_event_to_menu_objects(
              new CustomEvent(selection_menu_element_action, {
                detail: ["save", this]
              })
            );
          });

        d3.select("#cancel_selection_button")
          .classed("disabled", false)
          .on("click", function(e) {
            // save selection handler
            $("#selection_name_box").val(current_selection_name);
            send_click_event_to_menu_objects(
              new CustomEvent(selection_menu_element_action, {
                detail: ["cancel", this]
              })
            );
          });

        send_click_event_to_menu_objects(
          new CustomEvent(selection_menu_element_action, {
            detail: ["rename", this]
          })
        );
        e.preventDefault();
      });

      $("#selection_delete").on("click", function(e) {
        tree.display.updateKeyName(selection_set[current_selection_id], null);
        selection_set.splice(current_selection_id, 1);

        if (current_selection_id > 0) {
          current_selection_id--;
        }
        current_selection_name = selection_set[current_selection_id];
        update_selection_names(current_selection_id);
        $("#selection_name_box").val(current_selection_name);

        send_click_event_to_menu_objects(
          new CustomEvent(selection_menu_element_action, {
            detail: ["save", this]
          })
        );
        e.preventDefault();
      });

      $("#selection_new").on("click", function(e) {
        d3.select("#save_selection_button")
          .classed("disabled", true)
          .on("click", function(e) {
            // save selection handler
            current_selection_name = $("#selection_name_box").val();
            current_selection_id = selection_set.length;
            selection_set.push(current_selection_name);
            update_selection_names(current_selection_id);
            send_click_event_to_menu_objects(
              new CustomEvent(selection_menu_element_action, {
                detail: ["save", this]
              })
            );
          });

        d3.select("#cancel_selection_button")
          .classed("disabled", false)
          .on("click", function(e) {
            // save selection handler
            $("#selection_name_box").val(current_selection_name);
            send_click_event_to_menu_objects(
              new CustomEvent(selection_menu_element_action, {
                detail: ["cancel", this]
              })
            );
          });

        send_click_event_to_menu_objects(
          new CustomEvent(selection_menu_element_action, {
            detail: ["new", this]
          })
        );
        e.preventDefault();
      });

      function send_click_event_to_menu_objects(e) {
        $(
          "#selection_new, #selection_delete, #selection_rename, #save_selection_name, #selection_name_box, #selection_name_dropdown"
        )
          .get()
          .forEach(function(d) {
            d.dispatchEvent(e);
          });
      }

      function update_selection_names(id, skip_rebuild) {
        skip_rebuild = skip_rebuild || false;
        id = id || 0;

        current_selection_name = selection_set[id];
        current_selection_id = id;

        if (!skip_rebuild) {
          d3.selectAll(".selection_set").remove();

          d3.select("#selection_name_dropdown")
            .selectAll(".selection_set")
            .data(selection_set)
            .enter()
            .append("a")
            .attr("class", "selection_set dropdown-item")
            .attr("href", "#")
            .text(function(d) {
              return d;
            })
            .style("color", function(d, i) {
              return color_scheme(i);
            })
            .on("click", function(d, name) {
              // Pass the index of name
              let i = _.indexOf(selection_set, name);
              update_selection_names(i, true);
            });
        }

        d3.select("#selection_name_box")
          .style("color", color_scheme(id))
          .property("value", current_selection_name);

        // Loop through all selection_sets
        _.each(selection_set, function(id) {
          tree.display.selectionLabel(id);
          tree.display.update();
        });

        //console.log('Setting label within the tree display');
        //console.log(id);
        //console.log(selection_set[id]);
        tree.display.selectionLabel(selection_set[id]);
        tree.display.update();
      }

      var width = 600, //$(container_id).width(),
        height = 600, //$(container_id).height()
        selection_set = ["selected"] // ["Foreground"],
        current_selection_name = $("#selection_name_box").val(),
        current_selection_id = 0,
        max_selections = 10;
      (color_scheme = d3.scaleOrdinal(d3.schemeCategory10)),
        (selection_menu_element_action = "phylotree_menu_element_action");

      var test_string =
        "(((EELA:0.150276,CONGERA:0.213019):0.230956,(EELB:0.263487,CONGERB:0.202633):0.246917):0.094785,((CAVEFISH:0.451027,(GOLDFISH:0.340495,ZEBRAFISH:0.390163):0.220565):0.067778,((((((NSAM:0.008113,NARG:0.014065):0.052991,SPUN:0.061003,(SMIC:0.027806,SDIA:0.015298,SXAN:0.046873):0.046977):0.009822,(NAUR:0.081298,(SSPI:0.023876,STIE:0.013652):0.058179):0.091775):0.073346,(MVIO:0.012271,MBER:0.039798):0.178835):0.147992,((BFNKILLIFISH:0.317455,(ONIL:0.029217,XCAU:0.084388):0.201166):0.055908,THORNYHEAD:0.252481):0.061905):0.157214,LAMPFISH:0.717196,((SCABBARDA:0.189684,SCABBARDB:0.362015):0.282263,((VIPERFISH:0.318217,BLACKDRAGON:0.109912):0.123642,LOOSEJAW:0.397100):0.287152):0.140663):0.206729):0.222485,(COELACANTH:0.558103,((CLAWEDFROG:0.441842,SALAMANDER:0.299607):0.135307,((CHAMELEON:0.771665,((PIGEON:0.150909,CHICKEN:0.172733):0.082163,ZEBRAFINCH:0.099172):0.272338):0.014055,((BOVINE:0.167569,DOLPHIN:0.157450):0.104783,ELEPHANT:0.166557):0.367205):0.050892):0.114731):0.295021)myroot";
      
      // var container_id = "#tree_container";

      //var tree = phylotree.phylotree(test_string);
      //.size([height, width]);

      //window.setInterval (function () {});

      var example_controls = d3.select("#controls_form").append("form");

      //var svg = d3.select(container_id).append("svg")
      //    .attr("width", width)
      //    .attr("height", height);

      function selection_handler_name_box(e) {
        var name_box = d3.select(this);
        switch (e.detail[0]) {
          case "save":
          case "cancel":
            name_box
              .property("disabled", true)
              .style("color", color_scheme(current_selection_id));

            break;
          case "new":
            name_box
              .property("disabled", false)
              .property("value", "new_selection_name")
              .style("color", color_scheme(selection_set.length));
            break;
          case "rename":
            name_box.property("disabled", false);
            break;
        }
      }

      function selection_handler_new(e) {
        var element = d3.select(this);
        $(this).data("tooltip", false);
        switch (e.detail[0]) {
          case "save":
          case "cancel":
            if (selection_set.length == max_selections) {
              element.classed("disabled", true);
              $(this).tooltip({
                title: "Up to " + max_selections + " are allowed",
                placement: "left"
              });
            } else {
              element.classed("disabled", null);
            }
            break;
          default:
            element.classed("disabled", true);
            break;
        }
      }

      function selection_handler_rename(e) {
        var element = d3.select(this);
        element.classed(
          "disabled",
          e.detail[0] == "save" || e.detail[0] == "cancel" ? null : true
        );
      }

      function selection_handler_save_selection_name(e) {
        var element = d3.select(this);
        element.style(
          "display",
          e.detail[0] == "save" || e.detail[0] == "cancel" ? "none" : null
        );
      }

      function selection_handler_name_dropdown(e) {
        var element = d3.select(this).selectAll(".selection_set");
        element.classed(
          "disabled",
          e.detail[0] == "save" || e.detail[0] == "cancel" ? null : true
        );
      }

      function selection_handler_delete(e) {
        var element = d3.select(this);
        // $(this).tooltip("dispose");
        switch (e.detail[0]) {
          case "save":
          case "cancel":
            if (selection_set.length == 1) {
              element.classed("disabled", true);
              // $(this).tooltip({
              //   title:
              //     "At least one named selection set <br> is required;<br>it can be empty, however",
              //   placement: "bottom",
              //   html: true
              // });
            } else {
              element.classed("disabled", null);
            }
            break;
          default:
            element.classed("disabled", true);
            break;
        }
      }

      var datamonkey_save_image = function(type, container, treeTitle) {
        var prefix = {
          xmlns: "http://www.w3.org/2000/xmlns/",
          xlink: "http://www.w3.org/1999/xlink",
          svg: "http://www.w3.org/2000/svg"
        };

        function get_styles(doc) {
          function process_stylesheet(ss) {
            try {
              if (ss.cssRules) {
                for (var i = 0; i < ss.cssRules.length; i++) {
                  var rule = ss.cssRules[i];
                  if (rule.type === 3) {
                    // Import Rule
                    process_stylesheet(rule.styleSheet);
                  } else {
                    // hack for illustrator crashing on descendent selectors
                    if (rule.selectorText) {
                      if (rule.selectorText.indexOf(">") === -1) {
                        styles += "\n" + rule.cssText;
                      }
                    }
                  }
                }
              }
            } catch (e) {
              //console.log("Could not process stylesheet : " + ss); // eslint-disable-line
            }
          }

          var styles = "",
            styleSheets = doc.styleSheets;

          if (styleSheets) {
            for (var i = 0; i < styleSheets.length; i++) {
              process_stylesheet(styleSheets[i]);
            }
          }

          return styles;
        }

        var svg = $(container).find("svg")[0];
        if (!svg) {
          svg = $(container)[0];
        }

        var styles = get_styles(window.document);

        svg.setAttribute("version", "1.1");

        var defsEl = document.createElement("defs");
        svg.insertBefore(defsEl, svg.firstChild);

        var styleEl = document.createElement("style");
        defsEl.appendChild(styleEl);
        styleEl.setAttribute("type", "text/css");

        // removing attributes so they aren't doubled up
        svg.removeAttribute("xmlns");
        svg.removeAttribute("xlink");

        // These are needed for the svg
        if (!svg.hasAttributeNS(prefix.xmlns, "xmlns")) {
          svg.setAttributeNS(prefix.xmlns, "xmlns", prefix.svg);
        }

        if (!svg.hasAttributeNS(prefix.xmlns, "xmlns:xlink")) {
          svg.setAttributeNS(prefix.xmlns, "xmlns:xlink", prefix.xlink);
        }

        var source = new XMLSerializer()
          .serializeToString(svg)
          .replace("</style>", "<![CDATA[" + styles + "]]></style>");
        var doctype =
          '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">';
        var to_download = [doctype + source];
        var image_string =
          "data:image/svg+xml;base66," + encodeURIComponent(to_download);

        if (navigator.msSaveBlob) {
          // IE10
          download(image_string, `${treeTitle}.svg`, "image/svg+xml");
        } else if (type == "png") {
          b64toBlob(
            image_string,
            function(blob) {
              var url = window.URL.createObjectURL(blob);
              var pom = document.createElement("a");
              pom.setAttribute("download", `${treeTitle}.png`);
              pom.setAttribute("href", url);
              $("body").append(pom);
              pom.click();
              pom.remove();
            },
            function(error) {
              console.log(error); // eslint-disable-line
            }
          );
        } else {
          var pom = document.createElement("a");
          pom.setAttribute("download", `${treeTitle}.svg`);
          pom.setAttribute("href", image_string);
          $("body").append(pom);
          pom.click();
          pom.remove();
        }
      };

      /*
      $(document).ready(function() {
        tree = new phylotree.phylotree(test_string);

        tree.render({
          container: "#tree_container",
          "draw-size-bubbles": false,
          "bubble-styler": d => { return 5 },
          "node-styler": node_colorizer,
          "font-size": 12,
          zoom: false,
          "edge-styler": edge_colorizer
        });

        $('#tree_container').on('reroot', function (e) {  
          update_selection_names();

          tree.display.countHandler(count => {
            $("#selected_branch_counter").text(function(d) {
              return count[current_selection_name];
            });
          });

        });

        tree.display.selectionLabel(current_selection_name);

        tree.display.countHandler(count => {
          $("#selected_branch_counter").text(function(d) {
            return count[current_selection_name];
          });
        });

        // Get selection set names from parsed newick
        if (tree.parsed_tags.length) {
          selection_set = tree.parsed_tags;
        }

        // Until a cleaner solution to supporting both Observable and regular HTML
        $(tree.display.container).append(tree.display.show());

       

        update_selection_names();

        $("#save_image").on("click", function(e) {
          datamonkey_save_image("svg", "#tree_container");
        });
      });
      */
    });
        
        function centerData(data) {
            const [nr, nc] = [data.length, data[0].length];
            var ret = []
            var cD = new Array(nc).fill(0);
            for (let i=0; i<nr; i++) {
                for (let j=0; j<nc; j++) {
                    cD[j] += data[i][j]
                }
            }
            for (let i=0; i<nr; i++) {
                var nR = new Array(nc).fill(0);
                for (let j=0; j<nc; j++) {
                    nR[j] = data[i][j] - cD[j]/nr;
                }
                ret.push(nR);
            }
            return ret
        }
        
        // the following code is for NNMF algorithm, requires numerics package
        /*
        
        function softThreshold(x, λ) {
          return Math.sign(x) * Math.max(Math.abs(x) - λ, 0);
        }
        
        function normaliseArrayColumns(A,ε) {
            const [nr, nc] = [A.length, A[0].length];
            var colSums = new Array(nc).fill(0);
            for (let i=0; i<nr; i++) {
                for (let j=0; j<nc; j++) {
                    colSums[j] += (A[i][j] + ε);
                }
            }
            for (let i=0; i<nr; i++) {
                for (let j=0; j<nc; j++) {
                    A[i][j] /= colSums[j];
                }
            }
            return A
        }
        
        function sumArrayAbs(A) {
            const [nr, nc] = [A.length, A[0].length];
            var aSum = 0;
            for (let i=0; i<nr; i++) {
                for (let j=0; j<nc; j++) {
                    aSum += Math.abs(A[i][j]);
                }
            }
            return aSum
        }
        
        // returns a gaussian random function with the given mean and stdev.
        function gaussian(mean, stdev) {
          var y2;
          var use_last = false;
          return function() {
            var y1;
            if (use_last) {
              y1 = y2;
              use_last = false;
            } else {
              var x1, x2, w;
              do {
                x1 = 2.0 * Math.random() - 1.0;
                x2 = 2.0 * Math.random() - 1.0;
                w = x1 * x1 + x2 * x2;
              } while (w >= 1.0);
              w = Math.sqrt((-2.0 * Math.log(w)) / w);
              y1 = x1 * w;
              y2 = x2 * w;
              use_last = true;
            }

            var retval = mean + stdev * y1;
            if (retval > 0)
              return retval;
            return -retval;
          }
        }

        // make a standard gaussian variable.
        var standard = gaussian(0, 1);

        // make a bunch of standard variates
        // for (i = 0; i < 1000; i++) {
        //   console.log( standard() )
        // }
        
        function assignClusters(W,thresh) {
            const [nr, nc] = [W.length, W[0].length];
            var assignment = new Array(nc).fill(0);
            for (let j=0; j<nc; j++) {
                max_val=0;
                for (let i=0; i<nr; i++) {
                    if ( W[i][j] > max_val && W[i][j] > thresh ) {
                        max_val = W[i][j]
                        assignment[j] = i + 1
                    }
                }
            }
            return assignment
        }
        
       
        
        function matrixFactorization(S, K, λ_B, λ_W, { maxIter = 1000, tol = 1e-6 } = {}) {
          const [m, n] = [S[0].length, S.length];
          const ε = 1e-10; // Small constant to avoid division by zero

          // Initialize B and W
          let B = Array.from({ length: m }, () => Array.from({ length: K }, () => standard() ));
          let W = Array.from({ length: K }, () => Array.from({ length: n }, () => Math.abs( standard() ) ) );
          // let W = Array.from({ length: K }, () => Math.abs(Math.random() * 2 - 1));
          // W = W.map(w => w / (W.reduce((sum, v) => sum + v + ε, 0) / K)); // Normalize columns to sum to 1
          W = normaliseArrayColumns(W,ε)
          let prevError = Infinity;

          for (let iter = 0; iter < maxIter; iter++) {
            // Update B using a more stable method
            B = numeric.add( numeric.dot(numeric.transpose(S), numeric.transpose(W)), numeric.mul(λ_B,B) );
            B = numeric.div(B, numeric.add( numeric.add( numeric.dot(W, numeric.transpose(W)) , (λ_B) ) , ε) );
            // Update W using proximal gradient descent
            const α = 1 / (numeric.norm2(B) ** 2 + 1); // Step size
            const G = numeric.dot(numeric.transpose(B), numeric.sub( numeric.dot(B, W), numeric.transpose(S)));
            var W_new = numeric.sub(W, numeric.mul(α,G));
            // let W_new = W.map((w, i) => w - α * G[i]);

            // Apply soft thresholding (L1 proximal operator)
            W_new = W_new.map(w => w.map( x => softThreshold(x, α * λ_W)));
            

            // Project W onto the constraint set
            // W_new = W_new.map(w => Math.max(0, w)); // Ensure non-negativity
            W_new = W_new.map(w => w.map( x => Math.abs(x)));
            // const wSum = W_new.reduce((sum, v) => sum + v + ε, 0);
            // W_new = W_new.map(w => w / wSum); // Normalize columns to sum to 1
            W_new = normaliseArrayColumns(W_new,ε)

            // Check for convergence norm(S - B * W_new)
            var error = numeric.sub(numeric.transpose(S), numeric.dot(B, W_new));
            error = numeric.norm2(error)
            var sA = sumArrayAbs(W_new);
            error = error ** 2 + λ_B * ( numeric.norm2(B) ** 2 ) + λ_W * sA; // W_new.reduce((sum, v) => sum + Math.abs(v), 0);
            if (Math.abs(error - prevError) / (prevError + ε) < tol) {
              return [B, W_new, error, λ_B * numeric.norm2(B) ** 2 + λ_W * sumArrayAbs(W_new), error];
            }

            W = W_new;
            prevError = error;
          }

          return [B, W, numeric.norm2(numeric.sub(numeric.transpose(S), numeric.dot(B, W))) ** 2, λ_B * numeric.norm2(B) ** 2 + λ_W * sumArrayAbs(W_new), prevError];
        }
        
        function multiRestartMatrixFactorization(S, K, λ_B, λ_W, { maxIter = 1000, tol = 1e-6 } = {}) {
          let loss = Infinity;
          let res = [];

          for (let i = 0; i < 100; i++) {
            const newRes = matrixFactorization(S, K, λ_B, λ_W, { maxIter, tol });
            if (newRes[4] < loss) {
              res = newRes;
              loss = newRes[4];
              console.log(loss);
            }
          }
          console.log(res);
          return res;
        }
        */
        
    </script>

    <script>
      var _warn = console.warn;

      console.warn = function() {
        if (arguments[0].includes("Phylotree User Warning")) {
          var warning_div = d3
            .select("#main_display")
            .insert("div", ":first-child");
          warning_div
            .attr("class", "alert alert-danger alert-dismissable")
            .html(arguments[0]);
        }
        return _warn.apply(console, arguments);
      };
        
     </script>
  </body>
</html>
