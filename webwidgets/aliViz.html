<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>aliViz: View, Cluster, and Visualize Alignments in the browser</title>
    <!-- Included the NW Alignment Library -->
    <script src="https://hughmurrell.github.io/webwidgets/js/nw.js"></script>
    <!-- Included the Phylogenetic Tools Library -->
    <script src="https://hughmurrell.github.io/webwidgets/js/phylotools.js"></script>
    <!-- Included UMAP for dimensionality reduction -->
    <script src="https://hughmurrell.github.io/webwidgets/js/umap-js.min.js"></script>
    <!-- Included the Frame Cleaning Library -->
    <!-- <script src="https://murrellgroup.github.io/WebWidgets/frameclean.js"></script> -->
    <!-- Included Aioli for bioWASM -->
    <script src="https://biowasm.com/cdn/v3/aioli.js"></script>
     <!-- Included html2pdf.js for PDF export (includes jsPDF and svg2pdf internally) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <!-- 3Dmol.js for PDB 3D structure viewing (epitope coloring without molstar.lib) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/3Dmol/2.0.1/3Dmol-min.js"></script>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --panel-bg: #ffffff;
            --border-color: #d1d5db;
            --primary: #2563eb;
            --header-height: 90px;
            --ruler-height: 60px; 
            --names-width: 200px;
            --tree-width: 0px; 
        }

        * { box-sizing: border-box; }

        body, html {
            margin: 0; padding: 0;
            height: 100%; width: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            overflow: hidden;
            user-select: none;
            overscroll-behavior-x: none;
        }

        #app {
            display: flex; flex-direction: column;
            height: 100vh; width: 100vw;
        }

        #controls {
            height: var(--header-height);
            flex: 0 0 auto;
            min-width: 0; /* allow flex item to shrink so inner can overflow */
            max-width: 100%;
            background: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            z-index: 20;
            overflow: hidden; /* clip to bounds; scrolling happens in scroll wrapper */
        }
        #controls-scroll {
            width: 100%;
            height: 100%;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-x;
        }
        #controls-inner {
            display: inline-flex; align-items: center;
            padding: 0 20px; gap: 15px;
            min-height: var(--header-height);
            box-sizing: border-box;
        }

        .control-group { display: flex; flex-direction: column; gap: 4px; }
        label { font-size: 11px; font-weight: 700; text-transform: uppercase; color: #6b7280; }
        button, select, input[type="file"] {
            padding: 6px 10px; border: 1px solid #d1d5db; border-radius: 4px;
            background: white; font-size: 13px; cursor: pointer;
            white-space: nowrap;
        }
        button:hover { background-color: #f3f4f6; }
        button.active { background-color: var(--primary); color: white; border-color: var(--primary); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-icon { padding: 6px 8px; font-weight: bold; }

        #viewer-grid {
            flex: 1; display: grid;
            grid-template-columns: var(--tree-width) 5px var(--names-width) 5px minmax(0, 1fr);
            grid-template-rows: var(--ruler-height) minmax(0, 1fr);
            grid-template-areas: 
                "corner-tree resizer-tree corner-names resizer-names ruler" 
                "tree        resizer-tree names        resizer-names seq";
            overflow: hidden; position: relative;
            background: #fff;
        }

        #area-corner-tree { grid-area: corner-tree; background: #f3f4f6; border-bottom: 1px solid var(--border-color); }
        #area-corner-names { grid-area: corner-names; background: #f3f4f6; border-right: 1px solid var(--border-color); border-bottom: 1px solid var(--border-color); }

        #area-ruler {
            grid-area: ruler; background: #f3f4f6;
            border-bottom: 1px solid var(--border-color);
            position: relative; overflow: hidden; cursor: s-resize;
        }

        #area-tree {
            grid-area: tree; background: #fff;
            position: relative; overflow: hidden;
            border-right: 1px solid #e5e7eb;
        }

        #resizer-tree {
            grid-area: resizer-tree; background: #f3f4f6;
            border-right: 1px solid var(--border-color);
            cursor: col-resize; z-index: 15;
            display: flex; align-items: center; justify-content: center;
        }
        #resizer-tree:hover { background: #d1d5db; }
        #resizer-tree::after { content: ''; width: 1px; height: 20px; background: #9ca3af; }

        #resizer-names {
            grid-area: resizer-names; background: #f3f4f6;
            border-right: 1px solid var(--border-color);
            cursor: col-resize; z-index: 15;
            display: flex; align-items: center; justify-content: center;
        }
        #resizer-names:hover { background: #d1d5db; }
        #resizer-names::after { content: ''; width: 1px; height: 20px; background: #9ca3af; }

        #area-names {
            grid-area: names; background: #fff;
            border-right: 1px solid var(--border-color);
            position: relative; overflow: hidden; z-index: 5;
            box-shadow: 2px 0 5px rgba(0,0,0,0.05);
        }

        #area-seq {
            grid-area: seq; overflow: auto; position: relative;
            background: #fff; outline: none; cursor: text;
        }
        #area-seq.grabbing { cursor: grabbing; }

        canvas { display: block; }
        #cvs-seq { position: sticky; top: 0; left: 0; }
        #scroll-sizer { position: absolute; top: 0; left: 0; width: 1px; height: 1px; z-index: -1; }

        #overlay, #help-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.75);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 9999; opacity: 0; pointer-events: none; transition: opacity 0.2s;
        }
        #overlay.active, #help-overlay.active { opacity: 1; pointer-events: all; }
        
        #help-overlay { background: rgba(0,0,0,0.5); }
        .help-box {
            background: white; width: 600px; max-width: 90%; 
            padding: 20px; border-radius: 8px; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            display: flex; flex-direction: column; gap: 5px;
        }
        .help-box h2 { margin: 0 0 5px 0; font-size: 18px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .help-row { display: flex; justify-content: space-between; font-size: 13px; color: #374151; padding: 2px 0; border-bottom: 1px solid #f3f4f6; }
        .help-key { font-weight: bold; color: #111; }
        .close-help { align-self: flex-end; margin-top: 10px; }

        .spinner {
            width: 30px; height: 30px;
            border: 3px solid #e5e7eb; border-top: 3px solid var(--primary);
            border-radius: 50%; animation: spin 0.8s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        .hint-text {
            font-size: 11px; color: #4b5563; margin-left: auto; text-align: right;
            line-height: 1.3; background: #f3f4f6; padding: 5px 10px; border-radius: 4px; border: 1px solid #e5e7eb;
        }
        .tag { display: inline-block; padding: 1px 4px; background: #e5e7eb; border-radius: 3px; font-weight: 600; font-size: 10px; }

        #ctx-menu {
            position: fixed; 
            background: white; 
            border: 1px solid #d1d5db; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.1); 
            border-radius: 4px; 
            padding: 4px 0;
            z-index: 10000;
            display: none;
            min-width: 150px;
        }
        #ctx-menu .item {
            padding: 8px 12px;
            font-size: 13px;
            cursor: default;
            color: #374151;
            white-space: nowrap;
        }
        #ctx-menu .item:hover { background-color: transparent; }
        #ctx-menu .item:first-child {
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 4px;
            padding-bottom: 8px;
        }
    </style>
</head>
<body>

<div id="app">
    <div id="controls">
        <div id="controls-scroll">
        <div id="controls-inner">
        <div class="control-group">
            <label>Info</label>
            <button id="btn-help" class="btn-icon">?</button>
        </div>
        <div class="control-group">
            <label>Sequences</label>
            <div style="display:flex; gap:5px; align-items:center;">
                <input type="file" id="inp-file" accept=".fasta,.fa,.fastq,.fq,.txt">
                <button id="btn-group-sequences" title="Group sequences by name field">Group</button>
                <button id="btn-subtype" title="Add founder sequence from selected group">Add Founder</button>
                <button id="btn-sort-sequences" title="Sort sequences by name (REF and SUBTYPE remain first)">Sort</button>
            </div>
        </div>
        <div class="control-group">
            <label>Phylogeny</label>
            <div style="display:flex; gap:5px; align-items:center;">
                <button id="btn-infer-tree" title="Infer NJ tree from sequences">Infer</button>
                <!-- Choose file button commented out -->
                <!-- <input type="file" id="inp-tree"> -->
                <button id="btn-reroot-tree" title="Reroot tree on subtype sequence">Reroot</button>
                <button id="btn-ladderize-tree" title="Ladderize tree and reorder sequences">Ladderize</button>
                <button id="btn-histogram" title="Show histogram of root-to-leaf distances" disabled>Histogram</button>
                <button id="btn-mds" title="Show 2D projection and clustering of pairwise leaf distances" disabled>Cluster</button>
            </div>
        </div>
        
        <!-- Export Controls -->
        <div style="width:1px; height:30px; background:#e5e7eb; margin:0 10px;"></div>
        <div class="control-group">
            <label>Export</label>
            <div style="display:flex; gap:5px;">
                <button id="btn-download" title="Download Current View">fasta</button>
                <!-- Copy button commented out but code preserved -->
                <!-- <button id="btn-copy" title="Copy to Clipboard">Copy</button> -->
                <button id="btn-export-tree" title="Export current tree as Newick">tree</button>
            </div>
        </div>
        
        <div class="control-group">
            <label>Reset</label>
            <div style="display:flex; gap:5px;">
                <button id="btn-clear-aln" title="Remove all sequences">Clear Alignment</button>
                <button id="btn-clear-tree" title="Remove current tree">Clear Tree</button>
            </div>
        </div>
        
        <!-- History section commented out but code preserved -->
        <!--
        <div style="width:1px; height:30px; background:#e5e7eb; margin:0 10px;"></div>
        <div class="control-group">
            <label>History</label>
            <button id="btn-undo" title="Ctrl+Z">⟲ Undo</button>
        </div>
        -->

        <div style="width:1px; height:30px; background:#e5e7eb; margin:0 10px;"></div>
        <div class="control-group">
            <label>View Mode</label>
            <div style="display:flex;">
                <button id="btn-nt" class="active" style="border-top-right-radius:0; border-bottom-right-radius:0;">NT</button>
                <button id="btn-aa" style="border-top-left-radius:0; border-bottom-left-radius:0; border-left:none;">AA</button>
            </div>
        </div>

        <!-- Frame selector commented out but code preserved for potential reinstatement -->
        <!--
        <div class="control-group" id="grp-frame" style="opacity:0.4; pointer-events:none;">
            <label>Frame</label>
            <select id="sel-frame">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
            </select>
        </div>
        -->

        <div class="control-group">
            <label>Highlighter</label>
            <select id="sel-highlight" style="min-width: 120px;">
                <option value="" selected>Off</option>
                <option value="founder">Founder</option>
                <option value="subtype">SubType</option>
                <option value="reference">Reference</option>
            </select>
        </div>
        <div class="control-group">
            <label>Epitopes</label>
            <div style="display:flex; gap:5px; align-items:center;">
                <input type="file" id="inp-epitopes" accept=".csv" style="display: none;">
                <button id="btn-load-epitopes" title="Load epitope descriptions from CSV file">Load Epitopes</button>
                <button id="btn-select-epitope" title="Select an epitope to restrict display">Select Epitope</button>
                <button id="btn-show-logo" title="Show sequence logo for selected epitope">Show Logo</button>
            </div>
        </div>
        <div class="control-group">
            <label>3D Structure</label>
            <div style="display:flex; gap:5px; align-items:center;">
                <input type="file" id="inp-pdb" accept=".pdb,.ent,.cif" style="display: none;">
                <button id="btn-load-pdb" title="Load PDB/CIF file or fetch by PDB ID">Load file</button>
                <button id="btn-view-3d" title="Display loaded structure in 3D">View 3D</button>
            </div>
        </div>

        </div>
        </div>
    </div>

    <div id="viewer-grid">
        <div id="area-corner-tree"></div>
        <div id="resizer-tree"></div>
        <div id="area-corner-names"></div>
        <div id="resizer-names"></div>
        
        <div id="area-tree"><canvas id="cvs-tree"></canvas></div>
        <div id="area-ruler"><canvas id="cvs-ruler"></canvas></div>
        <div id="area-names"><canvas id="cvs-names"></canvas></div>
        <div id="area-seq" tabindex="0"><div id="scroll-sizer"></div><canvas id="cvs-seq"></canvas></div>
    </div>
</div>

<div id="overlay">
    <div class="spinner"></div>
    <div id="overlay-msg" style="margin-top:10px; font-weight:500;">Processing...</div>
    <div id="overlay-sub" style="margin-top:5px; font-size:12px; color:#666;"></div>
</div>


<div id="ladderize-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 10000;">
    <div class="help-box" style="width: 450px;">
        <h2>Ladderize Tree</h2>
        <div class="help-row" style="flex-direction: column; align-items: flex-start; gap: 5px;">
            <label style="text-transform: none; font-size: 13px; color: #374151;">Sorting Method</label>
            <select id="sel-ladderize-mode" style="width: 100%;">
                <option value="weight">By Weight (number of leaves)</option>
                <option value="depth" selected>By Depth (branch lengths)</option>
            </select>
        </div>

        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
            <button onclick="document.getElementById('ladderize-overlay').style.display='none'">Cancel</button>
            <button id="btn-run-ladderize" class="active">Ladderize</button>
        </div>
    </div>
</div>

<div id="reroot-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 10000;">
    <div class="help-box" style="width: 450px;">
        <h2>Reroot Tree</h2>
        <div class="help-row" style="flex-direction: column; align-items: flex-start; gap: 5px;">
            <label style="text-transform: none; font-size: 13px; color: #374151;">Root On</label>
            <select id="sel-reroot-target" style="width: 100%;">
                <option value="subtype">[SUBTYPE]</option>
                <option value="founder">[Founder]</option>
            </select>
        </div>

        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
            <button onclick="document.getElementById('reroot-overlay').style.display='none'">Cancel</button>
            <button id="btn-run-reroot" class="active">Reroot</button>
        </div>
    </div>
</div>

<div id="infer-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 10000;">
    <div class="help-box" style="width: 450px;">
        <h2>Infer Phylogeny</h2>
        <div class="help-row" style="flex-direction: column; align-items: flex-start; gap: 5px;">
            <label style="text-transform: none; font-size: 13px; color: #374151;">Method</label>
            <select id="sel-infer-method" style="width: 100%;">
                <option value="nj">Neighbor-Joining (Internal)</option>
                <option value="fasttree" selected>FastTree (bioWASM)</option>
            </select>
        </div>
        
        <div id="fasttree-options" style="display: none; flex-direction: column; gap: 10px; margin-top: 10px; border-top: 1px solid #eee; padding-top: 10px;">
            <div class="help-row">
                <span style="font-size: 13px; color: #374151;">Model (NT):</span>
                <select id="sel-ft-nt-model">
                    <option value="-gtr">-gtr (GTR+CAT)</option>
                    <option value="">Default (Jukes-Cantor)</option>
                </select>
            </div>
            <div class="help-row">
                <span style="font-size: 13px; color: #374151;">Model (AA):</span>
                <select id="sel-ft-aa-model">
                    <option value="-lg">-lg (Le-Gascuel)</option>
                    <option value="-wag">-wag (Whelan-And-Goldman)</option>
                    <option value="">Default (JTT)</option>
                </select>
            </div>
            <div class="help-row">
                <span style="font-size: 13px; color: #374151;">Speed:</span>
                <select id="sel-ft-speed">
                    <option value="">Default</option>
                    <option value="-fastest">-fastest</option>
                </select>
            </div>
        </div>

        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
            <button onclick="document.getElementById('infer-overlay').style.display='none'">Cancel</button>
            <button id="btn-run-infer" class="active">Run Inference</button>
        </div>
    </div>
</div>

<div id="histogram-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 10000;">
    <div class="help-box" style="width: 600px; max-width: 90vw;">
        <h2>Root-to-Leaf Distance Histogram</h2>
        <div style="margin: 20px 0;">
            <canvas id="histogram-canvas" width="560" height="400" style="width: 100%; max-width: 560px; height: auto; border: 1px solid #e5e7eb; background: white;"></canvas>
        </div>
        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
            <button onclick="document.getElementById('histogram-overlay').style.display='none'">Close</button>
        </div>
    </div>
</div>

<div id="method-select-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 10000; pointer-events: none;">
    <div class="help-box" style="width: 450px; pointer-events: auto;">
        <h2>Select Projection Method</h2>
        <div class="help-row" style="flex-direction: column; align-items: flex-start; gap: 5px;">
            <label style="text-transform: none; font-size: 13px; color: #374151;">Choose dimensionality reduction method:</label>
            <select id="sel-projection-method" style="width: 100%;">
                <option value="mds">MDS (Classical Multidimensional Scaling)</option>
                <option value="umap">UMAP (Uniform Manifold Approximation and Projection)</option>
                <option value="hierarchical">Hierarchical (Tree-based Clustering)</option>
            </select>
        </div>
        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
            <button onclick="document.getElementById('method-select-overlay').style.display='none'">Cancel</button>
            <button id="btn-confirm-method" class="active">Continue</button>
        </div>
    </div>
</div>

<div id="hierarchical-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 10000; pointer-events: none;">
    <div class="help-box" style="width: 500px; pointer-events: auto;">
        <h2>Hierarchical Clustering</h2>
        <div style="margin: 20px 0; display: flex; flex-direction: column; gap: 20px;">
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-size: 12px; color: #374151; min-width: 120px;">Level 1 Depth:</label>
                    <input type="range" id="hier-slider-1" min="0" max="1" step="0.01" value="0" style="flex: 1;">
                    <span id="hier-value-1" style="font-size: 11px; color: #374151; min-width: 60px; text-align: right;">0.00</span>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-size: 12px; color: #374151; min-width: 120px;">Level 2 Depth:</label>
                    <input type="range" id="hier-slider-2" min="0" max="1" step="0.01" value="0" style="flex: 1;">
                    <span id="hier-value-2" style="font-size: 11px; color: #374151; min-width: 60px; text-align: right;">0.00</span>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-size: 12px; color: #374151; min-width: 120px;">Level 3 Depth:</label>
                    <input type="range" id="hier-slider-3" min="0" max="1" step="0.01" value="0" style="flex: 1;">
                    <span id="hier-value-3" style="font-size: 11px; color: #374151; min-width: 60px; text-align: right;">0.00</span>
                </div>
            </div>
        </div>
        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
            <button id="btn-hier-cancel">Cancel</button>
            <button id="btn-hier-accept" class="active">Accept</button>
        </div>
    </div>
</div>

<div id="mds-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 10000; pointer-events: none;">
    <div class="help-box" style="width: 700px; max-width: 90vw; pointer-events: auto;">
        <h2>2D Projection of Pairwise Leaf Distances</h2>
        <div style="margin: 20px 0; display: flex; flex-direction: column; gap: 15px;">
            <div style="display: flex; flex-direction: column; gap: 5px;">
                <label style="font-size: 12px; color: #374151;">DBSCAN Parameters:</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-size: 11px; color: #6b7280; min-width: 80px;">Radius (eps):</label>
                    <input type="range" id="mds-eps-slider" min="0.01" max="1" step="0.01" value="0.1" style="flex: 1;">
                    <span id="mds-eps-value" style="font-size: 11px; color: #374151; min-width: 50px; text-align: right;">0.1</span>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-size: 11px; color: #6b7280; min-width: 80px;">Min Neighbors:</label>
                    <input type="range" id="mds-minpts-slider" min="0" max="5" step="1" value="2" style="flex: 1;">
                    <span id="mds-minpts-value" style="font-size: 11px; color: #374151; min-width: 50px; text-align: right;">2</span>
                </div>
            </div>
            <div id="umap-params-container" style="display: none; flex-direction: column; gap: 5px;">
                <label style="font-size: 12px; color: #374151;">UMAP Parameters:</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-size: 11px; color: #6b7280; min-width: 80px;">nNeighbors:</label>
                    <input type="range" id="umap-nneighbors-slider" min="0" max="5" step="1" value="2" style="flex: 1;">
                    <span id="umap-nneighbors-value" style="font-size: 11px; color: #374151; min-width: 50px; text-align: right;">2</span>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-size: 11px; color: #6b7280; min-width: 80px;">Spread:</label>
                    <input type="range" id="umap-spread-slider" min="0.1" max="3.0" step="0.1" value="1.0" style="flex: 1;">
                    <span id="umap-spread-value" style="font-size: 11px; color: #374151; min-width: 50px; text-align: right;">1.0</span>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-size: 11px; color: #6b7280; min-width: 80px;">Min Distance:</label>
                    <input type="range" id="umap-mindist-slider" min="0.0" max="1.0" step="0.01" value="0.1" style="flex: 1;">
                    <span id="umap-mindist-value" style="font-size: 11px; color: #374151; min-width: 50px; text-align: right;">0.1</span>
                </div>
            </div>
            <canvas id="mds-canvas" width="660" height="500" style="width: 100%; max-width: 660px; height: auto; border: 1px solid #e5e7eb; background: white;"></canvas>
        </div>
        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
            <button id="mds-apply-btn" class="active">Apply</button>
            <button onclick="document.getElementById('mds-overlay').style.display='none'">Close</button>
        </div>
    </div>
</div>

<div id="group-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 10000;">
    <div class="help-box" style="width: 450px;">
        <h2>Group Sequences</h2>
        <div class="help-row" style="flex-direction: column; align-items: flex-start; gap: 5px;">
            <label style="text-transform: none; font-size: 13px; color: #374151;">Delimiter Character</label>
            <input type="text" id="inp-group-delimiter" value="_" maxlength="1" style="width: 100%; padding: 5px; font-size: 13px;">
        </div>
        <div class="help-row" style="flex-direction: column; align-items: flex-start; gap: 5px; margin-top: 10px;">
            <label style="text-transform: none; font-size: 13px; color: #374151;">Field Number (1-indexed, after splitting by delimiter)</label>
            <input type="number" id="inp-group-field" value="3" min="1" style="width: 100%; padding: 5px; font-size: 13px;">
        </div>
        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
            <button onclick="document.getElementById('group-overlay').style.display='none'">Cancel</button>
            <button id="btn-run-group" class="active">Group</button>
        </div>
    </div>
</div>

<div id="color-legend" style="position: fixed; top: 100px; right: 20px; background: white; border: 1px solid #d1d5db; border-radius: 8px; padding: 15px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 5000; display: none; max-width: 250px; font-size: 12px;">
    <div id="legend-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; cursor: move; user-select: none;">
        <h3 style="margin: 0; font-size: 14px; color: #374151;">Color Legend</h3>
        <button onclick="document.getElementById('color-legend').style.display='none'" style="background: none; border: none; font-size: 18px; cursor: pointer; color: #6b7280;">×</button>
    </div>
    <div id="legend-groups" style="margin-bottom: 15px;">
        <div style="font-weight: 600; color: #374151; margin-bottom: 8px;">Groups:</div>
        <div id="legend-groups-content"></div>
    </div>
    <div id="legend-clusters">
        <div style="font-weight: 600; color: #374151; margin-bottom: 8px;">Clusters:</div>
        <div id="legend-clusters-content"></div>
    </div>
</div>

<div id="pdb-load-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 10000;">
    <div class="help-box" style="width: 320px;">
        <h2>Load 3D structure</h2>
        <div style="display: flex; flex-direction: column; gap: 12px; margin-top: 12px;">
            <button type="button" id="btn-pdb-choose-file" style="padding: 8px 14px; text-align: left;">Choose file...</button>
            <div style="display: flex; align-items: center; gap: 8px;">
                <label style="font-size: 13px; color: #374151; white-space: nowrap;">PDB ID</label>
                <input type="text" id="inp-pdb-id" placeholder="e.g. 7U2N" maxlength="4" style="width: 5em; padding: 6px 8px; font-size: 13px; border: 1px solid #d1d5db; border-radius: 4px;">
                <button type="button" id="btn-fetch-pdb">Fetch</button>
            </div>
        </div>
        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 16px;">
            <button type="button" id="btn-pdb-load-cancel">Cancel</button>
        </div>
    </div>
</div>

<div id="subtype-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 10000;">
    <div class="help-box" style="width: 450px;">
        <h2>Add Founder Sequence</h2>
        <div class="help-row" style="flex-direction: column; align-items: flex-start; gap: 5px;">
            <label style="text-transform: none; font-size: 13px; color: #374151;">Select Group</label>
            <select id="sel-subtype-group" style="width: 100%;">
                <option value="">-- Select a group --</option>
            </select>
        </div>
        <div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
            <button onclick="document.getElementById('subtype-overlay').style.display='none'">Cancel</button>
            <button id="btn-apply-subtype" class="active">Add Founder</button>
        </div>
    </div>
</div>

<div id="help-overlay">
    <div class="help-box">
        <h2>aliViz Help</h2>
        <div style="font-size: 0.75em; color: #6b7280; margin-bottom: 5px; padding-bottom: 5px; border-bottom: 1px solid #eee;">Based on the alignment app from <a href="https://murrellgroup.github.io/WebWidgets/alivibe.html" target="_blank" style="color: #3b82f6;">https://murrellgroup.github.io/WebWidgets/alivibe.html</a></div>
        <div class="help-row"><span class="help-key">Choose File</span> <span>Load an Alignment with Ref as first seq and SubType as second seq.</span></div>
        <div class="help-row"><span class="help-key">Sort</span> <span>Sort sequences by name (REF and SUBTYPE remain first)</span></div>
        <div class="help-row"><span class="help-key">Group</span> <span>Group sequences using field in Seq names</span></div>
        <div class="help-row"><span class="help-key">Add Founder</span> <span>Set a Founder sequence as consensus of a group</span></div>
        <div class="help-row"><span class="help-key">Infer</span> <span>Infer a phylogeny using FastTree of Neighbor Joining</span></div>
        <div class="help-row"><span class="help-key">Reroot</span> <span>Reroot tree on subtype sequence</span></div>
        <div class="help-row"><span class="help-key">Ladderize</span> <span>Ladderize tree and reorder sequences</span></div>
        <div class="help-row"><span class="help-key">Histogram</span> <span>Show histogram of root-to-leaf distances</span></div>
        <div class="help-row"><span class="help-key">Cluster</span> <span>Show 2D projection and clustering of pairwise leaf distances</span></div>
        <div class="help-row"><span class="help-key">fasta</span> <span>Download current view (NT or AA) as FASTA</span></div>
        <div class="help-row"><span class="help-key">tree</span> <span>Export current tree as Newick format</span></div>
        <div class="help-row"><span class="help-key">Clear Alignment</span> <span>Remove all sequences</span></div>
        <div class="help-row"><span class="help-key">Clear Tree</span> <span>Remove current tree</span></div>
        <div class="help-row"><span class="help-key">View Mode</span> <span>Switch between Nucleotide (NT) and Amino Acid (AA) view</span></div>
        <div class="help-row"><span class="help-key">Highlighter</span> <span>Highlight differences with respect to Reference, SubType, or Founder</span></div>
        <div class="help-row"><span class="help-key">Load Epitopes</span> <span>Load epitope descriptions from CSV file</span></div>
        <div class="help-row"><span class="help-key">Select Epitope</span> <span>Select an epitope to restrict display</span></div>
        <div class="help-row"><span class="help-key">Show Logo</span> <span>Generate sequence logo for selected epitope</span></div>
        <div class="help-row"><span class="help-key">3D Structure</span> <span>Load a PDB/CIF file, or enter a 4-character PDB ID and click Fetch to load from RCSB. Chains are added as sequences (xxxx_Chain_y [PDB_y]) and aligned to the reference (AA mode).</span></div>
        <div class="help-row"><span class="help-key">View 3D</span> <span>Display the loaded PDB structure in a 3D viewer window</span></div>
        <div class="help-row"><span class="help-key">IUPAC</span> <span>Full IUPAC ambiguity codes supported in Nucleotide view</span></div>
        <button class="close-help" onclick="document.getElementById('help-overlay').classList.remove('active')">Close</button>
    </div>
</div>

<div id="ctx-menu">
    <div class="item" id="ctx-info-group">Group: Not assigned</div>
    <div class="item" id="ctx-info-cluster">Cluster: Not assigned</div>
</div>

<div id="pdb3d-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 10001;">
    <div id="pdb3d-window" style="position: fixed; left: 5%; top: 5%; width: 90vw; max-width: 1000px; height: 85vh; background: var(--panel-bg, #fff); border-radius: 8px; box-shadow: 0 4px 24px rgba(0,0,0,0.2); display: flex; flex-direction: column; overflow: hidden; z-index: 10002;">
        <div id="pdb3d-title-bar" style="flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; padding: 10px 14px; border-bottom: 1px solid var(--border-color, #d1d5db); cursor: move; user-select: none; background: #fff; z-index: 10;">
            <span id="pdb3d-title" style="font-weight: 600;">PDB 3D Structure</span>
            <button id="btn-close-pdb3d" type="button" style="padding: 6px 12px; cursor: pointer;">Close</button>
        </div>
        <div id="pdb3d-hint" style="flex-shrink: 0; margin: 0; padding: 6px 14px; font-size: 11px; color: #374151; background: #f3f4f6; border-bottom: 1px solid var(--border-color, #e5e7eb); z-index: 10;">Epitope residues are colored automatically on intrinsic chains (residue colors, rest gray). <strong>Intrinsic</strong> = in panel, alignment &ge;50%; <strong>Extrinsic</strong> = in panel, &lt;50%; <strong>Superficial</strong> = not in panel. Use checkboxes to show/hide chains; set a different style per group.</div>
        <div id="pdb3d-toolbar" style="flex-shrink: 0; display: flex; flex-direction: column; gap: 10px; padding: 8px 14px; border-bottom: 1px solid var(--border-color, #e5e7eb); background: #fff; z-index: 10;">
            <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 8px;">
                <span style="font-size: 12px; font-weight: 600;">Intrinsic (&ge;50%):</span>
                <select id="pdb3d-style-intrinsic" style="padding: 4px 8px; font-size: 12px;">
                    <option value="cartoon">Cartoon</option>
                    <option value="sphere">Sphere</option>
                    <option value="stick">Stick</option>
                    <option value="line">Line</option>
                    <option value="cross">Cross</option>
                </select>
                <span id="pdb3d-intrinsic-chains" style="display: inline-flex; flex-wrap: wrap; gap: 6px; align-items: center;"></span>
                <button type="button" id="pdb3d-intrinsic-all" style="padding: 4px 8px; font-size: 11px;">All</button>
                <button type="button" id="pdb3d-intrinsic-none" style="padding: 4px 8px; font-size: 11px;">None</button>
            </div>
            <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 8px;">
                <span style="font-size: 12px; font-weight: 600;">Extrinsic (&lt;50%):</span>
                <select id="pdb3d-style-extrinsic" style="padding: 4px 8px; font-size: 12px;">
                    <option value="cartoon">Cartoon</option>
                    <option value="sphere">Sphere</option>
                    <option value="stick">Stick</option>
                    <option value="line">Line</option>
                    <option value="cross">Cross</option>
                </select>
                <span id="pdb3d-extrinsic-chains" style="display: inline-flex; flex-wrap: wrap; gap: 6px; align-items: center;"></span>
                <button type="button" id="pdb3d-extrinsic-all" style="padding: 4px 8px; font-size: 11px;">All</button>
                <button type="button" id="pdb3d-extrinsic-none" style="padding: 4px 8px; font-size: 11px;">None</button>
            </div>
            <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 8px;">
                <span style="font-size: 12px; font-weight: 600;">Superficial (not in panel):</span>
                <select id="pdb3d-style-superficial" style="padding: 4px 8px; font-size: 12px;">
                    <option value="sphere">Sphere</option>
                    <option value="stick">Stick</option>
                    <option value="cross">Cross</option>
                </select>
                <span id="pdb3d-superficial-chains" style="display: inline-flex; flex-wrap: wrap; gap: 6px; align-items: center;"></span>
                <button type="button" id="pdb3d-superficial-all" style="padding: 4px 8px; font-size: 11px;">All</button>
                <button type="button" id="pdb3d-superficial-none" style="padding: 4px 8px; font-size: 11px;">None</button>
            </div>
        </div>
        <div id="pdb3d-viewer" style="flex: 1; min-height: 0; width: 100%; position: relative; z-index: 1;"></div>
    </div>
</div>

<script>
// --- ALIGNMENT ALGORITHM ---
// Now imported from external library via script tag

// --- Config ---
const CONFIG = {
    font: "14px 'Courier New', monospace",
    labelFont: "12px system-ui, sans-serif",
    charWidth: 12,
    rowHeight: 24,
    highlightMatchColor: '#ffffff',
    highlightGapColor: '#d1d5db',
    rulerTickStep: 10,
    maxHistory: 30,
    colors: {
        // Includes IUPAC colors
        NT: { 
            'A': '#81d4fa', 'G': '#fff176', 'C': '#a5d6a7', 'T': '#ff8a80', 'U': '#ff8a80', 
            'R': '#e6ee9c', 'Y': '#80cbc4', 'M': '#a5d6a7', 'K': '#ef9a9a', 'S': '#c5e1a5', 
            'W': '#ce93d8', 'H': '#81d4fa', 'B': '#ef9a9a', 'V': '#fff59d', 'D': '#ffcc80', 
            'N': '#eeeeee',
            '-': '#ffffff', 'default': '#f5f5f5' 
        },
        AA: { 'A': '#80a0f0', 'R': '#f01505', 'N': '#00ff00', 'D': '#c048c0', 'C': '#f08080', 'Q': '#00ff00', 'E': '#c048c0', 'G': '#f09048', 'H': '#15a4a4', 'I': '#80a0f0', 'L': '#80a0f0', 'K': '#f01505', 'M': '#80a0f0', 'F': '#80a0f0', 'P': '#ffff00', 'S': '#00ff00', 'T': '#00ff00', 'W': '#80a0f0', 'Y': '#15a4a4', 'V': '#80a0f0', '*': '#999999', '-': '#ffffff', 'default': '#ffffff' }
    }
};

// Single color palette for both groups and clusters
// Index 0 is magenta (for cluster 0), indices 1+ are for groups and clusters 1+
const COLOR_PALETTE = [
    '#ff00ff', // Magenta (index 0 - for cluster 0)
    '#3b82f6', // Blue (index 1 - for first group/cluster 1)
    '#10b981', // Green (index 2 - for second group/cluster 2)
    '#f59e0b', // Amber (index 3 - for third group/cluster 3)
    '#8b5cf6', // Purple (index 4 - for fourth group/cluster 4)
    '#ec4899', // Pink (index 5)
    '#84cc16', // Lime (index 6)
    '#f97316', // Orange (index 7)
    '#6366f1', // Indigo (index 8)
    '#14b8a6', // Teal (index 9)
    '#ef4444', // Red (index 10)
    '#fbbf24', // Yellow (index 11)
    '#a855f7', // Violet (index 12)
    '#22c55e', // Emerald (index 13)
];

// Keep GROUP_COLORS for backward compatibility (same as COLOR_PALETTE[1+])
const GROUP_COLORS = COLOR_PALETTE.slice(1);

const GROUP_LIGHT_BG = [
    '#dbeafe', // Light blue
    '#d1fae5', // Light green
    '#fef3c7', // Light amber
    '#ede9fe', // Light purple
    '#fce7f3', // Light pink
    '#cffafe', // Light cyan
    '#ecfccb', // Light lime
    '#fed7aa', // Light orange
    '#e0e7ff', // Light indigo
    '#ccfbf1', // Light teal
    '#fee2e2', // Light red
    '#fef3c7', // Light yellow
    '#f3e8ff', // Light violet
    '#d1fae5', // Light emerald
    '#cffafe', // Light sky
];

// Helper function to get cluster color
// Uses COLOR_PALETTE directly: cluster 0 -> palette[0] (cyan), cluster 1 -> palette[1], etc.
function getClusterColor(clusterId) {
    return COLOR_PALETTE[clusterId % COLOR_PALETTE.length];
}

// Keep CLUSTER_COLORS for backward compatibility (deprecated, use getClusterColor instead)
const CLUSTER_COLORS = [
    '#06b6d4', // Cyan (cluster 0)
    '#3b82f6', // Blue (cluster 1, from GROUP_COLORS)
    '#10b981', // Green (cluster 2, from GROUP_COLORS)
    '#f59e0b', // Amber (cluster 3, from GROUP_COLORS)
    '#8b5cf6', // Purple (cluster 4, from GROUP_COLORS)
    '#ec4899', // Pink (cluster 5, from GROUP_COLORS)
    '#06b6d4', // Cyan (cluster 6, from GROUP_COLORS)
    '#84cc16', // Lime (cluster 7, from GROUP_COLORS)
    '#f97316', // Orange (cluster 8, from GROUP_COLORS)
    '#6366f1', // Indigo (cluster 9, from GROUP_COLORS)
];

const CLUSTER_LIGHT_BG = [
    '#ffe4e6', // Light rose
    '#d1fae5', // Light emerald
    '#fee2e2', // Light red
    '#ede9fe', // Light violet
    '#fed7aa', // Light orange
    '#e0f2fe', // Light sky
    '#dcfce7', // Light green
    '#fef3c7', // Light yellow
    '#fce7f3', // Light pink
    '#cffafe', // Light cyan
];

const CODON_TABLE = {
    'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M', 'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
    'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K', 'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',
    'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L', 'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
    'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q', 'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
    'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V', 'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
    'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E', 'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
    'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S', 'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',
    'TAC':'Y', 'TAT':'Y', 'TAA':'*', 'TAG':'*', 'TGC':'C', 'TGT':'C', 'TGA':'*', 'TGG':'W',
};

// --- State ---
const state = {
    rawSequences: [],
    viewSequences: [],
    history: [],
    dragSaved: false,
    mode: 'NT',
    highlightMatches: '', // 'founder', 'subtype', 'reference', or '' (off)
    frame: 1,
    maxLength: 0,
    selection: null,
    selectionAnchor: null, 
    tree: null, 
    treeWidth: 0, 
    namesWidth: 200,
    refIndex: 0, 
    subtypeIndex: 1, // Second sequence (index 1) is the subtype
    refMap: [], 
    epitopes: [], // Array of {name: string, regions: [{start: number, end: number}]}
    selectedEpitope: null, // Selected epitope name or null
    epitopeColumns: null, // Set of allowed alignment column indices for selected epitope 
    mouse: { isDown: false, target: null, startR: 0, startC: 0, lastHoverC: 0 },
    ctxTargetRow: null,
    pastedNameCounter: 1,
    aioliCLI: null,
    isAASequence: false, // Flag to track if sequences are already amino acids (not DNA to be translated)
    leafClusters: null, // Map from leaf name to cluster ID (from MDS clustering)
    hierarchicalActive: false, // Whether hierarchical clustering modal is active
    hierarchicalDepths: [0, 0, 0], // Current depth values for hierarchical clustering sliders
    sequenceGroups: null, // Map from sequence name to group ID (from grouping by name field)
    groupDelimiter: null, // Delimiter used for grouping
    groupFieldNum: null, // Field number (1-based) used for grouping
    groupNames: null, // Map from group ID to group value (for legend)
    originalSubtype: null, // Store original subtype sequence for reverting
    currentFileName: null, // Store the current alignment file name
    pdbFileContent: null, // Raw PDB/CIF text for 3D viewer (set when Load PDB/CIF or fetch by ID)
    pdbFileName: null,    // PDB/CIF file name for 3D overlay title
    pdbFormat: 'pdb'     // 'pdb' or 'cif' for 3Dmol addModel
};

// --- DOM ---
const dom = {
    file: document.getElementById('inp-file'),
    fileTree: document.getElementById('inp-tree'),
    btnInferTree: document.getElementById('btn-infer-tree'),
    btnExportTree: document.getElementById('btn-export-tree'),
    btnLadderizeTree: document.getElementById('btn-ladderize-tree'),
    btnRerootTree: document.getElementById('btn-reroot-tree'),
    btnHistogram: document.getElementById('btn-histogram'),
    btnMds: document.getElementById('btn-mds'),
    btnSortSequences: document.getElementById('btn-sort-sequences'),
    btnGroupSequences: document.getElementById('btn-group-sequences'),
    btnSubtype: document.getElementById('btn-subtype'),
    btnClearAlignment: document.getElementById('btn-clear-aln'),
    btnClearTree: document.getElementById('btn-clear-tree'),
    btnUndo: document.getElementById('btn-undo'),
    btnNt: document.getElementById('btn-nt'),
    btnAa: document.getElementById('btn-aa'),
    selHighlight: document.getElementById('sel-highlight'),
    btnDownload: document.getElementById('btn-download'),
    btnCopy: document.getElementById('btn-copy'),
    btnHelp: document.getElementById('btn-help'),
    inpEpitopes: document.getElementById('inp-epitopes'),
    btnLoadEpitopes: document.getElementById('btn-load-epitopes'),
    btnSelectEpitope: document.getElementById('btn-select-epitope'),
    btnShowLogo: document.getElementById('btn-show-logo'),
    inpPdb: document.getElementById('inp-pdb'),
    inpPdbId: document.getElementById('inp-pdb-id'),
    btnLoadPdb: document.getElementById('btn-load-pdb'),
    btnFetchPdb: document.getElementById('btn-fetch-pdb'),
    btnView3d: document.getElementById('btn-view-3d'),
    pdbOverlay: document.getElementById('pdb3d-overlay'),
    pdbViewerContainer: document.getElementById('pdb3d-viewer'),
    pdbTitle: document.getElementById('pdb3d-title'),
    selFrame: document.getElementById('sel-frame'),
    grpFrame: document.getElementById('grp-frame'),
    overlay: document.getElementById('overlay'),
    overlayMsg: document.getElementById('overlay-msg'),
    overlaySub: document.getElementById('overlay-sub'),
    helpOverlay: document.getElementById('help-overlay'),
    ctxMenu: document.getElementById('ctx-menu'),
    ctxInfoGroup: document.getElementById('ctx-info-group'),
    ctxInfoCluster: document.getElementById('ctx-info-cluster'),
    
    areaSeq: document.getElementById('area-seq'),
    areaNames: document.getElementById('area-names'),
    areaRuler: document.getElementById('area-ruler'),
    areaTree: document.getElementById('area-tree'),
    resizerTree: document.getElementById('resizer-tree'),
    resizerNames: document.getElementById('resizer-names'),
    
    cvsSeq: document.getElementById('cvs-seq'),
    cvsNames: document.getElementById('cvs-names'),
    cvsRuler: document.getElementById('cvs-ruler'),
    cvsTree: document.getElementById('cvs-tree'),
    sizer: document.getElementById('scroll-sizer')
};

const ctxSeq = dom.cvsSeq.getContext('2d', { alpha: false });
const ctxNames = dom.cvsNames.getContext('2d');
const ctxRuler = dom.cvsRuler.getContext('2d');
const ctxTree = dom.cvsTree.getContext('2d');

// Helper function to draw a diamond shape
function drawDiamond(ctx, x, y, size) {
    ctx.beginPath();
    ctx.moveTo(x, y - size);      // Top
    ctx.lineTo(x + size, y);     // Right
    ctx.lineTo(x, y + size);     // Bottom
    ctx.lineTo(x - size, y);     // Left
    ctx.closePath();
    ctx.fill();
}

// --- Button State Management ---
function disableButtonsOnStartup() {
    // Disable all buttons except the help button and file input
    if (dom.btnSortSequences) dom.btnSortSequences.disabled = true;
    if (dom.btnGroupSequences) dom.btnGroupSequences.disabled = true;
    if (dom.btnSubtype) dom.btnSubtype.disabled = true;
    if (dom.btnInferTree) dom.btnInferTree.disabled = true;
    if (dom.btnRerootTree) dom.btnRerootTree.disabled = true;
    if (dom.btnLadderizeTree) dom.btnLadderizeTree.disabled = true;
    if (dom.btnHistogram) dom.btnHistogram.disabled = true;
    if (dom.btnMds) dom.btnMds.disabled = true;
    if (dom.btnDownload) dom.btnDownload.disabled = true;
    if (dom.btnExportTree) dom.btnExportTree.disabled = true;
    if (dom.btnClearAlignment) dom.btnClearAlignment.disabled = true;
    if (dom.btnClearTree) dom.btnClearTree.disabled = true;
    if (dom.btnUndo) dom.btnUndo.disabled = true;
    if (dom.btnNt) dom.btnNt.disabled = true;
    if (dom.btnAa) dom.btnAa.disabled = true;
    if (dom.selHighlight) dom.selHighlight.disabled = true;
    if (dom.btnLoadEpitopes) dom.btnLoadEpitopes.disabled = true;
    if (dom.btnSelectEpitope) dom.btnSelectEpitope.disabled = true;
    if (dom.btnShowLogo) dom.btnShowLogo.disabled = true;
    // Help button should always be enabled, so we don't disable it
}

function enableButtonsAfterLoad() {
    // Enable buttons that become usable after a file is loaded
    // Group is enabled, but Add Founder and Sort require a successful grouping first
    if (dom.btnGroupSequences) dom.btnGroupSequences.disabled = false;
    if (dom.btnInferTree) dom.btnInferTree.disabled = false;
    if (dom.btnDownload) dom.btnDownload.disabled = false;
    if (dom.btnClearAlignment) dom.btnClearAlignment.disabled = false;
    if (dom.selHighlight) dom.selHighlight.disabled = false;
    if (dom.btnLoadEpitopes) dom.btnLoadEpitopes.disabled = false;
    // Add Founder and Sort remain disabled until grouping is done
    // Histogram, Cluster, and tree export remain disabled until ladderize is done
}

function enableButtonsAfterGrouping() {
    // Enable Add Founder and Sort after successful grouping
    if (dom.btnSubtype) dom.btnSubtype.disabled = false;
    if (dom.btnSortSequences) dom.btnSortSequences.disabled = false;
}

function enableButtonsAfterInference() {
    // Enable Reroot and Clear Tree buttons after successful tree inference
    if (dom.btnRerootTree) dom.btnRerootTree.disabled = false;
    if (dom.btnClearTree) dom.btnClearTree.disabled = false;
}

function enableButtonsAfterReroot() {
    // Enable Ladderize button after successful rerooting
    if (dom.btnLadderizeTree) dom.btnLadderizeTree.disabled = false;
}

function enableButtonsAfterLadderize() {
    // Enable Histogram, Cluster, and tree export buttons after successful ladderize
    if (dom.btnHistogram) dom.btnHistogram.disabled = false;
    if (dom.btnMds) dom.btnMds.disabled = false;
    if (dom.btnExportTree) dom.btnExportTree.disabled = false;
}

function enableButtonsAfterLoadEpitopes() {
    // Enable Select Epitope button after successful epitope loading
    if (dom.btnSelectEpitope) dom.btnSelectEpitope.disabled = false;
}

function enableButtonsAfterSelectEpitope() {
    // Enable Show Logo button after successful epitope selection
    if (dom.btnShowLogo) dom.btnShowLogo.disabled = false;
}

// --- Init ---
async function init() {
    // Initialize Aioli with FastTree only
    try {
        console.log("Loading FastTree from bioWASM...");
        state.aioliCLI = await new Aioli(["fasttree/2.1.11"]);
        console.log("FastTree successfully loaded");
        } catch (err) {
        console.error("Failed to initialize FastTree:", err);
        state.aioliCLI = null;
    }
    
    // Disable buttons that require a file to be loaded
    disableButtonsOnStartup();

    dom.file.addEventListener('change', e => loadFile(e.target.files[0]));
    if (dom.fileTree) {
        dom.fileTree.addEventListener('change', e => loadTreeFile(e.target.files[0]));
    }
    if (dom.btnSortSequences) {
        dom.btnSortSequences.addEventListener('click', sortSequencesByName);
    }
    if (dom.btnGroupSequences) {
        dom.btnGroupSequences.addEventListener('click', showGroupModal);
    }
    if (dom.btnSubtype) {
        dom.btnSubtype.addEventListener('click', showSubtypeModal);
    }
    document.getElementById('btn-apply-subtype').addEventListener('click', applySubtypeFounder);
    const btnRunGroup = document.getElementById('btn-run-group');
    if (btnRunGroup) {
        btnRunGroup.addEventListener('click', runGroupTask);
    }
    if (dom.btnLoadEpitopes) {
        dom.btnLoadEpitopes.addEventListener('click', () => dom.inpEpitopes.click());
    }
    if (dom.inpEpitopes) {
        dom.inpEpitopes.addEventListener('change', e => loadEpitopes(e.target.files[0]));
    }
    if (dom.btnSelectEpitope) {
        dom.btnSelectEpitope.addEventListener('click', showEpitopeSelector);
    }
    if (dom.btnShowLogo) {
        dom.btnShowLogo.addEventListener('click', showSequenceLogo);
    }
    var pdbLoadOverlay = document.getElementById('pdb-load-overlay');
    if (dom.btnLoadPdb) {
        dom.btnLoadPdb.addEventListener('click', function () {
            if (pdbLoadOverlay) pdbLoadOverlay.style.display = 'flex';
        });
    }
    if (document.getElementById('btn-pdb-choose-file') && dom.inpPdb) {
        document.getElementById('btn-pdb-choose-file').addEventListener('click', function () { dom.inpPdb.click(); });
    }
    if (dom.inpPdb) {
        dom.inpPdb.addEventListener('change', function (e) {
            if (e.target.files && e.target.files[0]) {
                loadPdbFile(e.target.files[0]);
                if (pdbLoadOverlay) pdbLoadOverlay.style.display = 'none';
            }
            e.target.value = '';
        });
    }
    if (document.getElementById('btn-pdb-load-cancel')) {
        document.getElementById('btn-pdb-load-cancel').addEventListener('click', function () {
            if (pdbLoadOverlay) pdbLoadOverlay.style.display = 'none';
        });
    }
    if (pdbLoadOverlay) {
        pdbLoadOverlay.addEventListener('click', function (e) {
            if (e.target === pdbLoadOverlay) pdbLoadOverlay.style.display = 'none';
        });
    }
    if (dom.btnFetchPdb && dom.inpPdbId) {
        dom.btnFetchPdb.addEventListener('click', function () {
            var code = (dom.inpPdbId.value || '').trim().toUpperCase().slice(0, 4);
            if (!/^[A-Z0-9]{4}$/.test(code)) {
                alert('Enter a valid 4-character PDB ID (e.g. 7U2N).');
                return;
            }
            if (pdbLoadOverlay) pdbLoadOverlay.style.display = 'none';
            loadPdbById(code);
        });
    }
    if (dom.btnView3d) {
        dom.btnView3d.addEventListener('click', openPdbViewerFromState);
    }
    const btnClosePdb3d = document.getElementById('btn-close-pdb3d');
    if (btnClosePdb3d && dom.pdbOverlay) {
        btnClosePdb3d.addEventListener('mousedown', e => e.stopPropagation());
        btnClosePdb3d.addEventListener('click', closePdbViewer);
    }
    if (dom.pdbOverlay) {
        dom.pdbOverlay.addEventListener('click', e => { if (e.target === dom.pdbOverlay) closePdbViewer(); });
    }
    dom.btnInferTree.addEventListener('click', showInferModal);
    dom.btnExportTree.addEventListener('click', exportTree);
    dom.btnLadderizeTree.addEventListener('click', showLadderizeModal);
    if (dom.btnRerootTree) {
        dom.btnRerootTree.addEventListener('click', showRerootModal);
    }
    
    const btnRunReroot = document.getElementById('btn-run-reroot');
    if (btnRunReroot) {
        btnRunReroot.addEventListener('click', runRerootTask);
    }
    if (dom.btnHistogram) {
        dom.btnHistogram.addEventListener('click', showHistogramModal);
    }
    if (dom.btnMds) {
        dom.btnMds.addEventListener('click', showMdsModal);
    }
    
    // Method selection popup - Continue button
    const btnConfirmMethod = document.getElementById('btn-confirm-method');
    if (btnConfirmMethod) {
        btnConfirmMethod.addEventListener('click', () => {
            const methodSelect = document.getElementById('sel-projection-method');
            const selectedMethod = methodSelect ? methodSelect.value : 'mds';
            document.getElementById('method-select-overlay').style.display = 'none';
            if (selectedMethod === 'hierarchical') {
                showHierarchicalModal();
            } else {
                showProjectionPlot(selectedMethod);
            }
        });
    }
    document.getElementById('btn-run-ladderize').addEventListener('click', runLadderizeTask);
    dom.btnClearAlignment.addEventListener('click', clearAlignment);
    dom.btnClearTree.addEventListener('click', clearTreeOnly);
    if (dom.btnUndo) {
        dom.btnUndo.addEventListener('click', undo);
    }
    dom.btnNt.addEventListener('click', () => setMode('NT'));
    dom.btnAa.addEventListener('click', () => setMode('AA'));
    dom.selHighlight.addEventListener('change', () => {
        state.highlightMatches = dom.selHighlight.value;
        render();
    });
    if (dom.selFrame) {
        dom.selFrame.addEventListener('change', () => { state.frame = +dom.selFrame.value; recalc(); });
    }
    
    
    document.getElementById('sel-infer-method').addEventListener('change', (e) => {
        document.getElementById('fasttree-options').style.display = (e.target.value === 'fasttree') ? 'flex' : 'none';
    });
    document.getElementById('btn-run-infer').addEventListener('click', runInferTask);

    dom.btnDownload.addEventListener('click', () => exportAlignment('download'));
    if (dom.btnCopy) {
        dom.btnCopy.addEventListener('click', handleCopyButton);
    }
    dom.btnHelp.addEventListener('click', () => dom.helpOverlay.classList.add('active'));

    dom.areaSeq.addEventListener('scroll', () => requestAnimationFrame(render));
    window.addEventListener('resize', onResize);

    // Ensure top controls panel can scroll horizontally (wheel/trackpad over panel).
    // Attach to #controls (always present) and resolve #controls-scroll in the handler so it works
    // after refresh: refresh can load cached HTML without #controls-scroll, so attaching only to
    // #controls-scroll at init would attach nothing; new tab loads fresh HTML and would work.
    var controlsPanel = document.getElementById('controls');
    if (controlsPanel) {
        controlsPanel.addEventListener('wheel', function (e) {
            var scrollEl = document.getElementById('controls-scroll');
            if (!scrollEl) return;
            if (e.deltaX !== 0) {
                scrollEl.scrollLeft += e.deltaX;
                e.preventDefault();
            } else if (e.deltaY !== 0) {
                scrollEl.scrollLeft += e.deltaY;
                e.preventDefault();
            }
        }, { passive: false });
    }
    
    dom.areaSeq.addEventListener('mousedown', (e) => onMouseDown(e, 'SEQ'));
    dom.areaNames.addEventListener('mousedown', (e) => { 
        if(e.button === 2) return; 
        e.preventDefault(); onMouseDown(e, 'NAMES'); 
    });
    dom.areaRuler.addEventListener('mousedown', (e) => { e.preventDefault(); onMouseDown(e, 'RULER'); });
    
    dom.areaNames.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const { r } = getCoords(e, 'NAMES');
        if(r >= 0 && r < state.viewSequences.length) {
            state.ctxTargetRow = r;
            const seqName = state.viewSequences[r].name;
            
            // Get group info
            let groupText = 'Not assigned';
            if (state.sequenceGroups && state.groupNames) {
                const groupId = state.sequenceGroups.get(seqName);
                if (groupId !== undefined && state.groupNames.has(groupId)) {
                    const groupValue = state.groupNames.get(groupId);
                    groupText = groupValue || `Group ${groupId}`;
                }
            }
            dom.ctxInfoGroup.textContent = `Group: ${groupText}`;
            
            // Get cluster info
            let clusterText = 'Not assigned';
            if (state.leafClusters) {
                const clusterId = state.leafClusters.get(seqName);
                if (clusterId !== undefined) {
                    if (clusterId === -1) {
                        clusterText = 'Noise';
                    } else {
                        clusterText = `Cluster ${clusterId}`;
                    }
                }
            }
            dom.ctxInfoCluster.textContent = `Cluster: ${clusterText}`;
            
            dom.ctxMenu.style.display = 'block';
            dom.ctxMenu.style.left = e.clientX + 'px';
            dom.ctxMenu.style.top = e.clientY + 'px';
        }
    });

    window.addEventListener('mousedown', (e) => {
        if(!dom.ctxMenu.contains(e.target)) dom.ctxMenu.style.display = 'none';
    });

    dom.resizerTree.addEventListener('mousedown', (e) => {
        e.preventDefault();
        state.mouse.isDown = true;
        state.mouse.target = 'RESIZE_TREE';
    });

    dom.resizerNames.addEventListener('mousedown', (e) => {
        e.preventDefault();
        state.mouse.isDown = true;
        state.mouse.target = 'RESIZE_NAMES';
        state.mouse.startX = e.clientX;
        state.mouse.startNamesWidth = state.namesWidth;
    });

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    
    dom.areaSeq.addEventListener('keydown', onKeyDown);
    window.addEventListener('keydown', (e) => {
        if((e.ctrlKey || e.metaKey) && e.key === 'z') {
            e.preventDefault();
            undo();
        }
    });
    window.addEventListener('copy', onCopyEvent);
    window.addEventListener('paste', onPasteEvent);

    // Initialize names width
    setNamesWidth(state.namesWidth);
    
    // Initialize highlighter select to match state
    if (dom.selHighlight) {
        dom.selHighlight.value = state.highlightMatches || '';
    }

    onResize();
    
    // Check for URL parameters and load if present
    loadFromURLParams();
}

// --- Export Logic ---
function exportAlignment(target) {
    if (!state.viewSequences.length) return;
    
    const rows = state.viewSequences.map((_, idx) => idx);
    const content = buildFastaContent(rows, 0, null);
    if(!content) return;

    if (target === 'clipboard') {
        if(navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(content).catch(err => {
                console.error("Copy failed:", err);
                alert("Copy failed: " + err.message);
            });
        } else {
            alert("Clipboard API not available.");
        }
    } else {
        const blob = new Blob([content], {type: "text/plain"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `alignment_${state.mode}.fasta`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
}

function getSelectionBounds() {
    if(!state.selection || !state.viewSequences.length) return null;
    const totalRows = state.viewSequences.length;
    const rowStart = Math.max(0, Math.min(state.selection.r1, totalRows - 1));
    const rowEnd = Math.max(0, Math.min(state.selection.r2, totalRows - 1));
    if(rowEnd < rowStart) return null;
    const rows = [];
    for(let r=rowStart; r<=rowEnd; r++) rows.push(r);
    if(!rows.length) return null;
    const isFullRow = state.selection.c2 >= 99999999;
    const colStart = isFullRow ? 0 : Math.max(0, state.selection.c1);
    const colEnd = isFullRow ? null : Math.max(colStart, state.selection.c2);
    return { rows, colStart, colEnd };
}

function buildFastaContent(rows, colStart = 0, colEnd = null) {
    if(!rows || !rows.length) return "";
    const lines = [];
    rows.forEach(r => {
        const entry = state.viewSequences[r];
        if(!entry) return;
        const seq = entry.seq;
        const start = Math.min(colStart, seq.length);
        const end = (colEnd === null || colEnd === undefined) ? seq.length : Math.min(seq.length, colEnd + 1);
        const fragment = seq.slice(start, end).join('');
        lines.push(`>${entry.name}`);
        lines.push(fragment);
    });
    return lines.join('\n') + (lines.length ? '\n' : '');
}

function getClipboardContent(preferSelection = true) {
    if(!state.viewSequences.length) return "";
    let bounds = preferSelection ? getSelectionBounds() : null;
    if(!bounds) {
        const rows = state.viewSequences.map((_, idx) => idx);
        bounds = { rows, colStart: 0, colEnd: null };
    }
    return buildFastaContent(bounds.rows, bounds.colStart, bounds.colEnd);
}

function shouldHandleClipboardEvent() {
    return document.activeElement === dom.areaSeq;
}

function handleCopyButton() {
    if (!dom.btnCopy) return; // Copy button is commented out
    const content = getClipboardContent(true);
    if(!content) return;
    if(!navigator.clipboard || !navigator.clipboard.writeText) {
        alert("Clipboard API not available.");
        return;
    }
    const originalText = dom.btnCopy.textContent;
    navigator.clipboard.writeText(content).then(() => {
        dom.btnCopy.textContent = "Copied!";
        setTimeout(() => dom.btnCopy.textContent = originalText, 1500);
    }).catch(err => {
        console.error("Copy failed:", err);
        dom.btnCopy.textContent = originalText;
        alert("Copy failed: " + err.message);
    });
}

function onCopyEvent(e) {
    if(!shouldHandleClipboardEvent()) return;
    const content = getClipboardContent(true);
    if(!content) return;
    if(e.clipboardData) {
        e.clipboardData.setData('text/plain', content);
        e.preventDefault();
    }
}

function onPasteEvent(e) {
    if(!shouldHandleClipboardEvent()) return;
    const data = e.clipboardData || window.clipboardData;
    if(!data) return;
    const text = data.getData('text/plain');
    if(!text) return;
    e.preventDefault();
    handleClipboardPaste(text);
}

function handleClipboardPaste(text) {
    if(!text) return;
    const trimmed = text.trim();
    if(!trimmed) return;

    const fastaEntries = parseClipboardFasta(trimmed);
    if(fastaEntries.length) {
        appendSequencesFromClipboard(fastaEntries);
        return;
    }

    const lines = trimmed.split(/\r?\n/).filter(line => line.trim().length > 0);
    if(lines.length === 1) {
        const seqStr = lines[0].replace(/\s+/g, '').toUpperCase().replace(/[^A-Z-]/g, '');
        if(seqStr.length) {
            appendSequencesFromClipboard([{ name: null, seq: seqStr.split('') }]);
            return;
        }
    }

    alert("Could not parse pasted content. Provide FASTA or a single sequence line.");
}

function parseClipboardFasta(text) {
    const lines = text.split(/\r?\n/);
    const seqs = [];
    let currentName = null;
    let buffer = [];
    let sawHeader = false;

    for(let rawLine of lines) {
        const line = rawLine.trim();
        if(!line) continue;
        if(line.startsWith('>')) {
            sawHeader = true;
            if(currentName !== null) {
                const seqStr = buffer.join('');
                if(seqStr.length) seqs.push({ name: currentName, seq: seqStr.split('') });
            }
            currentName = line.substring(1).trim() || null;
            buffer = [];
        } else if(currentName !== null) {
            buffer.push(line.toUpperCase().replace(/[^A-Z-]/g, ''));
        }
    }

    if(currentName !== null) {
        const seqStr = buffer.join('');
        if(seqStr.length) seqs.push({ name: currentName, seq: seqStr.split('') });
    }

    if(!sawHeader) return [];
    return seqs;
}

function appendSequencesFromClipboard(entries) {
    const payload = entries.filter(e => e.seq && e.seq.length);
    if(!payload.length) return;
    saveState();
    const existingNames = new Set(state.rawSequences.map(s => s.name));
    payload.forEach(entry => {
        let name = entry.name && entry.name.trim().length ? entry.name.trim() : '';
        if(!name) name = generatePastedName();
        while(existingNames.has(name)) {
            name = generatePastedName();
        }
        existingNames.add(name);
        state.rawSequences.push({ name, seq: entry.seq.slice() });
    });
    state.selection = null;
    recalc();
}

function generatePastedName() {
    return `Pasted_${state.pastedNameCounter++}`;
}


function clearAlignment() {
    if(!state.rawSequences.length) return;
    if(!confirm("Clear all sequences and the current tree?")) return;
    saveState();
    state.rawSequences = [];
    state.viewSequences = [];
    state.selection = null;
    state.tree = null;
    state.refIndex = 0;
    state.maxLength = 0;
    state.refMap = [];
    state.pastedNameCounter = 1;
    state.sequenceGroups = null;
    state.groupDelimiter = null;
    state.groupFieldNum = null;
    state.groupNames = null;
    state.leafClusters = null;
    state.pdbFileContent = null;
    state.pdbFileName = null;
    state.pdbFormat = 'pdb';
    dom.sizer.style.width = '1px';
    dom.sizer.style.height = '1px';
    setTreeWidth(0);
    updateColorLegend();
    
    // Disable buttons again after clearing alignment
    disableButtonsOnStartup();
    
    recalc();
    render();
}

function clearTreeOnly() {
    state.tree = null;
    state.leafClusters = null; // Clear clusters when tree is cleared
    setTreeWidth(0);
    if (dom.btnHistogram) {
        dom.btnHistogram.disabled = true;
    }
    if (dom.btnMds) {
        dom.btnMds.disabled = true;
    }
    // Disable Clear Tree button after clearing the tree
    if (dom.btnClearTree) {
        dom.btnClearTree.disabled = true;
    }
    // Also disable buttons that depend on the tree
    if (dom.btnRerootTree) {
        dom.btnRerootTree.disabled = true;
    }
    if (dom.btnLadderizeTree) {
        dom.btnLadderizeTree.disabled = true;
    }
    if (dom.btnExportTree) {
        dom.btnExportTree.disabled = true;
    }
    updateColorLegend();
    render();
}

// --- History ---
function saveState() {
    const snapshot = {
        seqs: JSON.parse(JSON.stringify(state.rawSequences)),
        sel: state.selection ? { ...state.selection } : null,
        refIdx: state.refIndex
    };
    state.history.push(snapshot);
    if(state.history.length > CONFIG.maxHistory) state.history.shift();
}

function undo() {
    if(state.history.length === 0) return;
    const prev = state.history.pop();
    state.rawSequences = prev.seqs;
    state.selection = prev.sel;
    if(prev.refIdx < state.rawSequences.length) state.refIndex = prev.refIdx;
    else state.refIndex = 0;
    
    recalc();
}

// --- Loading ---
function loadFile(file) {
    if(!file) return;
    showOverlay(true);
    const reader = new FileReader();
    const name = file.name.toLowerCase();
    const isFastq = name.endsWith('.fastq') || name.endsWith('.fq');
    
    // Store the file name
    state.currentFileName = file.name;

    reader.onload = e => {
        if(isFastq) parseFastq(e.target.result);
        else parseFasta(e.target.result);
    };
    reader.readAsText(file);
}

function loadTreeFile(file) {
    if(!file) return;
    showOverlay(true);
    const reader = new FileReader();
    reader.onload = e => parseTree(e.target.result, false, false); // Don't reroot when loading from file
    reader.readAsText(file);
}

// --- Sort Sequences by Name ---
function sortSequencesByName() {
    if (state.rawSequences.length === 0) {
        alert("No sequences to sort.");
        return;
    }
    
    saveState();
    
    // Get REF and SUBTYPE sequences (they stay in positions 0 and 1)
    const refSeq = state.rawSequences[state.refIndex];
    const subtypeSeq = state.subtypeIndex >= 0 && state.subtypeIndex < state.rawSequences.length 
        ? state.rawSequences[state.subtypeIndex] 
        : null;
    
    // Get other sequences: non-PDB (for sorting) and PDB chains (kept in order, always after Reference)
    const otherSeqs = [];
    const pdbChains = [];
    for (let i = 0; i < state.rawSequences.length; i++) {
        if (i === state.refIndex || i === state.subtypeIndex) continue;
        const s = state.rawSequences[i];
        if (isPdbChainSequence(s)) {
            pdbChains.push(s);
        } else {
            otherSeqs.push({ index: i, seq: s });
        }
    }
    
    // Sort non-PDB sequences by name
    otherSeqs.sort((a, b) => {
        const nameA = a.seq.name || '';
        const nameB = b.seq.name || '';
        return nameA.localeCompare(nameB);
    });
    
    // Rebuild: REF at 0, then PDB chains, then SUBTYPE (if any), then sorted non-PDB
    const newSequences = [refSeq];
    pdbChains.forEach(s => newSequences.push(s));
    if (subtypeSeq && subtypeSeq !== refSeq) {
        newSequences.push(subtypeSeq);
    }
    otherSeqs.forEach(item => {
        if (item.seq !== refSeq && item.seq !== subtypeSeq) {
            newSequences.push(item.seq);
        }
    });
    
    state.rawSequences = newSequences;
    
    // Update indices (subtype position depends on how many PDB chains are after ref)
    state.refIndex = 0;
    const subtypeName = subtypeSeq ? subtypeSeq.name : null;
    if (subtypeName) {
        const newSubtypeIdx = state.rawSequences.findIndex(s => s.name === subtypeName);
        state.subtypeIndex = newSubtypeIdx >= 0 ? newSubtypeIdx : 0;
    } else {
        state.subtypeIndex = state.rawSequences.length > 1 ? 1 : 0;
    }
    
    // Recalculate view sequences
    state.viewSequences = [...state.rawSequences];
    
    // Recalculate names width
    calculateNamesWidth();
    
    // Re-render
    recalc();
}

// --- Group Sequences by Name Field ---
function showGroupModal() {
    if (state.rawSequences.length === 0) {
        alert("No sequences to group.");
        return;
    }
    document.getElementById('group-overlay').style.display = 'flex';
}

function runGroupTask() {
    const delimiter = document.getElementById('inp-group-delimiter').value || '_';
    const fieldNumOneBased = parseInt(document.getElementById('inp-group-field').value) || 3;
    
    if (delimiter.length === 0) {
        alert("Please specify a delimiter character.");
        return;
    }
    
    if (fieldNumOneBased < 1) {
        alert("Field number must be at least 1.");
        return;
    }
    
    // Convert 1-based field number to 0-based array index
    const fieldNum = fieldNumOneBased - 1;
    
    document.getElementById('group-overlay').style.display = 'none';
    
    // Save state for undo
    saveState();
    
    // Group sequences by the specified field (no need to remove tree as grouping doesn't reorder sequences)
    const nameToGroup = new Map();
    const uniqueGroupValues = new Set();
    
    // First pass: collect all unique group values
    for (let i = 0; i < state.rawSequences.length; i++) {
        // Exclude REF, SUBTYPE, and PDB chain sequences (3D only)
        if (i === state.refIndex || i === state.subtypeIndex || isPdbChainSequence(state.rawSequences[i])) {
            continue;
        }
        
        const seq = state.rawSequences[i];
        const name = seq.name || '';
        
        // Split by delimiter
        const fields = name.split(delimiter);
        
        if (fields.length > fieldNum) {
            const groupValue = fields[fieldNum];
            uniqueGroupValues.add(groupValue);
        }
    }
    
    // Sort group values alphabetically and assign IDs and colors
    const sortedGroupValues = Array.from(uniqueGroupValues).sort();
    const groupNames = new Map(); // Map from group value to group ID
    const groupIdToValue = new Map(); // Map from group ID to group value (for legend)
    
    sortedGroupValues.forEach((groupValue, index) => {
        const groupId = index;
        groupNames.set(groupValue, groupId);
        groupIdToValue.set(groupId, groupValue);
    });
    
    // Second pass: assign group IDs to sequences
    for (let i = 0; i < state.rawSequences.length; i++) {
        // Exclude REF, SUBTYPE, and PDB chain sequences (3D only)
        if (i === state.refIndex || i === state.subtypeIndex || isPdbChainSequence(state.rawSequences[i])) {
            continue;
        }
        
        const seq = state.rawSequences[i];
        const name = seq.name || '';
        
        // Split by delimiter
        const fields = name.split(delimiter);
        
        if (fields.length > fieldNum) {
            const groupValue = fields[fieldNum];
            const gId = groupNames.get(groupValue);
            if (gId !== undefined) {
                nameToGroup.set(name, gId);
            }
        }
    }
    
    // Store grouping in state
    state.sequenceGroups = nameToGroup;
    state.groupDelimiter = delimiter;
    state.groupFieldNum = fieldNumOneBased; // Store 1-based field number
    state.groupNames = groupIdToValue; // Store group ID to value mapping for legend
    
    // Enable Add Founder and Sort buttons after successful grouping
    enableButtonsAfterGrouping();
    
    // Update legend
    updateColorLegend();
    
    // Re-render
    recalc();
}

// --- Add Founder Sequence ---
function showSubtypeModal() {
    if (!state.sequenceGroups || state.groupNames.size === 0) {
        alert("Please group sequences first before adding a founder sequence.");
        return;
    }
    
    // Populate group selector
    const select = document.getElementById('sel-subtype-group');
    select.innerHTML = '';
    
    // Sort groups alphabetically by value
    const groupEntries = Array.from(state.groupNames.entries()).sort((a, b) => {
        const valA = a[1] || '';
        const valB = b[1] || '';
        return valA.localeCompare(valB);
    });
    
    groupEntries.forEach(([groupId, groupValue], index) => {
        const option = document.createElement('option');
        option.value = groupId.toString();
        option.textContent = groupValue || `Group ${groupId}`;
        // Make the first group selected by default
        if (index === 0) {
            option.selected = true;
        }
        select.appendChild(option);
    });
    
    document.getElementById('subtype-overlay').style.display = 'flex';
}

function calculateFounder(sequences) {
    if (sequences.length === 0) return null;
    
    const founder = [];
    const maxLength = Math.max(...sequences.map(s => s.length));
    
    for (let pos = 0; pos < maxLength; pos++) {
        const counts = {};
        let total = 0;
        
        sequences.forEach(seq => {
            if (pos < seq.length) {
                const char = seq[pos].toUpperCase();
                // Include all characters including gaps
                counts[char] = (counts[char] || 0) + 1;
                total++;
            } else {
                // If sequence is shorter than this position, count it as a gap
                counts['-'] = (counts['-'] || 0) + 1;
                total++;
            }
        });
        
        if (total === 0) {
            founder.push('-');
        } else {
            // Find the most common character (including gaps)
            let maxCount = 0;
            let founderChar = '-';
            
            for (const [char, count] of Object.entries(counts)) {
                if (count > maxCount) {
                    maxCount = count;
                    founderChar = char;
                }
            }
            
            founder.push(founderChar);
        }
    }
    
    return founder;
}

function applySubtypeFounder() {
    const select = document.getElementById('sel-subtype-group');
    const selectedGroupId = parseInt(select.value);
    
    if (isNaN(selectedGroupId)) {
        alert("Please select a group.");
        return;
    }
    
    // Get group value for naming
    const groupValue = state.groupNames.get(selectedGroupId) || `group${selectedGroupId}`;
    
    // Find all sequences in the selected group
    const groupSequences = [];
    for (let i = 0; i < state.rawSequences.length; i++) {
        if (i === state.refIndex || i === state.subtypeIndex) continue; // Exclude REF and subtype
        
        const seq = state.rawSequences[i];
        const groupId = state.sequenceGroups.get(seq.name);
        
        if (groupId === selectedGroupId) {
            // Get the sequence array
            const seqArr = state.isAASequence ? state.viewSequences[i].seq : state.rawSequences[i].seq;
            groupSequences.push(seqArr);
        }
    }
    
    if (groupSequences.length === 0) {
        alert("No sequences found in the selected group.");
        return;
    }
    
    // Calculate founder
    const founder = calculateFounder(groupSequences);
    
    if (!founder) {
        alert("Failed to calculate founder sequence.");
        return;
    }
    
    // Save state for undo
    saveState();
    
    // Remove tree if present (user will need to infer again)
    if (state.tree) {
        state.tree = null;
        setTreeWidth(0);
        if (dom.btnHistogram) {
            dom.btnHistogram.disabled = true;
        }
        if (dom.btnMds) {
            dom.btnMds.disabled = true;
        }
        state.leafClusters = null; // Clear clusters
        updateColorLegend();
    }
    
    // Create new founder sequence
    const founderSeq = {
        name: `consensus_of_${groupValue}`,
        seq: [...founder]
    };
    
    // Check if a founder already exists and replace it, otherwise insert after subtype
    let existingFounderIndex = -1;
    for (let i = 0; i < state.rawSequences.length; i++) {
        if (state.rawSequences[i].name && state.rawSequences[i].name.startsWith('consensus_of_')) {
            existingFounderIndex = i;
            break;
        }
    }
    
    if (existingFounderIndex >= 0) {
        // Replace existing founder
        state.rawSequences[existingFounderIndex] = founderSeq;
    } else {
        // Insert after subtype (at index subtypeIndex + 1)
        const insertIndex = state.subtypeIndex + 1;
        state.rawSequences.splice(insertIndex, 0, founderSeq);
    }
    
    // Update view sequences
    state.viewSequences = [...state.rawSequences];
    
    // Recalculate names width
    calculateNamesWidth();
    
    // Close modal
    document.getElementById('subtype-overlay').style.display = 'none';
    
    // Re-render
    recalc();
}

// --- Color Legend ---
function updateColorLegend() {
    const legend = document.getElementById('color-legend');
    const groupsContent = document.getElementById('legend-groups-content');
    const clustersContent = document.getElementById('legend-clusters-content');
    const groupsSection = document.getElementById('legend-groups');
    const clustersSection = document.getElementById('legend-clusters');
    
    if (!legend || !groupsContent || !clustersContent) return;
    
    // Clear existing content
    groupsContent.innerHTML = '';
    clustersContent.innerHTML = '';
    
    let hasGroups = false;
    let hasClusters = false;
    
    // Update groups legend
    if (state.sequenceGroups && state.groupNames) {
        hasGroups = true;
        // Sort by group value alphabetically (not by group ID)
        const groupEntries = Array.from(state.groupNames.entries()).sort((a, b) => {
            const valA = a[1] || '';
            const valB = b[1] || '';
            return valA.localeCompare(valB);
        });
        
        groupEntries.forEach(([groupId, groupValue]) => {
            // Groups sorted alphabetically, use COLOR_PALETTE starting from index 1
            const color = COLOR_PALETTE[(groupId + 1) % COLOR_PALETTE.length];
            const item = document.createElement('div');
            item.style.display = 'flex';
            item.style.alignItems = 'center';
            item.style.gap = '8px';
            item.style.marginBottom = '4px';
            
            const colorBox = document.createElement('div');
            colorBox.style.width = '16px';
            colorBox.style.height = '16px';
            colorBox.style.backgroundColor = color;
            colorBox.style.border = '1px solid #d1d5db';
            colorBox.style.borderRadius = '3px';
            
            const label = document.createElement('span');
            label.textContent = groupValue || `Group ${groupId}`;
            label.style.color = '#374151';
            
            item.appendChild(colorBox);
            item.appendChild(label);
            groupsContent.appendChild(item);
        });
    }
    
    // Update clusters legend
    if (state.leafClusters) {
        const clusterIds = new Set();
        state.leafClusters.forEach(clusterId => {
            if (clusterId !== -1) {
                clusterIds.add(clusterId);
            }
        });
        
        if (clusterIds.size > 0) {
            hasClusters = true;
            const sortedClusterIds = Array.from(clusterIds).sort((a, b) => a - b);
            
            sortedClusterIds.forEach(clusterId => {
                const color = getClusterColor(clusterId);
                const item = document.createElement('div');
                item.style.display = 'flex';
                item.style.alignItems = 'center';
                item.style.gap = '8px';
                item.style.marginBottom = '4px';
                
                const colorBox = document.createElement('div');
                colorBox.style.width = '16px';
                colorBox.style.height = '16px';
                colorBox.style.backgroundColor = color;
                colorBox.style.border = '1px solid #d1d5db';
                colorBox.style.borderRadius = '3px';
                
                const label = document.createElement('span');
                label.textContent = `Cluster ${clusterId}`;
                label.style.color = '#374151';
                
                item.appendChild(colorBox);
                item.appendChild(label);
                clustersContent.appendChild(item);
            });
            
            // Add noise entry if present
            const hasNoise = Array.from(state.leafClusters.values()).includes(-1);
            if (hasNoise) {
                const item = document.createElement('div');
                item.style.display = 'flex';
                item.style.alignItems = 'center';
                item.style.gap = '8px';
                item.style.marginBottom = '4px';
                
                const colorBox = document.createElement('div');
                colorBox.style.width = '16px';
                colorBox.style.height = '16px';
                colorBox.style.backgroundColor = '#9ca3af';
                colorBox.style.border = '1px solid #d1d5db';
                colorBox.style.borderRadius = '3px';
                
                const label = document.createElement('span');
                label.textContent = 'Noise';
                label.style.color = '#374151';
                
                item.appendChild(colorBox);
                item.appendChild(label);
                clustersContent.appendChild(item);
            }
        }
    }
    
    // Show/hide sections and legend
    groupsSection.style.display = hasGroups ? 'block' : 'none';
    clustersSection.style.display = hasClusters ? 'block' : 'none';
    legend.style.display = (hasGroups || hasClusters) ? 'block' : 'none';
}

// --- URL Parameter Loading ---
function loadFromURLParams() {
    const params = new URLSearchParams(window.location.search);
    const alignmentURL = params.get('alignment');
    const treeURL = params.get('tree');
    
    if (alignmentURL) {
        showOverlay(true);
        dom.overlayMsg.textContent = "Loading alignment...";
        
        fetch(alignmentURL)
            .then(response => {
                if (!response.ok) throw new Error(`Failed to fetch alignment: ${response.status}`);
                return response.text();
            })
            .then(text => {
                const name = alignmentURL.toLowerCase();
                const isFastq = name.endsWith('.fastq') || name.endsWith('.fq');
                if (isFastq) parseFastq(text);
                else parseFasta(text);
                
                // After alignment loads, try to load tree if specified
                if (treeURL) {
                    loadTreeFromURL(treeURL);
                }
            })
            .catch(err => {
                console.error("Error loading alignment:", err);
                alert("Failed to load alignment from URL: " + err.message);
                showOverlay(false);
            });
    }
}

function loadTreeFromURL(url) {
    dom.overlayMsg.textContent = "Loading tree...";
    
    fetch(url)
        .then(response => {
            if (!response.ok) throw new Error(`Failed to fetch tree: ${response.status}`);
            return response.text();
        })
        .then(text => {
            parseTree(text, false, false); // Don't reroot when loading from file
        })
        .catch(err => {
            console.error("Error loading tree:", err);
            alert("Failed to load tree from URL: " + err.message);
            showOverlay(false);
        });
}

// --- Infer Tree Logic ---
function showInferModal() {
    if (!state.rawSequences || state.rawSequences.length < 2) {
        alert("Need at least 2 sequences to infer a tree.");
        return;
    }
    document.getElementById('infer-overlay').style.display = 'flex';
}

function runInferTask() {
    const method = document.getElementById('sel-infer-method').value;
    document.getElementById('infer-overlay').style.display = 'none';

    // Disable buttons that require ladderize (will be re-enabled after ladderize)
    if (dom.btnHistogram) dom.btnHistogram.disabled = true;
    if (dom.btnMds) dom.btnMds.disabled = true;
    if (dom.btnExportTree) dom.btnExportTree.disabled = true;
    // Disable reroot and ladderize buttons (will be re-enabled after inference/reroot)
    if (dom.btnRerootTree) dom.btnRerootTree.disabled = true;
    if (dom.btnLadderizeTree) dom.btnLadderizeTree.disabled = true;

    // Clear clustering state and remove cluster annotations before inferring a new tree
    if (state.leafClusters || state.hierarchicalActive) {
        const delimiter = state.groupDelimiter || '_';
        const clusterPattern = new RegExp(`${delimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}cl-(\\d+|na)$`);
        
        // Remove cluster suffixes from sequence names
        state.rawSequences.forEach(seq => {
            if (seq.name) {
                seq.name = seq.name.replace(clusterPattern, '');
            }
        });
        
        // Also remove from tree nodes if tree exists
        if (state.tree && state.tree.root) {
            function removeClusterSuffixesFromTree(node) {
                if (node.name) {
                    node.name = node.name.replace(clusterPattern, '');
                }
                if (node.children) {
                    node.children.forEach(removeClusterSuffixesFromTree);
                }
            }
            removeClusterSuffixesFromTree(state.tree.root);
        }
        
        // Clear clustering state
        state.leafClusters = null;
        state.hierarchicalActive = false;
        state.hierarchicalDepths = [0, 0, 0];
        
        // Update color legend to remove cluster colors
        updateColorLegend();
    }

    if (method === 'nj') {
        inferTreeNJ();
    } else {
        runFastTreeTask();
    }
}

function inferTreeNJ() {
    const startTime = performance.now();
    showOverlay(true);
    dom.overlayMsg.textContent = "Inferring phylogeny...";
    dom.overlaySub.textContent = "Calculating distances and building NJ tree";
    
    setTimeout(() => {
        try {
            // Exclude reference and PDB chain sequences from tree inference
            const refName = state.rawSequences[state.refIndex]?.name;
            const nonRefSequences = state.rawSequences.filter((s, idx) =>
                idx !== state.refIndex && !isPdbChainSequence(s));
            
            if (nonRefSequences.length < 2) {
                alert("Need at least 2 non-reference, non-PDB sequences to infer a tree.");
                showOverlay(false);
                return;
            }
            
            // Extract sequences (strip gaps for distance calculation)
            const labels = nonRefSequences.map(s => s.name);
            const seqs = nonRefSequences.map(s => s.seq.join(''));
            
            // Use PhyloTools to generate the Newick tree
            const newick = PhyloTools.generatePhylogeny(seqs, labels);
            
            // Parse the generated tree (don't auto-reroot)
            parseTree(newick, false, false);
            
            const endTime = performance.now();
            const executionTime = ((endTime - startTime) / 1000).toFixed(2);
            console.log(`NJ Tree Inference completed in ${executionTime} seconds`);
        } catch (err) {
            console.error("Error inferring tree:", err);
            alert("Failed to infer tree: " + err.message);
            showOverlay(false);
        }
    }, 50);
}

async function runFastTreeTask() {
    const startTime = performance.now();
    
    if (!state.aioliCLI) {
        alert("FastTree (bioWASM) is not yet initialized. Please wait or refresh.");
        return;
    }

    showOverlay(true);
    dom.overlayMsg.textContent = "Inferring phylogeny with FastTree...";
    dom.overlaySub.textContent = "via bioWASM";

    try {
        // Exclude reference and PDB chain sequences from tree inference
        const nonRefSequences = state.rawSequences.filter((s, idx) =>
            idx !== state.refIndex && !isPdbChainSequence(s));
        
        if (nonRefSequences.length < 2) {
            alert("Need at least 2 non-reference, non-PDB sequences to infer a tree.");
            showOverlay(false);
            return;
        }
        
        // Use indices as temporary names (excluding ref and PDB chains)
        const indexMap = new Map();
        let newIdx = 0;
        state.rawSequences.forEach((s, origIdx) => {
            if (origIdx !== state.refIndex && !isPdbChainSequence(s)) {
                indexMap.set(newIdx, origIdx);
                newIdx++;
            }
        });
        
        const fastaInput = nonRefSequences.map((s, idx) => {
            return `>${idx}\n${s.seq.join('')}`;
        }).join('\n');
        
        await state.aioliCLI.mount({
            name: "input_tree.fa",
            data: fastaInput
        });

        const isAA = (state.mode === 'AA');
        
        // Build flags array to ensure proper spacing
        const flagArray = [];
        
        // Suppress support values to avoid confusion with sequence indices
        flagArray.push("-nosupport");
        
        if (!isAA) {
            flagArray.push("-nt");
        }
        
        const aaModel = document.getElementById('sel-ft-aa-model').value;
        const ntModel = document.getElementById('sel-ft-nt-model').value;
        const speed = document.getElementById('sel-ft-speed').value;
        
        // Only add model flags if they have values and are not empty strings
        if (isAA && aaModel && aaModel.trim() !== '') {
            flagArray.push(aaModel.trim());
        } else if (!isAA && ntModel && ntModel.trim() !== '') {
            flagArray.push(ntModel.trim());
        }
        
        // Only add speed flag if it has a value and is not empty string
        if (speed && speed.trim() !== '') {
            flagArray.push(speed.trim());
        }
        
        const trimmedFlags = flagArray.join(" ");

        const command = `fasttree ${trimmedFlags} input_tree.fa`;
        
        // Log FastTree parameters
        console.log("=== FastTree Parameters ===");
        console.log(`Sequences: ${nonRefSequences.length} (reference sequence excluded)`);
        console.log(`Mode: ${isAA ? 'AA' : 'NT'}`);
        console.log(`AA Model: ${aaModel || 'Default (JTT)'}`);
        console.log(`NT Model: ${ntModel || 'Default (Jukes-Cantor)'}`);
        console.log(`Speed: ${speed || 'Default'}`);
        console.log(`Flags: ${trimmedFlags || '(none)'}`);
        console.log(`Full Command: ${command}`);
        console.log(`Flag Array: [${flagArray.join(', ')}]`);
        console.log("===========================");
        
        const output = await state.aioliCLI.exec(command);
        
        // FastTree outputs multiple lines - extract the Newick string (usually the last line with parentheses)
        const lines = output.split(/\r?\n/);
        let newick = null;
        for (let i = lines.length - 1; i >= 0; i--) {
            const line = lines[i].trim();
            if (line.includes('(') && line.includes(')')) {
                newick = line;
                break;
            }
        }
        
        // Check if FastTree showed help (indicates command error)
        if (output.includes("FastTree accepts alignments") || output.includes("Common options")) {
            console.error("ERROR: FastTree showed help message instead of running. Command may be invalid.");
            console.error("This usually means FastTree didn't recognize the command syntax.");
        }
        
        if (newick && newick.includes('(')) {
            // Remove trailing semicolon if present
            if (newick.endsWith(';')) {
                newick = newick.slice(0, -1);
            }
            // Map back to original sequence names (excluding ref)
            state.tempNameMap = nonRefSequences.map(s => s.name);
            parseTree(newick, true, false); // isIndexed=true, shouldReroot=false
            
            const endTime = performance.now();
            const executionTime = ((endTime - startTime) / 1000).toFixed(2);
            console.log(`FastTree Inference completed in ${executionTime} seconds`);
        } else {
            throw new Error("Invalid Newick output from FastTree.");
        }
    } catch (err) {
        console.error("FastTree error:", err);
        alert("FastTree failed: " + err.message);
        showOverlay(false);
    }
}

// --- Export Tree as Newick ---
function exportTree() {
    if (!state.tree || !state.tree.root) {
        alert("No tree to export. Load or infer a tree first.");
        return;
    }
    
    const newick = treeToNewick(state.tree.root) + ';';
    
    // Download as file
    const blob = new Blob([newick], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "tree.nwk";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// --- Convert tree structure back to Newick format ---
function treeToNewick(node) {
    if (!node.children || node.children.length === 0) {
        // Leaf node
        const name = node.name || '';
        const len = (node.len !== undefined && node.len !== 0) ? `:${node.len.toFixed(5)}` : '';
        return name + len;
    } else {
        // Internal node
        const childStrs = node.children.map(c => treeToNewick(c));
        const name = node.name || '';
        const len = (node.len !== undefined && node.len !== 0) ? `:${node.len.toFixed(5)}` : '';
        return `(${childStrs.join(',')})${name}${len}`;
    }
}

function parseFastq(text) {
    const lines = text.split(/\r?\n/);
    const seqs = [];
    for(let i=0; i<lines.length; i++) {
        const line = lines[i].trim();
        if(!line) continue;
        if(line.startsWith('@')) {
            const name = line.substring(1); 
            if(i + 1 < lines.length) {
                const seqStr = lines[i+1].trim().toUpperCase().replace(/[^A-Z-]/g, '');
                seqs.push({ name: name, seq: seqStr.split('') });
                i += 3; 
            }
        }
    }
    finalizeLoad(seqs);
}

function parseFasta(text) {
    const lines = text.split(/\r?\n/);
    const seqs = [];
    let name = null, buf = [];
    for(let line of lines) {
        line = line.trim();
        if(!line) continue;
        if(line.startsWith('>')) {
            if(name) seqs.push({name, seq: buf.join('').split('')});
            name = line.substring(1).trim();
            buf = [];
        } else {
            buf.push(line.toUpperCase().replace(/[^A-Z-]/g, ''));
        }
    }
    if(name) seqs.push({name, seq: buf.join('').split('')});
    
    // Validate that all sequences are the same length (alignment check)
    if(seqs.length > 1) {
        const firstLength = seqs[0].seq.length;
        for(let i = 1; i < seqs.length; i++) {
            if(seqs[i].seq.length !== firstLength) {
                alert(`Error: Sequences are not aligned. Sequence "${seqs[0].name}" has length ${firstLength}, but sequence "${seqs[i].name}" has length ${seqs[i].seq.length}. All sequences must be the same length.`);
                showOverlay(false);
                return;
            }
        }
    }
    
    finalizeLoad(seqs);
}

function detectSequenceType(seqs) {
    if (!seqs || seqs.length === 0) return 'NT'; // Default to NT if no sequences
    
    // Get all unique characters from all sequences (excluding gaps)
    const allChars = new Set();
    seqs.forEach(s => {
        if (s.seq) {
            s.seq.forEach(char => {
                if (char !== '-' && char !== 'N' && char !== 'X') {
                    allChars.add(char.toUpperCase());
                }
            });
        }
    });
    
    // Amino acid specific characters (not in standard nucleotide alphabet)
    // Standard nucleotides: A, C, G, T, U
    // IUPAC nucleotides: R, Y, M, K, S, W, B, D, H, V, N
    // Amino acids have: E, F, I, L, P, Q, W, Y (some overlap with IUPAC, but W and Y are in both)
    // Clear AA-only: E, F, I, L, P, Q
    const aaOnlyChars = new Set(['E', 'F', 'I', 'L', 'P', 'Q']);
    
    // Check if we have any AA-only characters
    let hasAAOnly = false;
    for (const char of allChars) {
        if (aaOnlyChars.has(char)) {
            hasAAOnly = true;
            break;
        }
    }
    
    // Also check for common AA characters that might indicate AA alignment
    // If we have many characters that are in AA color map but not typical nucleotides
    const aaChars = new Set(['A', 'R', 'N', 'D', 'C', 'Q', 'E', 'G', 'H', 'I', 'L', 'K', 'M', 'F', 'P', 'S', 'T', 'W', 'Y', 'V', '*']);
    const ntChars = new Set(['A', 'C', 'G', 'T', 'U', 'R', 'Y', 'M', 'K', 'S', 'W', 'B', 'D', 'H', 'V', 'N']);
    
    let aaCharCount = 0;
    let ntCharCount = 0;
    for (const char of allChars) {
        if (aaChars.has(char)) aaCharCount++;
        if (ntChars.has(char)) ntCharCount++;
    }
    
    // If we have AA-only characters, definitely AA
    if (hasAAOnly) {
        return 'AA';
    }
    
    // If we have characters that are AA but not NT, likely AA
    // But be conservative - if it could be NT, assume NT
    // Only return AA if we're very confident
    
    // For now, if we have AA-only chars, return AA, otherwise NT
    return hasAAOnly ? 'AA' : 'NT';
}

function finalizeLoad(seqs) {
    state.rawSequences = seqs;
    state.selection = null;
    state.history = [];
    state.tree = null;
    state.refIndex = 0; 
    state.subtypeIndex = (seqs.length > 1) ? 1 : 0; // Second sequence is subtype, or first if only one sequence
    
    // Store original subtype
    if (state.subtypeIndex >= 0 && state.subtypeIndex < seqs.length) {
        state.originalSubtype = JSON.parse(JSON.stringify(seqs[state.subtypeIndex]));
    }
    
    state.pastedNameCounter = state.rawSequences.length + 1;
    
    // Detect sequence type and set mode accordingly
    const detectedType = detectSequenceType(seqs);
    if (detectedType === 'AA') {
        // If AA detected, set to AA mode and disable NT button
        state.isAASequence = true; // Mark that sequences are already AA
        setMode('AA', true); // Pass flag to disable NT
    } else {
        // Default to NT mode
        state.isAASequence = false; // Sequences are DNA
        setMode('NT', false);
    }
    
    // Enable buttons that become usable after a file is loaded
    enableButtonsAfterLoad();
    
    // Calculate and set names panel width to accommodate all names
    calculateNamesWidth();
    
    setTreeWidth(0);
    recalc();
    showOverlay(false);
}

// --- Tree Rerooting ---
function showRerootModal() {
    if (!state.tree || !state.tree.root) {
        alert("Please load or infer a tree first.");
        return;
    }
    
    // Check if subtype exists
    const hasSubtype = state.subtypeIndex < state.rawSequences.length;
    
    // Check if founder exists
    let hasFounder = false;
    for (let i = 0; i < state.rawSequences.length; i++) {
        if (state.rawSequences[i].name && state.rawSequences[i].name.startsWith('consensus_of_')) {
            hasFounder = true;
            break;
        }
    }
    
    const select = document.getElementById('sel-reroot-target');
    select.innerHTML = '';
    
    // Add founder first (default selection)
    if (hasFounder) {
        const option = document.createElement('option');
        option.value = 'founder';
        option.textContent = '[Founder]';
        option.selected = true; // Make founder the default
        select.appendChild(option);
    }
    
    // Add subtype second
    if (hasSubtype) {
        const option = document.createElement('option');
        option.value = 'subtype';
        option.textContent = '[SUBTYPE]';
        select.appendChild(option);
    }
    
    if (!hasSubtype && !hasFounder) {
        alert("No subtype or founder sequence found. Please add a founder sequence or ensure the subtype is present.");
        return;
    }
    
    document.getElementById('reroot-overlay').style.display = 'flex';
}

function runRerootTask() {
    const target = document.getElementById('sel-reroot-target').value;
    document.getElementById('reroot-overlay').style.display = 'none';
    
    if (target === 'subtype') {
        rerootTreeOnTarget('subtype');
    } else if (target === 'founder') {
        rerootTreeOnTarget('founder');
    }
}

function rerootTreeOnTarget(targetType) {
    if (!state.tree || !state.tree.root) {
        alert("Please load or infer a tree first.");
        return;
    }
    
    let targetName;
    let targetIndex;
    
    if (targetType === 'subtype') {
        if (state.subtypeIndex >= state.rawSequences.length) {
            alert("No subtype sequence found. Subtype should be the second sequence in the alignment.");
            return;
        }
        targetIndex = state.subtypeIndex;
        targetName = state.rawSequences[targetIndex].name;
    } else if (targetType === 'founder') {
        // Find founder sequence
        targetIndex = -1;
        for (let i = 0; i < state.rawSequences.length; i++) {
            if (state.rawSequences[i].name && state.rawSequences[i].name.startsWith('consensus_of_')) {
                targetIndex = i;
                targetName = state.rawSequences[i].name;
                break;
            }
        }
        if (targetIndex === -1) {
            alert("No founder sequence found.");
            return;
        }
    } else {
        alert("Invalid target type.");
        return;
    }
    saveState();
    
    // Find the subtype node first - prefer leaf nodes (actual sequences) over internal nodes with same name
    // Collect all nodes with matching name, then return the leaf one
    function findAllNodes(node, name, depth = 0, results = []) {
        if (node.name === name) {
            const isLeaf = !node.children || node.children.length === 0;
            results.push({ node, depth, isLeaf });
        }
        for (const child of node.children) {
            findAllNodes(child, name, depth + 1, results);
        }
        return results;
    }
    
    const allTargetNodes = findAllNodes(state.tree.root, targetName);
    
    // Prefer the leaf node (actual sequence)
    const leafTarget = allTargetNodes.find(r => r.isLeaf);
    const targetResult = leafTarget || allTargetNodes[0];
    
    if (!targetResult) {
        const targetLabel = targetType === 'subtype' ? 'Subtype' : 'Founder';
        alert(`${targetLabel} sequence "${targetName}" not found in tree.`);
        return;
    }
    
    const targetNode = targetResult.node;
    const targetDepth = targetResult.depth;
    const isLeaf = targetResult.isLeaf;
    
    if (!isLeaf) {
        const targetLabel = targetType === 'subtype' ? 'Subtype' : 'Founder';
        console.warn(`WARNING: ${targetLabel} "${targetName}" is an internal node, not a leaf! This may cause issues.`);
        console.warn(`${targetLabel} node children: ${targetNode.children.map(c => `${c.name || '(unnamed)'}`).join(', ')}`);
    }
    
    // Find the actual parent by traversing the tree structure (don't trust parent reference)
    function findActualParent(node, target, currentParent = null, depth = 0) {
        if (node === target) {
            return { parent: currentParent, depth };
        }
        for (const child of node.children) {
            const found = findActualParent(child, target, node, depth + 1);
            if (found !== null) return found;
        }
        return null;
    }
    
    const actualParentResult = findActualParent(state.tree.root, targetNode);
    if (!actualParentResult) {
        const targetLabel = targetType === 'subtype' ? 'Subtype' : 'Founder';
        console.error(`ERROR: Could not find actual parent of ${targetLabel.toLowerCase()} by tree traversal!`);
        alert(`Could not determine ${targetLabel.toLowerCase()}'s parent in tree structure.`);
        return;
    }
    
    const actualParent = actualParentResult.parent;
    const parentDepth = actualParentResult.depth;
    
    if (actualParent) {
        // Update parent reference to match actual structure
        if (targetNode.parent !== actualParent) {
            targetNode.parent = actualParent;
        }
    }
    
    // Check if target is actually in root's children
    const targetInRoot = state.tree.root.children.some(c => c === targetNode);
    
    if (targetInRoot) {
        // Target is a direct child of root - just adjust branch lengths, no rerooting needed
        const targetBranchLength = targetNode.len || 0;
        const otherChildren = state.tree.root.children.filter(c => c !== targetNode);
        
        if (otherChildren.length > 0 && targetBranchLength > 0) {
            // Distribute 1% of target's branch length evenly among other children
            const lengthToDistribute = targetBranchLength * 0.01;
            const lengthPerChild = lengthToDistribute / otherChildren.length;
            otherChildren.forEach(child => {
                child.len = (child.len || 0) + lengthPerChild;
            });
        }
        
        // Set target's branch length to 0
        targetNode.len = 0;
        
        // Recalculate tree layout
        let totalLen = 0;
        function checkLen(n) { totalLen += (n.len || 0); n.children.forEach(checkLen); }
        checkLen(state.tree.root);
        
        const useCladogram = (totalLen === 0);
        let maxDepth = 0;
        
        function layoutX(node, currentDepth) {
            let dist = useCladogram ? (node === state.tree.root ? 0 : 1) : (node.len || 0);
            node.xDepth = currentDepth + dist;
            if(node.xDepth > maxDepth) maxDepth = node.xDepth;
            node.children.forEach(c => layoutX(c, node.xDepth));
        }
        
        layoutX(state.tree.root, 0);
        state.tree.maxDepth = maxDepth;
        state.tree.useCladogram = useCladogram;
        
        // Enable Ladderize button after successful rerooting (even if just adjusting branch lengths)
        enableButtonsAfterReroot();
        
        recalc();
        return; // Exit early since we've handled this case
    }
    
    // Reroot on the parent of the subtype node (avoid rerooting on a leaf)
    if (!actualParent || actualParent === state.tree.root) {
        // If actual parent is root, we can't reroot on it
        // Just adjust branch lengths
    }
    
    const parentNode = actualParent;
    const parentName = parentNode.name || '(unnamed internal node)';
    
    let newRoot;
    
    // If parent is already the root, we can't reroot on it (would do nothing)
    if (parentNode === state.tree.root) {
        newRoot = state.tree.root;
    } else {
        // Reroot directly on the parent node object (not by name, since it may be unnamed)
        try {
            newRoot = rerootTree(state.tree.root, parentNode, targetType);
            state.tree.root = newRoot;
        } catch (error) {
            console.error(`ERROR in rerootTree:`, error);
            alert(`Error during rerooting: ${error.message}`);
            return;
        }
    }
    
    // Recalculate tree layout
    let totalLen = 0;
    function checkLen(n) { totalLen += (n.len || 0); n.children.forEach(checkLen); }
    checkLen(newRoot);
    
    const useCladogram = (totalLen === 0);
    let maxDepth = 0;
    
    function layoutX(node, currentDepth) {
        let dist = useCladogram ? (node === newRoot ? 0 : 1) : (node.len || 0);
        node.xDepth = currentDepth + dist;
        if(node.xDepth > maxDepth) maxDepth = node.xDepth;
        node.children.forEach(c => layoutX(c, node.xDepth));
    }
    
    layoutX(newRoot, 0);
    state.tree.maxDepth = maxDepth;
    state.tree.useCladogram = useCladogram;
    
    // Adjust branch lengths: find target and if it's a direct child of new root,
    // set its branch length to 0 and distribute 1% of its length to other children
    function findTargetNodeInTree(node) {
        if (node.name === targetName && (!node.children || node.children.length === 0)) {
            return node; // Found leaf node with target name
        }
        for (const child of node.children) {
            const found = findTargetNodeInTree(child);
            if (found) return found;
        }
        return null;
    }
    
    const targetNodeAfterReroot = findTargetNodeInTree(newRoot);
    if (targetNodeAfterReroot && targetNodeAfterReroot.parent === newRoot) {
        const targetBranchLength = targetNodeAfterReroot.len || 0;
        const otherChildren = newRoot.children.filter(c => c !== targetNodeAfterReroot);
        
        if (otherChildren.length > 0 && targetBranchLength > 0) {
            // Distribute 1% of target's branch length evenly among other children
            const lengthToDistribute = targetBranchLength * 0.01;
            const lengthPerChild = lengthToDistribute / otherChildren.length;
            otherChildren.forEach(child => {
                child.len = (child.len || 0) + lengthPerChild;
            });
        }
        
        // Set target's branch length to 0
        targetNodeAfterReroot.len = 0;
        
        // Recalculate layout again after branch length adjustment
        totalLen = 0;
        checkLen(newRoot);
        const useCladogram2 = (totalLen === 0);
        maxDepth = 0;
        layoutX(newRoot, 0);
        state.tree.maxDepth = maxDepth;
        state.tree.useCladogram = useCladogram2;
    }
    
    // Enable Ladderize button after successful rerooting
    enableButtonsAfterReroot();
    
    recalc();
}

function rerootTree(root, targetNode, targetType = 'subtype') {
    // If targetNode is a string (name), find the node first
    if (typeof targetNode === 'string') {
        function findNode(node, name) {
            if (node.name === name) {
                return node;
            }
            for (const child of node.children) {
                const found = findNode(child, name);
                if (found) return found;
            }
            return null;
        }
        const foundNode = findNode(root, targetNode);
        if (!foundNode) {
            console.warn(`Node "${targetNode}" not found in tree. Tree not rerooted.`);
            return root;
        }
        targetNode = foundNode;
    }
    
    // If target is already the root, no need to reroot
    if (targetNode === root) {
        return root;
    }
    
    // Ensure parent references are set correctly by traversing the tree
    function setParentReferences(node, parent = null) {
        node.parent = parent;
        if (node.children) {
            for (const child of node.children) {
                setParentReferences(child, node);
            }
        }
    }
    setParentReferences(root, null);
    
    // Build path from target to root using tree traversal (more reliable than parent chain)
    function findPathToRoot(target, rootNode) {
        // First, find the path by traversing from root to target
        function findPathFromRoot(node, targetNode, currentPath = []) {
            if (node === targetNode) {
                return [...currentPath, node];
            }
            if (node.children) {
                for (const child of node.children) {
                    const result = findPathFromRoot(child, targetNode, [...currentPath, node]);
                    if (result) {
                        return result;
                    }
                }
            }
            return null;
        }
        
        const pathFromRoot = findPathFromRoot(rootNode, target);
        if (!pathFromRoot) {
            console.error(`ERROR: Could not find path from root to target node: ${target.name || '(unnamed)'}`);
            return null;
        }
        
        // Reverse the path to get path from target to root
        return pathFromRoot.reverse();
    }
    
    const path = findPathToRoot(targetNode, root);
    if (!path) {
        return root; // Can't reroot if path not found
    }
    
    // Verify path is valid (target should be first, root should be last)
    if (path[0] !== targetNode || path[path.length - 1] !== root) {
        console.error(`ERROR: Invalid path structure! Path length: ${path.length}`);
        return root;
    }
    
    // Reverse the path to reroot, preserving branch lengths and all connections
    // We need to reverse each edge in the path while preserving all other children
    // Process from target (path[0]) to root (path[path.length-1])
    for (let i = 0; i < path.length - 1; i++) {
        const node = path[i];        // Current node in path
        const parent = path[i + 1]; // Parent of current node
        
        // Store the branch length from node to parent
        const branchLength = node.len || 0;
        
        // Remove node from parent's children array (if it's there)
        if (parent.children) {
        const parentChildIndex = parent.children.indexOf(node);
        if (parentChildIndex !== -1) {
            parent.children.splice(parentChildIndex, 1);
            }
        }
        
        // Initialize node.children if it doesn't exist (for leaf nodes)
        if (!node.children) {
            node.children = [];
        }
        
        // Add parent to node's children (this reverses the edge)
        // But only if parent is not already a child (avoid duplicates)
        if (!node.children.includes(parent)) {
            node.children.push(parent);
        }
        
        // Update branch lengths
        parent.len = branchLength; // The branch from node to parent becomes parent's length
        if (i === 0) {
            node.len = 0; // The new root has no branch length
        }
    }
    
    // Now update all parent references in one pass
    // The new root (targetNode) has no parent
    targetNode.parent = null;
    
    // For each node in the path (except the first which is the new root),
    // set its parent to be the previous node in the path
    for (let i = 1; i < path.length; i++) {
        const node = path[i];
        const newParent = path[i - 1];
        node.parent = newParent;
    }
    
    // Rebuild parent references for the entire tree to ensure consistency
    function rebuildAllParentReferences(node, parent = null) {
        node.parent = parent;
        if (node.children) {
            for (const child of node.children) {
                rebuildAllParentReferences(child, node);
            }
        }
    }
    rebuildAllParentReferences(targetNode, null);
    
    // Verify tree structure after rerooting (simplified - just check parent-child consistency)
    // Note: We don't check for cycles here as the tree structure should be valid after rerooting
    // The depth limit is just a safety check
    function verifyTreeStructure(node, depth = 0, issues = []) {
        if (depth > 1000) {
            // This is a very deep tree, but not necessarily an error
            return issues;
        }
        
        // Check parent-child consistency
        if (node.children) {
            for (const child of node.children) {
                if (child.parent !== node) {
                    issues.push(`Child "${child.name || '(unnamed)'}" parent mismatch at depth ${depth}`);
                }
                // Recursively verify child
                verifyTreeStructure(child, depth + 1, issues);
            }
        }
        
        return issues;
    }
    
    const structureIssues = verifyTreeStructure(targetNode);
    if (structureIssues.length > 0) {
        console.warn(`Tree structure issues after rerooting:`, structureIssues);
        // Don't fail - just warn, as the tree might still be usable
    }
    
    // Move root closer to subtype by adjusting branch lengths
    // Find subtype node and if it's a direct child, set its branch length to 0
    // and distribute its original length among other children
    const subtypeName = state.rawSequences[state.subtypeIndex]?.name;
    if (subtypeName) {
        function findSubtypeInTree(node, name) {
            if (node.name === name) {
                return node;
            }
            for (const child of node.children) {
                const found = findSubtypeInTree(child, name);
                if (found) return found;
            }
            return null;
        }
        
        const subtypeNode = findSubtypeInTree(targetNode, subtypeName);
        if (subtypeNode && subtypeNode.parent === targetNode) {
            // Subtype is a direct child of the new root
            const subtypeBranchLength = subtypeNode.len || 0;
            
            // Get all other children of the root (excluding subtype)
            const otherChildren = targetNode.children.filter(c => c !== subtypeNode);
            
            if (otherChildren.length > 0 && subtypeBranchLength > 0) {
                // Distribute 1% of subtype's branch length evenly among other children
                const lengthToDistribute = subtypeBranchLength * 0.01;
                const lengthPerChild = lengthToDistribute / otherChildren.length;
                
                otherChildren.forEach(child => {
                    const oldLength = child.len || 0;
                    child.len = oldLength + lengthPerChild;
                });
            }
            
            // Set subtype's branch length to 0 (moves it closer to root)
            subtypeNode.len = 0;
        } else if (subtypeNode) {
            // Subtype found but not a direct child of root - no adjustment needed
        } else {
            console.warn(`Subtype "${subtypeName}" not found in tree after rerooting`);
        }
    }
    
    // The target node is now the root
    return targetNode;
}

// --- Newick Parser ---
function parseTree(newick, isIndexed = false, shouldReroot = true) {
    if(!state.rawSequences.length) {
        alert("Please load sequences first.");
        showOverlay(false);
        return;
    }
    
    saveState();

    // FastTree output might contain multiple lines; the tree is usually the last line
    let lines = newick.trim().split(/\r?\n/);
    let s = lines[lines.length - 1].trim();
    if(s.endsWith(';')) s = s.slice(0, -1);

    // Remove Newick comments like [ ... ]
    s = s.replace(/\[[^\]]*\]/g, '');

    const tokens = s.split(/([(),:;])/).map(t => t.trim()).filter(t => t !== '');
    
    let stack = [];
    let root = { children: [], name: null, len: 0 };
    let current = root;

    for(let i=0; i<tokens.length; i++) {
        let t = tokens[i];
        if(t === '(') {
            let node = { children: [], name: null, len: 0, parent: current };
            current.children.push(node);
            stack.push(current);
            current = node;
        } else if (t === ',') {
            if (stack.length > 0) {
                current = stack[stack.length - 1];
            } else {
                current = root;
            }
            let node = { children: [], name: null, len: 0, parent: current };
            current.children.push(node);
            current = node;
        } else if (t === ')') {
            if (stack.length > 0) {
                current = stack.pop();
            } else {
                current = root;
            }
        } else if (t === ':') {
            i++;
            let lenStr = tokens[i];
            let val = parseFloat(lenStr);
            if(current && !isNaN(val)) {
                current.len = val;
            } else if(current) {
                // Invalid length value, default to 0
                current.len = 0;
            }
        } else {
            if (!current) continue;
            let name = t.replace(/^['"]|['"]$/g, '');
            const originalName = name;
            const isInternalNode = current.children && current.children.length > 0;
            
            // Only apply name mapping for leaf nodes (actual sequences), not internal nodes
            // Internal nodes may have support values (decimals like 0.796) which should not be mapped
            if (isIndexed && state.tempNameMap && !isInternalNode) {
                // Check if the name is a valid integer (not a decimal)
                // FastTree outputs support values as decimals (e.g., 0.796) which should not be mapped
                if (/^\d+$/.test(name)) {
                const idx = parseInt(name);
                if (!isNaN(idx) && idx >= 0 && idx < state.tempNameMap.length) {
                    name = state.tempNameMap[idx];
                    }
                }
            }
            current.name = name;
            
            // Check if next token is a colon - if not, ensure branch length is 0
            // (nodes are initialized with len: 0, but explicitly set it for clarity)
            if (i + 1 < tokens.length && tokens[i + 1] !== ':') {
                current.len = 0;
            }
        }
    }
    delete state.tempNameMap;

    // If root has only one child and no name/length, that child is likely the real root
    // BUT: Don't do this for FastTree if it would make leaves direct children of root
    // (FastTree might have a different structure)
    if (root.children.length === 1 && !root.name) {
        const singleChild = root.children[0];
        // Only collapse if the single child is not a leaf (has children)
        // This prevents making leaf nodes direct children of root
        if (singleChild.children && singleChild.children.length > 0) {
            root = singleChild;
        delete root.parent;
            // Rebuild parent references after collapsing root
            function rebuildParents(node, parent = null) {
                node.parent = parent;
                if (node.children) {
                    for (const child of node.children) {
                        rebuildParents(child, node);
                    }
                }
            }
            rebuildParents(root, null);
            console.log(`Collapsed root: single child with ${singleChild.children.length} children`);
        } else {
            console.log(`Keeping root: single child is a leaf, not collapsing`);
        }
    }
    
    // Ensure all parent references are set correctly before rerooting
    function ensureParentReferences(node, parent = null) {
        node.parent = parent;
        if (node.children) {
            for (const child of node.children) {
                ensureParentReferences(child, node);
            }
        }
    }
    ensureParentReferences(root, null);

    // Reroot tree on subtype sequence if it exists and shouldReroot is true
    if (shouldReroot && state.subtypeIndex < state.rawSequences.length) {
        const subtypeName = state.rawSequences[state.subtypeIndex].name;
        root = rerootTree(root, subtypeName);
    }

    applyTreeOrder(root);
    
    let totalLen = 0;
    function checkLen(n) { totalLen += (n.len || 0); n.children.forEach(checkLen); }
    checkLen(root);

    const useCladogram = (totalLen === 0);
    let maxDepth = 0;

    function layoutX(node, currentDepth) {
        let dist = useCladogram ? (node === root ? 0 : 1) : (node.len || 0);
        node.xDepth = currentDepth + dist;
        if(node.xDepth > maxDepth) maxDepth = node.xDepth;
        node.children.forEach(c => layoutX(c, node.xDepth));
    }
    
    root.len = 0; 
    layoutX(root, 0);

    state.tree = { root, maxDepth };
    setTreeWidth(200);
    // Don't enable Histogram, Cluster, or tree export here - they require ladderize first
    
    // Enable Reroot button after successful tree inference/loading
    enableButtonsAfterInference();
    
    recalc();
    showOverlay(false);
}

function applyTreeOrder(root) {
    const leafOrder = [];
    function traverse(node) {
        if(!node.children || node.children.length === 0) {
            if(node.name) {
                leafOrder.push(node.name);
            }
        } else {
            node.children.forEach(traverse);
        }
    }
    traverse(root);

    // Keep reference sequence separate - it should not be reordered or matched to tree
    const refSeq = state.rawSequences[state.refIndex];
    const refName = refSeq?.name;
    
    // Preserve subtype sequence identity by name (not index)
    const subtypeSeq = state.rawSequences[state.subtypeIndex];
    const subtypeName = subtypeSeq?.name;
    
    // Create map of non-reference sequences; collect PDB chains in order (they go right after reference)
    const seqMap = new Map();
    const pdbChainsInOrder = [];
    state.rawSequences.forEach((s, idx) => {
        if (idx === state.refIndex) return;
        if (isPdbChainSequence(s)) {
            pdbChainsInOrder.push(s);
        } else {
            seqMap.set(s.name, s);
        }
    });
    
    // Order: Reference first, then PDB chains, then tree-ordered non-PDB, then any remaining non-PDB
    const newSeqList = [];
    if (refSeq) {
        newSeqList.push(refSeq); // Reference always first
    }
    pdbChainsInOrder.forEach(s => newSeqList.push(s)); // PDB chains immediately after reference
    leafOrder.forEach(name => {
        if (name !== refName && seqMap.has(name)) {
            newSeqList.push(seqMap.get(name));
            seqMap.delete(name);
        }
    });
    // Add any remaining non-PDB sequences that weren't in the tree
    seqMap.forEach(s => newSeqList.push(s));
    
    state.rawSequences = newSeqList;
    state.refIndex = 0; // Reference is always at index 0
    
    // Update subtype index to point to the subtype sequence by name (not position)
    const newSubtypeIndex = state.rawSequences.findIndex(s => s.name === subtypeName);
    if (newSubtypeIndex !== -1) {
        state.subtypeIndex = newSubtypeIndex;
    } else {
        // Subtype not found in reordered list (shouldn't happen, but handle gracefully)
        console.warn(`Subtype sequence "${subtypeName}" not found after reordering. Keeping original index.`);
    }
}

function showLadderizeModal() {
    if (!state.tree || !state.tree.root) {
        alert("Please load or infer a tree first.");
        return;
    }
    document.getElementById('ladderize-overlay').style.display = 'flex';
}

function showHistogramModal() {
    if (!state.tree || !state.tree.root) {
        alert("Please load or infer a tree first.");
        return;
    }
    
    // Calculate root-to-leaf distances for all leaves
    const distances = [];
    
    function collectLeafDistances(node, distanceFromRoot) {
        const branchLength = node.len || 0;
        const currentDistance = distanceFromRoot + branchLength;
        
        if (!node.children || node.children.length === 0) {
            // This is a leaf node
            distances.push({
                name: node.name || 'Unnamed',
                distance: currentDistance
            });
        } else {
            // This is an internal node, recurse to children
            node.children.forEach(child => {
                collectLeafDistances(child, currentDistance);
            });
        }
    }
    
    collectLeafDistances(state.tree.root, 0);
    
    // Draw histogram
    drawHistogram(distances);
    
    document.getElementById('histogram-overlay').style.display = 'flex';
}

function drawHistogram(distances) {
    const canvas = document.getElementById('histogram-canvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const padding = { top: 40, right: 40, bottom: 60, left: 60 };
    const plotWidth = width - padding.left - padding.right;
    const plotHeight = height - padding.top - padding.bottom;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    if (distances.length === 0) {
        ctx.fillStyle = '#374151';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No leaf nodes found', width / 2, height / 2);
        return;
    }
    
    // Calculate bin statistics
    const minDist = Math.min(...distances.map(d => d.distance));
    const maxDist = Math.max(...distances.map(d => d.distance));
    const range = maxDist - minDist;
    
    // Use a reasonable number of bins (between 10 and 30)
    const numBins = Math.min(30, Math.max(10, Math.ceil(Math.sqrt(distances.length))));
    const binWidth = range / numBins;
    
    // Create bins
    const bins = new Array(numBins).fill(0);
    const binLabels = [];
    
    for (let i = 0; i < numBins; i++) {
        binLabels.push(minDist + (i + 0.5) * binWidth);
    }
    
    // Count distances in each bin
    distances.forEach(d => {
        let binIndex = Math.floor((d.distance - minDist) / binWidth);
        if (binIndex >= numBins) binIndex = numBins - 1;
        if (binIndex < 0) binIndex = 0;
        bins[binIndex]++;
    });
    
    const maxCount = Math.max(...bins);
    
    // Draw axes
    ctx.strokeStyle = '#374151';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding.left, padding.top);
    ctx.lineTo(padding.left, padding.top + plotHeight);
    ctx.lineTo(padding.left + plotWidth, padding.top + plotHeight);
    ctx.stroke();
    
    // Draw histogram bars
    const barWidth = plotWidth / numBins;
    ctx.fillStyle = '#3b82f6';
    
    bins.forEach((count, i) => {
        const barHeight = (count / maxCount) * plotHeight;
        const x = padding.left + i * barWidth;
        const y = padding.top + plotHeight - barHeight;
        
        ctx.fillRect(x, y, barWidth - 1, barHeight);
    });
    
    // Draw axis labels
    ctx.fillStyle = '#374151';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'center';
    
    // X-axis labels (show a few key values)
    const numXLabels = 5;
    for (let i = 0; i <= numXLabels; i++) {
        const value = minDist + (i / numXLabels) * range;
        const x = padding.left + (i / numXLabels) * plotWidth;
        ctx.fillText(value.toFixed(3), x, padding.top + plotHeight + 20);
    }
    
    // Y-axis labels
    ctx.textAlign = 'right';
    const numYLabels = 5;
    for (let i = 0; i <= numYLabels; i++) {
        const value = Math.round((i / numYLabels) * maxCount);
        const y = padding.top + plotHeight - (i / numYLabels) * plotHeight;
        ctx.fillText(value.toString(), padding.left - 10, y + 4);
    }
    
    // Draw axis labels
    ctx.fillStyle = '#111827';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    
    // Y-axis label (on the left, rotated vertically)
    ctx.save();
    ctx.translate(padding.left / 2, padding.top + plotHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('frequency', 0, 0);
    ctx.restore();
    
    // X-axis label (at the bottom, horizontal)
    ctx.fillText('root to leaf distance', padding.left + plotWidth / 2, padding.top + plotHeight + 50);
    
    // Draw statistics
    const mean = distances.reduce((sum, d) => sum + d.distance, 0) / distances.length;
    const variance = distances.reduce((sum, d) => sum + Math.pow(d.distance - mean, 2), 0) / distances.length;
    const stdDev = Math.sqrt(variance);
    
    ctx.fillStyle = '#6b7280';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`Count: ${distances.length}`, padding.left, padding.top - 20);
    ctx.fillText(`Mean: ${mean.toFixed(4)}`, padding.left, padding.top - 8);
    ctx.fillText(`Std Dev: ${stdDev.toFixed(4)}`, padding.left + 120, padding.top - 8);
    ctx.fillText(`Min: ${minDist.toFixed(4)}`, padding.left + 240, padding.top - 8);
    ctx.fillText(`Max: ${maxDist.toFixed(4)}`, padding.left + 320, padding.top - 8);
}

function showMdsModal() {
    if (!state.tree || !state.tree.root) {
        alert("Please load or infer a tree first.");
        return;
    }
    
    // Collect all leaf nodes
    const leaves = [];
    function collectLeaves(node) {
        if (!node.children || node.children.length === 0) {
            leaves.push(node);
        } else {
            node.children.forEach(child => collectLeaves(child));
        }
    }
    collectLeaves(state.tree.root);
    
    if (leaves.length < 2) {
        alert("Need at least 2 leaves to create a projection.");
        return;
    }
    
    // Get subtype name
    const subtypeName = (state.subtypeIndex >= 0 && state.subtypeIndex < state.rawSequences.length) 
        ? state.rawSequences[state.subtypeIndex].name 
        : null;
    
    // Calculate pairwise distance matrix
    const n = leaves.length;
    const distanceMatrix = [];
    
    // Build a map of all nodes to their distance from root
    const nodeToRootDistance = new Map();
    function calculateRootDistances(node, distanceFromRoot) {
        const currentDistance = distanceFromRoot + (node.len || 0);
        nodeToRootDistance.set(node, currentDistance);
        if (node.children) {
            node.children.forEach(child => calculateRootDistances(child, currentDistance));
        }
    }
    calculateRootDistances(state.tree.root, 0);
    
    // Find lowest common ancestor (LCA) of two nodes
    function findLCA(node1, node2) {
        // Get all ancestors of node1
        const ancestors1 = new Set();
        let current = node1;
        while (current) {
            ancestors1.add(current);
            current = current.parent;
        }
        
        // Find first common ancestor by walking up from node2
        current = node2;
        while (current) {
            if (ancestors1.has(current)) {
                return current;
            }
            current = current.parent;
        }
        
        return state.tree.root; // Fallback to root
    }
    
    function calculateDistance(node1, node2) {
        if (node1 === node2) return 0;
        
        const lca = findLCA(node1, node2);
        const dist1 = nodeToRootDistance.get(node1) || 0;
        const dist2 = nodeToRootDistance.get(node2) || 0;
        const distLCA = nodeToRootDistance.get(lca) || 0;
        
        // Distance = (dist1 - distLCA) + (dist2 - distLCA)
        return (dist1 - distLCA) + (dist2 - distLCA);
    }
    
    // Build distance matrix
    for (let i = 0; i < n; i++) {
        distanceMatrix[i] = [];
        for (let j = 0; j < n; j++) {
            if (i === j) {
                distanceMatrix[i][j] = 0;
            } else {
                distanceMatrix[i][j] = calculateDistance(leaves[i], leaves[j]);
            }
        }
    }
    
    // Store data for use after method selection
    window.mdsModalData = { leaves, distanceMatrix, subtypeName };
    
    // Show method selection popup
    document.getElementById('method-select-overlay').style.display = 'flex';
}

function showProjectionPlot(selectedMethod) {
    // Get stored data
    const { leaves, distanceMatrix, subtypeName } = window.mdsModalData;
    if (!leaves || !distanceMatrix) {
        alert("Error: Projection data not available.");
        return;
    }
    
    // Show/hide UMAP parameters based on selected method
    const umapParamsContainer = document.getElementById('umap-params-container');
    if (umapParamsContainer) {
        umapParamsContainer.style.display = selectedMethod === 'umap' ? 'flex' : 'none';
    }
    
    // Function to perform projection based on selected method
    function performProjection(method, distMatrix, nNeighbors = 15, spread = 1.0, minDist = 0.1) {
        if (method === 'umap') {
            return performUMAP(distMatrix, nNeighbors, spread, minDist);
        } else {
            return performClassicalMDS(distMatrix);
        }
    }
    
    // Get UMAP parameter sliders
    const nNeighborsSlider = document.getElementById('umap-nneighbors-slider');
    const spreadSlider = document.getElementById('umap-spread-slider');
    const minDistSlider = document.getElementById('umap-mindist-slider');
    const nNeighborsValue = document.getElementById('umap-nneighbors-value');
    const spreadValue = document.getElementById('umap-spread-value');
    const minDistValue = document.getElementById('umap-mindist-value');
    
    // Calculate initial nNeighbors (clamped to 0-5 range)
    const n = distanceMatrix.length;
    const initialNNeighbors = Math.min(5, Math.max(0, Math.floor(Math.sqrt(n))));
    if (nNeighborsSlider) {
        // Keep max at 5 (slider range is 0-5)
        nNeighborsSlider.max = '5';
        nNeighborsSlider.value = initialNNeighbors.toString();
    }
    
    // Perform initial projection with selected method
    let nNeighbors = nNeighborsSlider ? parseInt(nNeighborsSlider.value) : initialNNeighbors;
    let spread = spreadSlider ? parseFloat(spreadSlider.value) : 1.0;
    let minDist = minDistSlider ? parseFloat(minDistSlider.value) : 0.1;
    let projectionCoords = performProjection(selectedMethod, distanceMatrix, nNeighbors, spread, minDist);
    
    // Calculate coordinate ranges to set appropriate slider bounds
    const xs = projectionCoords.map(c => c.x);
    const ys = projectionCoords.map(c => c.y);
    const rangeX = Math.max(...xs) - Math.min(...xs);
    const rangeY = Math.max(...ys) - Math.min(...ys);
    const minRange = Math.min(rangeX, rangeY);
    
    // Set epsilon slider step to 0.01 of the minimum range
    const epsStep = minRange * 0.01;
    const epsMin = epsStep; // Minimum should be at least one step
    // For UMAP, set max to 2x current spread value; for MDS, use 2x minimum range
    const epsMax = selectedMethod === 'umap' ? spread * 2 : minRange * 2;
    const epsDefault = minRange * 0.1; // Default to 10% of minimum range
    
    // Store data for DBSCAN updates
    window.mdsData = { leaves, coords: projectionCoords, subtypeName };
    
    // Set up sliders
    const epsSlider = document.getElementById('mds-eps-slider');
    const minPtsSlider = document.getElementById('mds-minpts-slider');
    const epsValue = document.getElementById('mds-eps-value');
    const minPtsValue = document.getElementById('mds-minpts-value');
    
    // Update epsilon slider attributes based on projection data
    epsSlider.min = epsMin.toString();
    epsSlider.max = epsMax.toString();
    epsSlider.step = epsStep.toString();
    epsSlider.value = epsDefault.toString();
    
    // Calculate decimal places for display based on step size
    // Clamp to valid range for toFixed() (0-100)
    let decimalPlaces = 2; // Default
    if (epsStep > 0 && isFinite(epsStep)) {
        const calculated = Math.max(0, -Math.floor(Math.log10(epsStep)) + 1);
        decimalPlaces = Math.min(100, Math.max(0, calculated));
    }
    
    // Store current clusters for apply button
    let currentClusters = null;
    
    // Function to recalculate projection (for UMAP parameter changes)
    const recalculateProjection = () => {
        if (selectedMethod === 'umap') {
            nNeighbors = nNeighborsSlider ? parseInt(nNeighborsSlider.value) : 15;
            spread = spreadSlider ? parseFloat(spreadSlider.value) : 1.0;
            minDist = minDistSlider ? parseFloat(minDistSlider.value) : 0.1;
            projectionCoords = performProjection(selectedMethod, distanceMatrix, nNeighbors, spread, minDist);
            
            // Update coordinate ranges for epsilon slider
            const xs = projectionCoords.map(c => c.x);
            const ys = projectionCoords.map(c => c.y);
            const rangeX = Math.max(...xs) - Math.min(...xs);
            const rangeY = Math.max(...ys) - Math.min(...ys);
            const minRange = Math.min(rangeX, rangeY);
            const epsStep = minRange * 0.01;
            const epsMin = epsStep;
            // For UMAP, set max to 2x current spread value
            const epsMax = spread * 2;
            const epsDefault = minRange * 0.1;
            
            epsSlider.min = epsMin.toString();
            epsSlider.max = epsMax.toString();
            epsSlider.step = epsStep.toString();
            if (parseFloat(epsSlider.value) > epsMax) {
                epsSlider.value = epsDefault.toString();
            }
            
            // Update stored coords
            window.mdsData.coords = projectionCoords;
        }
    };
    
    const updatePlot = () => {
        const eps = parseFloat(epsSlider.value);
        const minPts = parseInt(minPtsSlider.value);
        // Format epsilon with appropriate decimal places based on step size
        epsValue.textContent = eps.toFixed(decimalPlaces);
        minPtsValue.textContent = minPts.toString();
        
        // Find subtype index in leaves array
        let subtypeIdx = -1;
        if (subtypeName) {
            for (let i = 0; i < leaves.length; i++) {
                if (leaves[i].name === subtypeName) {
                    subtypeIdx = i;
                    break;
                }
            }
        }
        
        // Find founder index and name in leaves array
        let founderIdx = -1;
        let founderName = null;
        for (let i = 0; i < leaves.length; i++) {
            if (leaves[i].name && leaves[i].name.startsWith('consensus_of_')) {
                founderIdx = i;
                founderName = leaves[i].name;
                break;
            }
        }
        
        // Perform DBSCAN clustering (subtype will be isolated, founder can cluster naturally)
        let clusters = performDBSCAN(projectionCoords, eps, minPts, subtypeIdx, null);
        
        // Renumber clusters by distance from founder (if present) or subtype
        clusters = renumberClustersByDistanceFromSubtype(clusters, projectionCoords, subtypeIdx, leaves, subtypeName);
        
        currentClusters = clusters; // Store for apply button
        
        // Draw projection plot with clusters and epsilon circles
        drawMdsPlot(leaves, projectionCoords, subtypeName, clusters, eps, founderName);
    };
    
    epsSlider.addEventListener('input', updatePlot);
    minPtsSlider.addEventListener('input', updatePlot);
    
    // Initialize UMAP parameter display values
    if (nNeighborsValue) {
        nNeighborsValue.textContent = nNeighbors.toString();
    }
    if (spreadValue) {
        spreadValue.textContent = spread.toFixed(1);
    }
    if (minDistValue) {
        minDistValue.textContent = minDist.toFixed(2);
    }
    
    // Add event listeners for UMAP parameter sliders
    if (nNeighborsSlider && spreadSlider && minDistSlider) {
        nNeighborsSlider.addEventListener('input', () => {
            if (nNeighborsValue) {
                nNeighborsValue.textContent = nNeighborsSlider.value;
            }
            recalculateProjection();
            updatePlot();
        });
        
        spreadSlider.addEventListener('input', () => {
            if (spreadValue) {
                spreadValue.textContent = parseFloat(spreadSlider.value).toFixed(1);
            }
            recalculateProjection();
            updatePlot();
        });
        
        minDistSlider.addEventListener('input', () => {
            if (minDistValue) {
                minDistValue.textContent = parseFloat(minDistSlider.value).toFixed(2);
            }
            recalculateProjection();
            updatePlot();
        });
    }
    
    // Apply button - apply clustering to tree
    const applyBtn = document.getElementById('mds-apply-btn');
    applyBtn.addEventListener('click', () => {
        if (currentClusters === null) {
            // Perform initial clustering if not done yet
            const eps = parseFloat(epsSlider.value);
            const minPts = parseInt(minPtsSlider.value);
            
            // Find subtype index in leaves array
            let subtypeIdx = -1;
            if (subtypeName) {
                for (let i = 0; i < leaves.length; i++) {
                    if (leaves[i].name === subtypeName) {
                        subtypeIdx = i;
                        break;
                    }
                }
            }
            
            // Find founder index and name in leaves array
            let founderIdx = -1;
            let founderName = null;
            for (let i = 0; i < leaves.length; i++) {
                if (leaves[i].name && leaves[i].name.startsWith('consensus_of_')) {
                    founderIdx = i;
                    founderName = leaves[i].name;
                    break;
                }
            }
            
            let clusters = performDBSCAN(projectionCoords, eps, minPts, subtypeIdx, null);
            clusters = renumberClustersByDistanceFromSubtype(clusters, projectionCoords, subtypeIdx, leaves, subtypeName);
            currentClusters = clusters;
        }
        
        // Create mapping from leaf name to cluster ID
        // First, create a map from sequence names (without cluster suffix) to cluster IDs
        const delimiter = state.groupDelimiter || '_';
        const clusterPattern = new RegExp(`${delimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}cl-(\\d+|na)$`); // Matches _cl-<number> or _cl-na
        
        // Build map: original sequence name (without cluster suffix) -> cluster ID
        const nameToCluster = new Map();
        leaves.forEach((leaf, i) => {
            if (leaf.name) {
                // Remove any existing cluster suffix from leaf name for lookup
                const originalLeafName = leaf.name.replace(clusterPattern, '');
                nameToCluster.set(originalLeafName, currentClusters[i]);
            }
        });
        
        // Also create mapping from current leaf names to cluster IDs (for tree update)
        const leafToCluster = new Map();
        leaves.forEach((leaf, i) => {
            if (leaf.name) {
                leafToCluster.set(leaf.name, currentClusters[i]);
            }
        });
        
        // Store in state (using original names)
        state.leafClusters = nameToCluster;
        
        // Create mapping from old name to new name
        const nameMapping = new Map();
        
        // Update names in rawSequences
        state.rawSequences.forEach(seq => {
            if (seq.name) {
                // Get original name (remove any existing cluster suffix for lookup)
                const originalName = seq.name.replace(clusterPattern, '');
                const clusterId = nameToCluster.get(originalName);
                
                if (clusterId !== undefined && clusterId !== -1) {
                    // Only update if sequence is in a cluster (not noise)
                    const oldName = seq.name;
                    const newName = originalName + `${delimiter}cl-${clusterId}`;
                    seq.name = newName;
                    if (oldName !== newName) {
                        nameMapping.set(oldName, newName);
                    }
                } else if (clusterId === -1) {
                    // For noise, label with _cl-na (not assigned)
                    const oldName = seq.name;
                    const newName = originalName + `${delimiter}cl-na`;
                    seq.name = newName;
                    if (oldName !== newName) {
                        nameMapping.set(oldName, newName);
                    }
                }
            }
        });
        
        // Update tree node names to match sequence names
        if (state.tree && state.tree.root && nameMapping.size > 0) {
            function updateTreeNodeNames(node) {
                if (node.name) {
                    // Try to match by current name or by original name (without cluster suffix)
                    const originalNodeName = node.name.replace(clusterPattern, '');
                    
                    // Check if we have a mapping for this node's current name
                    if (nameMapping.has(node.name)) {
                        node.name = nameMapping.get(node.name);
                    } else {
                        // Check if any sequence was updated from this original name
                        for (const [oldName, newName] of nameMapping.entries()) {
                            const oldOriginal = oldName.replace(clusterPattern, '');
                            if (oldOriginal === originalNodeName) {
                                node.name = newName;
                                break;
                            }
                        }
                    }
                }
                if (node.children) {
                    node.children.forEach(child => updateTreeNodeNames(child));
                }
            }
            updateTreeNodeNames(state.tree.root);
        }
        
        // Update state.leafClusters to use new names (with cluster suffix)
        // Rebuild from nameToCluster using updated sequence names
        if (nameToCluster.size > 0) {
            const updatedLeafClusters = new Map();
            state.rawSequences.forEach(seq => {
                if (seq.name) {
                    const originalName = seq.name.replace(clusterPattern, '');
                    const clusterId = nameToCluster.get(originalName);
                    if (clusterId !== undefined) {
                        updatedLeafClusters.set(seq.name, clusterId);
                    }
                }
            });
            state.leafClusters = updatedLeafClusters;
        }
        
        // Update state.sequenceGroups to use new names (with cluster suffix)
        // Rebuild from original sequenceGroups using updated sequence names
        if (state.sequenceGroups && state.sequenceGroups.size > 0) {
            const updatedSequenceGroups = new Map();
            state.rawSequences.forEach(seq => {
                if (seq.name) {
                    const originalName = seq.name.replace(clusterPattern, '');
                    const groupId = state.sequenceGroups.get(originalName);
                    if (groupId !== undefined) {
                        updatedSequenceGroups.set(seq.name, groupId);
                    }
                }
            });
            state.sequenceGroups = updatedSequenceGroups;
        }
        
        // Update legend
        updateColorLegend();
        
        // Re-render tree
        recalc();
        
        // Close modal
        document.getElementById('mds-overlay').style.display = 'none';
    });
    
    // Update initial value display
    epsValue.textContent = epsDefault.toFixed(decimalPlaces);
    
    // Initial draw
    updatePlot();
    
    document.getElementById('mds-overlay').style.display = 'flex';
}

// --- Legend Dragging ---
function initLegendDragging() {
    const legend = document.getElementById('color-legend');
    const header = document.getElementById('legend-header');
    if (!legend || !header) return;
    
    let isDragging = false;
    let startX, startY, initialLeft, initialTop;
    
    header.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);
    
    function dragStart(e) {
        if (e.target.tagName === 'BUTTON') return; // Don't drag when clicking close button
        
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        
        // Get current position
        const rect = legend.getBoundingClientRect();
        initialLeft = rect.left;
        initialTop = rect.top;
        
        e.preventDefault();
    }
    
    function drag(e) {
        if (!isDragging) return;
        
        e.preventDefault();
        const deltaX = e.clientX - startX;
        const deltaY = e.clientY - startY;
        
        const newLeft = initialLeft + deltaX;
        const newTop = initialTop + deltaY;
        
        // Update position using left/top instead of transform
        legend.style.left = newLeft + 'px';
        legend.style.right = 'auto';
        legend.style.top = newTop + 'px';
    }
    
    function dragEnd(e) {
        isDragging = false;
    }
}

function performUMAP(distanceMatrix, nNeighbors = 15, spread = 1.0, minDist = 0.1) {
    // Check if UMAP is available - try different possible exports
    let UMAPClass = null;
    
    // Try different ways UMAP might be exported
    // Note: We avoid checking 'umap' directly to prevent conflicts with the local variable declared later
    if (typeof UMAP !== 'undefined') {
        UMAPClass = UMAP;
    } else if (typeof window !== 'undefined' && window.UMAP) {
        UMAPClass = window.UMAP;
    } else if (typeof window !== 'undefined' && window.umap) {
        UMAPClass = window.umap;
    } else {
        // Try to access umap via window property access to avoid variable name conflicts
        try {
            if (typeof window !== 'undefined' && 'umap' in window) {
                UMAPClass = window['umap'];
            }
        } catch (e) {
            // Ignore errors
        }
    }
    
    if (!UMAPClass) {
        console.error('UMAP library not loaded. Falling back to MDS.');
        return performClassicalMDS(distanceMatrix);
    }
    
    const n = distanceMatrix.length;
    
    if (n < 2) {
        return [{ x: 0, y: 0 }];
    }
    
    // UMAP works with feature vectors, not distance matrices directly
    // We need to convert the distance matrix to a feature space representation
    // One approach: use the distance matrix rows as feature vectors
    // Each point is represented by its distances to all other points
    
    // Create feature matrix from distance matrix
    // Each row represents a point, each column is distance to another point
    const data = [];
    for (let i = 0; i < n; i++) {
        const features = [];
        for (let j = 0; j < n; j++) {
            features.push(distanceMatrix[i][j]);
        }
        data.push(features);
    }
    
    // Create UMAP instance with appropriate parameters
    // nNeighbors is passed as a parameter to the function
    
    let umap;
    try {
        // Try different ways to instantiate UMAP
        if (typeof UMAPClass === 'function') {
            // Direct constructor
            umap = new UMAPClass({
                nNeighbors: nNeighbors,
                minDist: minDist,
                nComponents: 2,
                nEpochs: 200,
                spread: spread
            });
        } else if (UMAPClass.default && typeof UMAPClass.default === 'function') {
            // Default export
            umap = new UMAPClass.default({
                nNeighbors: nNeighbors,
                minDist: minDist,
                nComponents: 2,
                nEpochs: 200,
                spread: spread
            });
        } else if (UMAPClass.UMAP && typeof UMAPClass.UMAP === 'function') {
            // Namespace export
            umap = new UMAPClass.UMAP({
                nNeighbors: nNeighbors,
                minDist: minDist,
                nComponents: 2,
                nEpochs: 200,
                spread: spread
            });
        } else {
            throw new Error('Cannot determine how to instantiate UMAP');
        }
        
        // Fit UMAP to the data
        umap.fit(data);
        
        // Get the embedding
        const embedding = umap.getEmbedding();
        
        // Convert to our coordinate format
        const coords = embedding.map(point => ({
            x: point[0],
            y: point[1]
        }));
        
        return coords;
    } catch (err) {
        console.error('UMAP initialization or fitting failed:', err);
        return performClassicalMDS(distanceMatrix);
    }
}

function showHierarchicalModal() {
    if (!state.tree || !state.tree.root) {
        alert("Please load or infer a tree first.");
        return;
    }
    
    // Ensure tree has depth information
    if (!state.tree.maxDepth) {
        // Recalculate tree layout if needed
        let totalLen = 0;
        function checkLen(n) { totalLen += (n.len || 0); n.children.forEach(checkLen); }
        checkLen(state.tree.root);
        const useCladogram = (totalLen === 0);
        let maxDepth = 0;
        function layoutX(node, currentDepth) {
            let dist = useCladogram ? (node === state.tree.root ? 0 : 1) : (node.len || 0);
            node.xDepth = currentDepth + dist;
            if(node.xDepth > maxDepth) maxDepth = node.xDepth;
            node.children.forEach(c => layoutX(c, node.xDepth));
        }
        layoutX(state.tree.root, 0);
        state.tree.maxDepth = maxDepth;
    }
    
    const maxDepth = state.tree.maxDepth;
    
    // Set up sliders
    const slider1 = document.getElementById('hier-slider-1');
    const slider2 = document.getElementById('hier-slider-2');
    const slider3 = document.getElementById('hier-slider-3');
    const value1 = document.getElementById('hier-value-1');
    const value2 = document.getElementById('hier-value-2');
    const value3 = document.getElementById('hier-value-3');
    
    // Set max values (allow one step past maximum depth)
    const step = 0.01;
    slider1.max = maxDepth + step;
    slider2.max = maxDepth + step;
    slider3.max = maxDepth + step;
    
    // Initialize values
    slider1.value = 0;
    slider2.value = 0;
    slider3.value = 0;
    value1.textContent = '0.00';
    value2.textContent = '0.00';
    value3.textContent = '0.00';
    
    // Function to update clustering
    function updateHierarchicalClustering() {
        const depth1 = parseFloat(slider1.value);
        const depth2 = parseFloat(slider2.value);
        const depth3 = parseFloat(slider3.value);
        
        // Store depths in state for drawing vertical lines
        state.hierarchicalDepths = [depth1, depth2, depth3];
        
        applyHierarchicalClustering(depth1, depth2, depth3);
    }
    
    // Slider event handlers with constraints
    slider1.addEventListener('input', () => {
        const val = parseFloat(slider1.value);
        value1.textContent = val.toFixed(2);
        
        // Constrain slider2 >= slider1
        if (parseFloat(slider2.value) < val) {
            slider2.value = val;
            value2.textContent = val.toFixed(2);
        }
        
        // Constrain slider3 >= slider2
        if (parseFloat(slider3.value) < parseFloat(slider2.value)) {
            slider3.value = slider2.value;
            value3.textContent = slider2.value;
        }
        
        updateHierarchicalClustering();
    });
    
    slider2.addEventListener('input', () => {
        const val = parseFloat(slider2.value);
        const val1 = parseFloat(slider1.value);
        
        // Constrain slider2 >= slider1
        if (val < val1) {
            slider2.value = val1;
            value2.textContent = val1.toFixed(2);
            return;
        }
        
        value2.textContent = val.toFixed(2);
        
        // Constrain slider3 >= slider2
        if (parseFloat(slider3.value) < val) {
            slider3.value = val;
            value3.textContent = val.toFixed(2);
        }
        
        updateHierarchicalClustering();
    });
    
    slider3.addEventListener('input', () => {
        const val = parseFloat(slider3.value);
        const val2 = parseFloat(slider2.value);
        
        // Constrain slider3 >= slider2
        if (val < val2) {
            slider3.value = val2;
            value3.textContent = val2.toFixed(2);
            return;
        }
        
        value3.textContent = val.toFixed(2);
        updateHierarchicalClustering();
    });
    
    // Button handlers
    document.getElementById('btn-hier-cancel').onclick = () => {
        document.getElementById('hierarchical-overlay').style.display = 'none';
        state.hierarchicalActive = false;
        state.hierarchicalDepths = [0, 0, 0];
        // Restore previous clustering if any
        recalc();
    };
    
    document.getElementById('btn-hier-accept').onclick = () => {
        // Update sequence names with cluster numbers (same as MDS/UMAP)
        const delimiter = state.groupDelimiter || '_';
        const clusterPattern = new RegExp(`${delimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}cl-(\\d+|na)$`); // Matches _cl-<number> or _cl-na
        
        // Create mapping from old name to new name
        const nameMapping = new Map();
        
        // Update names in rawSequences
        state.rawSequences.forEach(seq => {
            if (seq.name) {
                // Get original name (remove any existing cluster suffix for lookup)
                const originalName = seq.name.replace(clusterPattern, '');
                const clusterId = state.leafClusters ? state.leafClusters.get(originalName) : undefined;
                
                if (clusterId !== undefined && clusterId !== -1) {
                    // Only update if sequence is in a cluster (not noise)
                    const oldName = seq.name;
                    const newName = originalName + `${delimiter}cl-${clusterId}`;
                    seq.name = newName;
                    if (oldName !== newName) {
                        nameMapping.set(oldName, newName);
                    }
                } else if (clusterId === -1) {
                    // For noise, label with _cl-na (not assigned)
                    const oldName = seq.name;
                    const newName = originalName + `${delimiter}cl-na`;
                    seq.name = newName;
                    if (oldName !== newName) {
                        nameMapping.set(oldName, newName);
                    }
                }
            }
        });
        
        // Update tree node names to match sequence names
        if (state.tree && state.tree.root && nameMapping.size > 0) {
            function updateTreeNodeNames(node) {
                if (node.name) {
                    // Try to match by current name or by original name (without cluster suffix)
                    const originalNodeName = node.name.replace(clusterPattern, '');
                    
                    // Check if we have a mapping for this node's current name
                    if (nameMapping.has(node.name)) {
                        node.name = nameMapping.get(node.name);
                    } else {
                        // Check if any sequence was updated from this original name
                        for (const [oldName, newName] of nameMapping.entries()) {
                            const oldOriginal = oldName.replace(clusterPattern, '');
                            if (oldOriginal === originalNodeName) {
                                node.name = newName;
                                break;
                            }
                        }
                    }
                }
                if (node.children) {
                    node.children.forEach(child => updateTreeNodeNames(child));
                }
            }
            updateTreeNodeNames(state.tree.root);
        }
        
        // Update state.leafClusters to use new names (with cluster suffix)
        // Rebuild from original leafClusters using updated sequence names
        if (state.leafClusters && state.leafClusters.size > 0) {
            const updatedLeafClusters = new Map();
            state.rawSequences.forEach(seq => {
                if (seq.name) {
                    const originalName = seq.name.replace(clusterPattern, '');
                    const clusterId = state.leafClusters.get(originalName);
                    if (clusterId !== undefined) {
                        updatedLeafClusters.set(seq.name, clusterId);
                    }
                }
            });
            state.leafClusters = updatedLeafClusters;
        }
        
        // Update state.sequenceGroups to use new names (with cluster suffix)
        // Rebuild from original sequenceGroups using updated sequence names
        if (state.sequenceGroups && state.sequenceGroups.size > 0) {
            const updatedSequenceGroups = new Map();
            state.rawSequences.forEach(seq => {
                if (seq.name) {
                    const originalName = seq.name.replace(clusterPattern, '');
                    const groupId = state.sequenceGroups.get(originalName);
                    if (groupId !== undefined) {
                        updatedSequenceGroups.set(seq.name, groupId);
                    }
                }
            });
            state.sequenceGroups = updatedSequenceGroups;
        }
        
        document.getElementById('hierarchical-overlay').style.display = 'none';
        state.hierarchicalActive = false;
        
        // Re-render
        recalc();
    };
    
    // Show modal and set active state
    document.getElementById('hierarchical-overlay').style.display = 'flex';
    state.hierarchicalActive = true;
    
    // Initial clustering
    updateHierarchicalClustering();
}

function applyHierarchicalClustering(depth1, depth2, depth3) {
    if (!state.tree || !state.tree.root) return;
    
    const leafToCluster = new Map();
    let clusterId = 2; // Start from 2 (cluster 0 for subtype, cluster 1 for leaves left of line)
    const assignedNodes = new Set(); // Track which nodes have had their subtrees assigned
    
    // Get subtype name (use original name without cluster suffix for comparison)
    const delimiter = state.groupDelimiter || '_';
    const clusterPattern = new RegExp(`${delimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}cl-(\\d+|na)$`);
    const subtypeNameWithSuffix = (state.subtypeIndex >= 0 && state.subtypeIndex < state.rawSequences.length) 
        ? state.rawSequences[state.subtypeIndex].name 
        : null;
    const subtypeName = subtypeNameWithSuffix ? subtypeNameWithSuffix.replace(clusterPattern, '') : null;
    
    // First, assign cluster 0 to the subtype leaf
    function assignSubtype(node) {
        if (!node.children || node.children.length === 0) {
            // This is a leaf - compare using original name (without cluster suffix)
            if (node.name) {
                const originalNodeName = node.name.replace(clusterPattern, '');
                if (originalNodeName === subtypeName) {
                    leafToCluster.set(node.name, 0);
                }
            }
        } else {
            // Internal node - recurse to children
            node.children.forEach(assignSubtype);
        }
    }
    assignSubtype(state.tree.root);
    
    // Second, assign cluster 1 to all leaves to the left of line 1 (depth < depth1)
    function assignLeavesLeftOfLine(node) {
        if (!node.children || node.children.length === 0) {
            // This is a leaf
            if (node.name) {
                const originalNodeName = node.name.replace(clusterPattern, '');
                if (originalNodeName !== subtypeName) {
                    const currentDepth = node.xDepth || 0;
                    if (currentDepth < depth1) {
                        leafToCluster.set(node.name, 1);
                    }
                }
            }
        } else {
            // Internal node - recurse to children
            node.children.forEach(assignLeavesLeftOfLine);
        }
    }
    assignLeavesLeftOfLine(state.tree.root);
    
    // Third, use BFS to find subtrees crossing line 1 and assign incremental cluster numbers
    const queue1 = [state.tree.root];
    
    while (queue1.length > 0) {
        const node = queue1.shift();
        const currentDepth = node.xDepth || 0;
        
        // Check if this node crosses line 1 (depth threshold)
        if (currentDepth > depth1 && depth1 >= 0) {
            // Check if this node or any of its ancestors has already been assigned
            // We only want to assign clusters to the first node we encounter at depth > depth1
            // in each branch
            let shouldAssign = true;
            let ancestor = node.parent;
            while (ancestor) {
                if (assignedNodes.has(ancestor)) {
                    shouldAssign = false;
                    break;
                }
                ancestor = ancestor.parent;
            }
            
            if (shouldAssign && !assignedNodes.has(node)) {
                // Assign all leaves in this node's subtree to the current cluster number
                // (but skip subtype and leaves already assigned to cluster 1)
                function assignLeavesInSubtree(subtreeNode) {
                    if (!subtreeNode.children || subtreeNode.children.length === 0) {
                        // This is a leaf
                        if (subtreeNode.name) {
                            const originalLeafName = subtreeNode.name.replace(clusterPattern, '');
                            if (originalLeafName !== subtypeName) {
                                // Only assign if not already assigned (skip cluster 1 leaves)
                                if (!leafToCluster.has(subtreeNode.name) || leafToCluster.get(subtreeNode.name) === 1) {
                                    // Check if this leaf is actually to the right of the line
                                    const leafDepth = subtreeNode.xDepth || 0;
                                    if (leafDepth >= depth1) {
                                        leafToCluster.set(subtreeNode.name, clusterId);
                                    }
                                }
                            }
                        }
                    } else {
                        // Internal node - recurse to children
                        subtreeNode.children.forEach(assignLeavesInSubtree);
                    }
                }
                
                assignLeavesInSubtree(node);
                assignedNodes.add(node);
                clusterId++;
            }
        }
        
        // Add children to queue for BFS
        if (node.children && node.children.length > 0) {
            node.children.forEach(child => {
                queue1.push(child);
            });
        }
    }
    
    // Fourth, use BFS to find subtrees crossing line 2 and assign incremental cluster numbers
    if (depth2 > depth1) {
        const queue2 = [state.tree.root];
        const assignedNodes2 = new Set(); // Track nodes assigned at line 2 level
        
        while (queue2.length > 0) {
            const node = queue2.shift();
            const currentDepth = node.xDepth || 0;
            
            // Check if this node crosses line 2 (depth threshold)
            if (currentDepth > depth2) {
                // Check if this node or any of its ancestors has already been assigned at line 2 level
                let shouldAssign = true;
                let ancestor = node.parent;
                while (ancestor) {
                    if (assignedNodes2.has(ancestor)) {
                        shouldAssign = false;
                        break;
                    }
                    ancestor = ancestor.parent;
                }
                
                if (shouldAssign && !assignedNodes2.has(node)) {
                    // Assign all leaves in this node's subtree to the current cluster number
                    // Only assign leaves that are to the right of line 2 (depth >= depth2)
                    function assignLeavesInSubtree2(subtreeNode) {
                        if (!subtreeNode.children || subtreeNode.children.length === 0) {
                            // This is a leaf
                            if (subtreeNode.name) {
                                const originalLeafName = subtreeNode.name.replace(clusterPattern, '');
                                if (originalLeafName !== subtypeName) {
                                    const leafDepth = subtreeNode.xDepth || 0;
                                    // Only assign if leaf is to the right of line 2
                                    if (leafDepth >= depth2) {
                                        leafToCluster.set(subtreeNode.name, clusterId);
                                    }
                                }
                            }
                        } else {
                            // Internal node - recurse to children
                            subtreeNode.children.forEach(assignLeavesInSubtree2);
                        }
                    }
                    
                    assignLeavesInSubtree2(node);
                    assignedNodes2.add(node);
                    clusterId++;
                }
            }
            
            // Add children to queue for BFS
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    queue2.push(child);
                });
            }
        }
    }
    
    // Fifth, use BFS to find subtrees crossing line 3 and assign incremental cluster numbers
    if (depth3 > depth2) {
        const queue3 = [state.tree.root];
        const assignedNodes3 = new Set(); // Track nodes assigned at line 3 level
        
        while (queue3.length > 0) {
            const node = queue3.shift();
            const currentDepth = node.xDepth || 0;
            
            // Check if this node crosses line 3 (depth threshold)
            if (currentDepth > depth3) {
                // Check if this node or any of its ancestors has already been assigned at line 3 level
                let shouldAssign = true;
                let ancestor = node.parent;
                while (ancestor) {
                    if (assignedNodes3.has(ancestor)) {
                        shouldAssign = false;
                        break;
                    }
                    ancestor = ancestor.parent;
                }
                
                if (shouldAssign && !assignedNodes3.has(node)) {
                    // Assign all leaves in this node's subtree to the current cluster number
                    // Only assign leaves that are to the right of line 3 (depth >= depth3)
                    function assignLeavesInSubtree3(subtreeNode) {
                        if (!subtreeNode.children || subtreeNode.children.length === 0) {
                            // This is a leaf
                            if (subtreeNode.name) {
                                const originalLeafName = subtreeNode.name.replace(clusterPattern, '');
                                if (originalLeafName !== subtypeName) {
                                    const leafDepth = subtreeNode.xDepth || 0;
                                    // Only assign if leaf is to the right of line 3
                                    if (leafDepth >= depth3) {
                                        leafToCluster.set(subtreeNode.name, clusterId);
                                    }
                                }
                            }
                        } else {
                            // Internal node - recurse to children
                            subtreeNode.children.forEach(assignLeavesInSubtree3);
                        }
                    }
                    
                    assignLeavesInSubtree3(node);
                    assignedNodes3.add(node);
                    clusterId++;
                }
            }
            
            // Add children to queue for BFS
            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    queue3.push(child);
                });
            }
        }
    }
    
    // Store in state using original names (without cluster suffix) for consistency with MDS/UMAP
    // (delimiter and clusterPattern already defined at top of function)
    const nameToCluster = new Map();
    
    // Convert leafToCluster (which uses current names) to nameToCluster (using original names)
    for (const [leafName, clusterId] of leafToCluster.entries()) {
        const originalName = leafName.replace(clusterPattern, '');
        nameToCluster.set(originalName, clusterId);
    }
    
    state.leafClusters = nameToCluster;
    
    // Update legend and re-render
    updateColorLegend();
    recalc();
}

function performClassicalMDS(distanceMatrix) {
    const n = distanceMatrix.length;
    
    // Step 1: Square the distance matrix
    const dSquared = distanceMatrix.map(row => row.map(d => d * d));
    
    // Step 2: Double-center the squared distance matrix
    // B = -0.5 * H * D^2 * H where H = I - (1/n) * 11^T
    
    // Calculate row and column means of D^2
    const rowMeans = [];
    const colMeans = [];
    const grandMean = [];
    
    for (let i = 0; i < n; i++) {
        let rowSum = 0;
        for (let j = 0; j < n; j++) {
            rowSum += dSquared[i][j];
        }
        rowMeans[i] = rowSum / n;
    }
    
    for (let j = 0; j < n; j++) {
        let colSum = 0;
        for (let i = 0; i < n; i++) {
            colSum += dSquared[i][j];
        }
        colMeans[j] = colSum / n;
    }
    
    let grandSum = 0;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            grandSum += dSquared[i][j];
        }
    }
    const grandMeanValue = grandSum / (n * n);
    
    // Compute B = -0.5 * (D^2 - row_means - col_means + grand_mean)
    const B = [];
    for (let i = 0; i < n; i++) {
        B[i] = [];
        for (let j = 0; j < n; j++) {
            B[i][j] = -0.5 * (dSquared[i][j] - rowMeans[i] - colMeans[j] + grandMeanValue);
        }
    }
    
    // Step 3: Find eigenvalues and eigenvectors using a more robust method
    const eigenResult = computeEigenDecomposition(B, 2);
    
    // Extract first two eigenvectors (largest eigenvalues)
    // Scale by sqrt(eigenvalue) to get coordinates
    const coords = [];
    
    // Ensure we have valid eigenvalues (should be non-negative for valid distance matrices)
    const lambda1 = Math.max(0, eigenResult.values[0]);
    const lambda2 = Math.max(0, eigenResult.values[1]);
    
    // Check if second eigenvalue is too small (relative to first)
    const ratio = lambda2 / (lambda1 + 1e-10);
    
    for (let i = 0; i < n; i++) {
        const x = eigenResult.vectors[0][i] * Math.sqrt(lambda1);
        let y = eigenResult.vectors[1][i] * Math.sqrt(lambda2);
        
        // If second eigenvalue is very small, still use it but scale appropriately
        // This ensures we get some spread in the second dimension
        if (ratio < 1e-6 && lambda2 > 0) {
            // Scale up the second dimension to make it visible
            y = eigenResult.vectors[1][i] * Math.sqrt(lambda1) * 0.1;
        }
        
        coords.push({ x, y });
    }
    
    return coords;
}

function computeEigenDecomposition(matrix, numComponents) {
    const n = matrix.length;
    const vectors = [];
    const values = [];
    
    // Work with a copy of the matrix to avoid modifying the original
    const A = matrix.map(row => [...row]);
    
    // Use power iteration with deflation for multiple eigenvectors
    for (let comp = 0; comp < numComponents; comp++) {
        // Start with random vector
        let v = [];
        for (let i = 0; i < n; i++) {
            v[i] = Math.random() - 0.5;
        }
        
        // Normalize
        let norm = Math.sqrt(v.reduce((sum, x) => sum + x * x, 0));
        if (norm < 1e-10) {
            // If norm is too small, use a unit vector
            v = new Array(n).fill(0);
            v[comp % n] = 1;
            norm = 1;
        }
        v = v.map(x => x / norm);
        
        // Power iteration with orthogonalization
        for (let iter = 0; iter < 200; iter++) {
            // Apply matrix: newV = A * v
            const newV = [];
            for (let i = 0; i < n; i++) {
                let sum = 0;
                for (let j = 0; j < n; j++) {
                    sum += A[i][j] * v[j];
                }
                newV[i] = sum;
            }
            
            // Orthogonalize against previous eigenvectors
            for (let prev = 0; prev < comp; prev++) {
                const dot = newV.reduce((sum, x, i) => sum + x * vectors[prev][i], 0);
                for (let i = 0; i < n; i++) {
                    newV[i] -= dot * vectors[prev][i];
                }
            }
            
            // Normalize
            norm = Math.sqrt(newV.reduce((sum, x) => sum + x * x, 0));
            if (norm < 1e-10) {
                // Vector collapsed, try a different direction
                for (let i = 0; i < n; i++) {
                    newV[i] = Math.random() - 0.5;
                }
                // Re-orthogonalize
                for (let prev = 0; prev < comp; prev++) {
                    const dot = newV.reduce((sum, x, i) => sum + x * vectors[prev][i], 0);
                    for (let i = 0; i < n; i++) {
                        newV[i] -= dot * vectors[prev][i];
                    }
                }
                norm = Math.sqrt(newV.reduce((sum, x) => sum + x * x, 0));
                if (norm < 1e-10) break;
            }
            
            newV.forEach((x, i) => { v[i] = x / norm; });
            
            // Check convergence
            if (iter > 10) {
                let maxChange = 0;
                for (let i = 0; i < n; i++) {
                    const change = Math.abs(newV[i] / norm - v[i]);
                    if (change > maxChange) maxChange = change;
                }
                if (maxChange < 1e-8) break;
            }
        }
        
        // Calculate eigenvalue using Rayleigh quotient
        const Av = [];
        for (let i = 0; i < n; i++) {
            let sum = 0;
            for (let j = 0; j < n; j++) {
                sum += A[i][j] * v[j];
            }
            Av[i] = sum;
        }
        const eigenvalue = v.reduce((sum, x, i) => sum + x * Av[i], 0);
        
        vectors.push([...v]);
        values.push(eigenvalue);
        
        // Deflate matrix for next iteration: A = A - lambda * v * v^T
        if (comp < numComponents - 1) {
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    A[i][j] -= eigenvalue * v[i] * v[j];
                }
            }
        }
    }
    
    return { vectors, values };
}

function performDBSCAN(coords, eps, minPts, subtypeIndex = null, founderIndex = null) {
    const n = coords.length;
    const visited = new Array(n).fill(false);
    const clusters = new Array(n).fill(-1); // -1 means noise/unassigned
    let clusterId = 0;
    
    // Calculate Euclidean distances between all points
    function distance(p1, p2) {
        const dx = p1.x - p2.x;
        const dy = p1.y - p2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    // Find all neighbors within eps radius (excluding subtype only)
    function getNeighbors(pointIndex) {
        const neighbors = [];
        const point = coords[pointIndex];
        for (let i = 0; i < n; i++) {
            if (i !== pointIndex && distance(point, coords[i]) <= eps) {
                // Exclude subtype from neighbor calculations (founder can cluster naturally)
                if (subtypeIndex !== null && (pointIndex === subtypeIndex || i === subtypeIndex)) {
                    continue; // Subtype is always isolated
                }
                neighbors.push(i);
            }
        }
        return neighbors;
    }
    
    // Expand cluster from a seed point
    function expandCluster(pointIndex, neighbors) {
        clusters[pointIndex] = clusterId;
        
        let i = 0;
        while (i < neighbors.length) {
            const neighborIndex = neighbors[i];
            
            if (!visited[neighborIndex]) {
                visited[neighborIndex] = true;
                const neighborNeighbors = getNeighbors(neighborIndex);
                
                if (neighborNeighbors.length >= minPts) {
                    // Add neighbors of this neighbor to the list
                    neighbors.push(...neighborNeighbors);
                }
            }
            
            // Assign to cluster if not already assigned
            if (clusters[neighborIndex] === -1) {
                clusters[neighborIndex] = clusterId;
            }
            
            i++;
        }
    }
    
    // First, assign subtype to its own cluster (cluster 0) if subtype exists
    if (subtypeIndex !== null && subtypeIndex >= 0 && subtypeIndex < n) {
        clusters[subtypeIndex] = 0;
        visited[subtypeIndex] = true;
        clusterId = 1; // Start next cluster at 1
    }
    
    // Main DBSCAN algorithm (skip subtype only, founder can cluster naturally)
    for (let i = 0; i < n; i++) {
        if (visited[i]) continue;
        if (subtypeIndex !== null && i === subtypeIndex) continue; // Skip subtype
        
        visited[i] = true;
        const neighbors = getNeighbors(i);
        
        if (neighbors.length < minPts) {
            // Mark as noise (cluster -1)
            clusters[i] = -1;
        } else {
            // Start a new cluster
            expandCluster(i, neighbors);
            clusterId++;
        }
    }
    
    return clusters;
}

// Renumber clusters by distance from subtype
function renumberClustersByDistanceFromSubtype(clusters, coords, subtypeIndex, leaves, subtypeName) {
    if (subtypeIndex === null || subtypeIndex < 0 || subtypeIndex >= coords.length) {
        return clusters; // No subtype, return as-is
    }
    
    // Find subtype index in leaves array
    let subtypeIdxInLeaves = -1;
    for (let i = 0; i < leaves.length; i++) {
        if (leaves[i].name === subtypeName) {
            subtypeIdxInLeaves = i;
            break;
        }
    }
    
    if (subtypeIdxInLeaves === -1) {
        return clusters; // Subtype not found in leaves
    }
    
    // Check if founder sequence exists
    let founderIdxInLeaves = -1;
    let founderClusterId = null;
    for (let i = 0; i < leaves.length; i++) {
        if (leaves[i].name && leaves[i].name.startsWith('consensus_of_')) {
            founderIdxInLeaves = i;
            founderClusterId = clusters[i];
            break;
        }
    }
    
    // Determine reference point for renumbering
    let referencePos;
    let referenceClusterId;
    let useFounder = false;
    
    if (founderIdxInLeaves >= 0 && founderClusterId !== null && founderClusterId !== -1) {
        // Use founder as reference
        referencePos = coords[founderIdxInLeaves];
        referenceClusterId = founderClusterId;
        useFounder = true;
    } else {
        // Use subtype as reference
        referencePos = coords[subtypeIdxInLeaves];
        referenceClusterId = 0; // Subtype's cluster
    }
    
    // Calculate cluster centroids (excluding subtype's cluster 0 and founder cluster if using founder)
    const clusterPoints = new Map(); // clusterId -> [point indices]
    for (let i = 0; i < clusters.length; i++) {
        const cid = clusters[i];
        // Exclude noise, subtype cluster (0), and founder cluster if using founder
        if (cid !== -1 && cid !== 0) {
            if (useFounder && cid === founderClusterId) {
                continue; // Skip founder cluster when using founder as reference
            }
            if (!clusterPoints.has(cid)) {
                clusterPoints.set(cid, []);
            }
            clusterPoints.get(cid).push(i);
        }
    }
    
    // Calculate centroids and distances
    const clusterDistances = [];
    clusterPoints.forEach((pointIndices, clusterId) => {
        // Calculate centroid
        let sumX = 0, sumY = 0;
        pointIndices.forEach(idx => {
            sumX += coords[idx].x;
            sumY += coords[idx].y;
        });
        const centroid = {
            x: sumX / pointIndices.length,
            y: sumY / pointIndices.length
        };
        
        // Calculate distance from reference (founder or subtype) to centroid
        const dx = referencePos.x - centroid.x;
        const dy = referencePos.y - centroid.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        clusterDistances.push({ clusterId, distance: dist });
    });
    
    // Sort by distance (closest first)
    clusterDistances.sort((a, b) => a.distance - b.distance);
    
    // Create mapping: old cluster ID -> new cluster ID
    const clusterMap = new Map();
    clusterMap.set(0, 0); // Subtype stays at 0
    
    if (useFounder && founderClusterId !== null) {
        clusterMap.set(founderClusterId, 1); // Founder becomes cluster 1
        // Other clusters start at 2
        clusterDistances.forEach((item, index) => {
            if (item.clusterId !== founderClusterId) {
                clusterMap.set(item.clusterId, index + 2);
            }
        });
    } else {
        // No founder, use subtype-based numbering
        clusterDistances.forEach((item, index) => {
            clusterMap.set(item.clusterId, index + 1); // Closest = 1, next = 2, etc.
        });
    }
    
    // Renumber clusters
    const renumbered = clusters.map(cid => {
        if (cid === -1) return -1; // Keep noise as -1
        if (cid === 0) return 0; // Subtype stays at 0
        return clusterMap.get(cid) || cid; // Map to new ID
    });
    
    return renumbered;
}

function drawMdsPlot(leaves, coords, subtypeName, clusters = null, epsilon = null, founderName = null) {
    const canvas = document.getElementById('mds-canvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const padding = { top: 40, right: 40, bottom: 60, left: 60 };
    const plotWidth = width - padding.left - padding.right;
    const plotHeight = height - padding.top - padding.bottom;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    if (coords.length === 0) {
        ctx.fillStyle = '#374151';
        ctx.font = '14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No data to plot', width / 2, height / 2);
        return;
    }
    
    // Find min/max for scaling
    const xs = coords.map(c => c.x);
    const ys = coords.map(c => c.y);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    
    const rangeX = maxX - minX || 1;
    const rangeY = maxY - minY || 1;
    
    // Scale to fit plot area with some padding
    const scaleX = plotWidth / rangeX * 0.9;
    const scaleY = plotHeight / rangeY * 0.9;
    const offsetX = padding.left + (width - padding.left - padding.right) / 2;
    const offsetY = padding.top + (height - padding.top - padding.bottom) / 2;
    
    function toPlotX(x) {
        return offsetX + (x - (minX + maxX) / 2) * scaleX;
    }
    
    function toPlotY(y) {
        return offsetY - (y - (minY + maxY) / 2) * scaleY; // Flip Y axis
    }
    
    // Draw axes
    ctx.strokeStyle = '#9ca3af';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding.left, offsetY);
    ctx.lineTo(width - padding.right, offsetY);
    ctx.moveTo(offsetX, padding.top);
    ctx.lineTo(offsetX, height - padding.bottom);
    ctx.stroke();
    
    // Draw axis labels
    ctx.fillStyle = '#374151';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Dimension 1', offsetX, height - padding.bottom + 30);
    
    ctx.save();
    ctx.translate(padding.left - 20, offsetY);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Dimension 2', 0, 0);
    ctx.restore();
    
    const noiseColor = '#9ca3af'; // Grey for noise
    
    // Calculate epsilon radius in plot coordinates (if epsilon is provided)
    // Epsilon is in data space, need to convert to pixels
    // Use average of scaleX and scaleY to convert distance to pixels
    const avgScale = (Math.abs(scaleX) + Math.abs(scaleY)) / 2;
    const epsilonRadius = epsilon !== null ? epsilon * avgScale : 0;
    
    // Draw epsilon circles first (behind points)
    if (epsilon !== null && epsilonRadius > 0) {
        leaves.forEach((leaf, i) => {
            const x = toPlotX(coords[i].x);
            const y = toPlotY(coords[i].y);
            const isSubtype = subtypeName && leaf.name === subtypeName;
            const isFounder = founderName && leaf.name === founderName;
            const clusterId = clusters ? clusters[i] : -1;
            
            // Determine color based on clustering
            let circleColor;
            if (isSubtype) {
                circleColor = '#dc2626'; // Red for subtype
            } else if (clusterId === -1) {
                circleColor = noiseColor; // Grey for noise
            } else {
                circleColor = getClusterColor(clusterId);
            }
            
            // Draw light circle with cluster color
            ctx.beginPath();
            ctx.arc(x, y, epsilonRadius, 0, 2 * Math.PI);
            ctx.fillStyle = circleColor;
            ctx.globalAlpha = 0.2; // Light/transparent
            ctx.fill();
            ctx.globalAlpha = 1.0; // Reset alpha
        });
    }
    
    // Draw points
    leaves.forEach((leaf, i) => {
        const x = toPlotX(coords[i].x);
        const y = toPlotY(coords[i].y);
        const isSubtype = subtypeName && leaf.name === subtypeName;
        const isFounder = founderName && leaf.name === founderName;
        const clusterId = clusters ? clusters[i] : -1;
        
        // Determine color based on clustering
        let fillColor, strokeColor;
        if (isSubtype) {
            fillColor = '#dc2626'; // Red for subtype
            strokeColor = '#991b1b';
        } else if (clusterId === -1) {
            fillColor = noiseColor; // Grey for noise
            strokeColor = '#6b7280';
        } else {
            fillColor = getClusterColor(clusterId);
            strokeColor = fillColor;
        }
        
        // Draw point
        ctx.beginPath();
        if (isSubtype) {
            // Draw subtype as a diamond
            ctx.fillStyle = fillColor;
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            const size = 8;
            ctx.moveTo(x, y - size);
            ctx.lineTo(x + size, y);
            ctx.lineTo(x, y + size);
            ctx.lineTo(x - size, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        } else {
            // Draw regular leaves as circles
            ctx.fillStyle = fillColor;
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 1;
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
        }
    });
    
    // Draw labels for subtype and founder AFTER all points and circles
    leaves.forEach((leaf, i) => {
        const x = toPlotX(coords[i].x);
        const y = toPlotY(coords[i].y);
        const isSubtype = subtypeName && leaf.name === subtypeName;
        const isFounder = founderName && leaf.name === founderName;
        
        if (isSubtype || isFounder) {
            ctx.fillStyle = '#111827';
            ctx.font = '9px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(leaf.name || 'Unnamed', x + 8, y + 3);
        }
    });
    
    // Draw legend
    ctx.fillStyle = '#111827';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'left';
    let legendY = padding.top - 25;
    ctx.fillText('Legend:', padding.left, legendY);
    
    // Subtype
    ctx.fillStyle = '#dc2626';
    ctx.strokeStyle = '#991b1b';
    ctx.lineWidth = 2;
    ctx.beginPath();
    const subtypeX = padding.left + 60;
    const subtypeY = legendY - 5;
    const size = 6;
    ctx.moveTo(subtypeX, subtypeY - size);
    ctx.lineTo(subtypeX + size, subtypeY);
    ctx.lineTo(subtypeX, subtypeY + size);
    ctx.lineTo(subtypeX - size, subtypeY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = '#111827';
    ctx.fillText('Subtype', subtypeX + 10, subtypeY + 4);
    
    // Show cluster info if clustering is active
    if (clusters) {
        const numClusters = new Set(clusters.filter(c => c !== -1)).size;
        const numNoise = clusters.filter(c => c === -1).length;
        
        let xPos = subtypeX + 80;
        
        if (numClusters > 0) {
            ctx.fillText(`Clusters: ${numClusters}`, xPos, legendY);
            xPos += 100;
        }
        
        if (numNoise > 0) {
            ctx.fillStyle = noiseColor;
            ctx.beginPath();
            ctx.arc(xPos, subtypeY, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#6b7280';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.fillStyle = '#111827';
            ctx.fillText(`Noise: ${numNoise}`, xPos + 10, subtypeY + 4);
        }
    }
}

function runLadderizeTask() {
    const mode = document.getElementById('sel-ladderize-mode').value;
    document.getElementById('ladderize-overlay').style.display = 'none';
    ladderizeTree(mode);
}

function ladderizeTree(mode) {
    if (!state.tree || !state.tree.root) {
        alert("Please load or infer a tree first.");
        return;
    }
    
    saveState();
    
    if (mode === 'weight') {
        // Sort by number of leaves (weight)
    function countLeaves(node) {
        if (!node.children || node.children.length === 0) {
            node.leafCount = 1;
            return 1;
        }
        let count = 0;
        for (const child of node.children) {
            count += countLeaves(child);
        }
        node.leafCount = count;
        return count;
    }
    
    function sortChildren(node) {
            // Only terminate recursion when there are zero children (leaf node)
            if (!node.children || node.children.length === 0) return;
            // If there's only one child, still recurse into it (don't sort, but recurse)
            if (node.children.length > 1) {
        node.children.sort((a, b) => a.leafCount - b.leafCount);
            }
        for (const child of node.children) {
            sortChildren(child);
        }
    }
    
    countLeaves(state.tree.root);
    sortChildren(state.tree.root);
    } else if (mode === 'depth') {
        // For each node, calculate the maximum depth from root to deepest leaf in each child's subtree
        // Using branch lengths (sum of branch lengths from root), not node counts
        // Then sort children from shallowest to deepest by that maximum depth
        function calculateSubtreeMaxDepth(node, depthFromRoot = 0) {
            // Add this node's branch length to the depth from root
            const branchLength = node.len || 0;
            const currentDepth = depthFromRoot + branchLength;
            
            if (!node.children || node.children.length === 0) {
                // Leaf node: its depth from root is the sum of branch lengths from root
                node.subtreeMaxDepth = currentDepth;
                return currentDepth;
            }
            // Internal node: find max depth among all leaves in this subtree
            let maxLeafDepth = -1;
            for (const child of node.children) {
                const childMaxDepth = calculateSubtreeMaxDepth(child, currentDepth);
                if (childMaxDepth > maxLeafDepth) {
                    maxLeafDepth = childMaxDepth;
                }
            }
            node.subtreeMaxDepth = maxLeafDepth;
            return node.subtreeMaxDepth;
        }
        
        function sortChildren(node) {
            // Only terminate recursion when there are zero children (leaf node)
            if (!node.children || node.children.length === 0) return;
            
            // If there's only one child, still recurse into it (don't sort, but recurse)
            if (node.children.length > 1) {
                // Sort in ascending order: shallowest subtrees first, deepest subtrees last in array
                // In depth-first traversal, we visit children in array order [shallow, deep]
                // Shallow subtrees processed first → their leaves collected first → appear at top
                // Deep subtrees processed last → their leaves collected last → appear at bottom
                node.children.sort((a, b) => a.subtreeMaxDepth - b.subtreeMaxDepth);
            }
            
            // Recursively sort children of each child
            for (const child of node.children) {
                sortChildren(child);
            }
        }
        
        calculateSubtreeMaxDepth(state.tree.root, 0);
        sortChildren(state.tree.root);
    }
    
    applyTreeOrder(state.tree.root);
    
    // Enable Histogram, Cluster, and tree export buttons after successful ladderize
    enableButtonsAfterLadderize();
    
    recalc();
}

// --- Temporary Notification ---
function showTemporaryNotification(message, duration) {
    // Create notification element
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #2563eb;
        color: white;
        padding: 12px 20px;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 10001;
        font-size: 14px;
        font-weight: 500;
        opacity: 0;
        transition: opacity 0.3s ease;
    `;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    // Fade in
    setTimeout(() => {
        notification.style.opacity = '1';
    }, 10);
    
    // Fade out and remove after duration
    setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    }, duration);
}

// --- Epitope Loading and Selection ---
function loadEpitopes(file) {
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const text = e.target.result;
            const lines = text.split(/\r?\n/).filter(line => line.trim());
            const epitopes = [];
            
            for (const line of lines) {
                const parts = line.split(',').map(p => p.trim());
                if (parts.length < 2) continue;
                
                const name = parts[0];
                const regions = [];
                
                // Parse coordinate pairs from remaining parts
                for (let i = 1; i < parts.length; i++) {
                    const coordStr = parts[i];
                    if (!coordStr) continue;
                    
                    if (coordStr.includes(':')) {
                        // Format: start:stop
                        const [startStr, endStr] = coordStr.split(':').map(s => parseInt(s.trim()));
                        if (!isNaN(startStr) && !isNaN(endStr)) {
                            regions.push({ start: startStr, end: endStr });
                        }
                    } else {
                        // Format: single coordinate (both start and stop)
                        const coord = parseInt(coordStr.trim());
                        if (!isNaN(coord)) {
                            regions.push({ start: coord, end: coord });
                        }
                    }
                }
                
                if (regions.length > 0) {
                    epitopes.push({ name, regions });
                }
            }
            
            state.epitopes = epitopes;
            
            // Enable Select Epitope button after successful loading
            enableButtonsAfterLoadEpitopes();
            
            // Show temporary notification that disappears after 2 seconds
            showTemporaryNotification(`Loaded ${epitopes.length} epitope(s). Use "Select Epitope" to choose one.`, 2000);
        } catch (err) {
            console.error("Error loading epitopes:", err);
            alert("Error loading epitopes: " + err.message);
        }
    };
    reader.readAsText(file);
}

function showEpitopeSelector() {
    if (state.epitopes.length === 0) {
        alert("No epitopes loaded. Please load epitopes first.");
        return;
    }
    
    // Create a simple selector dialog
    const selector = document.createElement('div');
    selector.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; box-shadow: 0 10px 25px rgba(0,0,0,0.3); z-index: 10000; min-width: 300px;';
    
    const title = document.createElement('h3');
    title.textContent = 'Select Epitope';
    title.style.margin = '0 0 15px 0';
    selector.appendChild(title);
    
    const list = document.createElement('select');
    list.style.cssText = 'width: 100%; padding: 8px; margin-bottom: 15px; font-size: 14px;';
    
    // Add "None" option to clear selection
    const noneOption = document.createElement('option');
    noneOption.value = '';
    noneOption.textContent = 'None (show all)';
    if (!state.selectedEpitope) noneOption.selected = true;
    list.appendChild(noneOption);
    
    for (const epitope of state.epitopes) {
        const option = document.createElement('option');
        option.value = epitope.name;
        option.textContent = epitope.name;
        if (state.selectedEpitope === epitope.name) option.selected = true;
        list.appendChild(option);
    }
    selector.appendChild(list);
    
    const buttonDiv = document.createElement('div');
    buttonDiv.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end;';
    
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.cssText = 'padding: 8px 16px; border: 1px solid #ccc; background: white; cursor: pointer;';
    cancelBtn.onclick = () => selector.remove();
    buttonDiv.appendChild(cancelBtn);
    
    const selectBtn = document.createElement('button');
    selectBtn.textContent = 'Select';
    selectBtn.style.cssText = 'padding: 8px 16px; border: 1px solid #2563eb; background: #2563eb; color: white; cursor: pointer;';
    selectBtn.onclick = () => {
        const selectedName = list.value;
        selectEpitope(selectedName || null);
        selector.remove();
    };
    buttonDiv.appendChild(selectBtn);
    
    selector.appendChild(buttonDiv);
    document.body.appendChild(selector);
}

/** Convert a ref region (1-based inclusive start/end) to alignment column indices. Only includes columns where the reference has a residue (not a gap), so the region stops at the last coordinate and does not include trailing (or leading) gaps. Used by epitope highlighting, logos, and region logos. */
function getAlignmentColumnsForRefRegion(region) {
    var refSeq = state.viewSequences && state.refIndex >= 0 ? state.viewSequences[state.refIndex].seq : null;
    if (!refSeq || !state.refMap) return [];
    var cols = [];
    for (var col = 0; col < state.refMap.length && col < refSeq.length; col++) {
        if (refSeq[col] !== '-' && refSeq[col] !== '.' && state.refMap[col] >= region.start && state.refMap[col] <= region.end) {
            cols.push(col);
        }
    }
    return cols;
}

function selectEpitope(epitopeName) {
    state.selectedEpitope = epitopeName;
    
    if (!epitopeName) {
        // Clear epitope selection - show all
        state.epitopeColumns = null;
        // Disable Show Logo button when epitope selection is cleared
        if (dom.btnShowLogo) dom.btnShowLogo.disabled = true;
        recalc();
        return;
    }
    
    // Find the epitope
    const epitope = state.epitopes.find(e => e.name === epitopeName);
    if (!epitope) {
        alert(`Epitope "${epitopeName}" not found.`);
        return;
    }
    
    // Create a set of allowed alignment columns using shared ref-coord-to-column mapping
    const allowedColumns = new Set();
    for (const region of epitope.regions) {
        const cols = getAlignmentColumnsForRefRegion(region);
        cols.forEach(function (c) { allowedColumns.add(c); });
    }
    state.epitopeColumns = allowedColumns;
    
    // Enable Show Logo button after successful epitope selection
    enableButtonsAfterSelectEpitope();
    
    recalc();
}

function setTreeWidth(w) {
    state.treeWidth = Math.max(0, w);
    document.documentElement.style.setProperty('--tree-width', state.treeWidth + 'px');
    onResize();
}

function setNamesWidth(w) {
    state.namesWidth = Math.max(100, Math.min(800, w));
    document.documentElement.style.setProperty('--names-width', state.namesWidth + 'px');
    onResize();
}

function calculateNamesWidth() {
    if (!state.rawSequences.length) {
        setNamesWidth(200); // Default width
        return;
    }
    
    // Ensure canvas is initialized for text measurement
    if (dom.cvsNames.width === 0) {
        dom.cvsNames.width = 1;
        dom.cvsNames.height = 1;
    }
    
    // Calculate width needed for longest sequence name
    const ctx = dom.cvsNames.getContext('2d');
    ctx.font = CONFIG.labelFont;
    
    let maxWidth = 0;
    state.rawSequences.forEach((s, idx) => {
        let text = s.name;
        if(idx === state.refIndex) text += " [Reference]";
        if(idx === state.subtypeIndex) text += " [Subtype]";
        if(s.name && s.name.startsWith('consensus_of_')) {
            text += " [Founder]";
        }
        const metrics = ctx.measureText(text);
        if (metrics.width > maxWidth) {
            maxWidth = metrics.width;
        }
    });
    
    // Add padding (20px on each side) and set width
    const calculatedWidth = Math.ceil(maxWidth) + 40;
    setNamesWidth(Math.max(200, Math.min(800, calculatedWidth)));
}

function setMode(m, disableNT = false) {
    state.mode = m;
    if(m === 'NT') {
        dom.btnNt.classList.add('active'); dom.btnAa.classList.remove('active');
        if (dom.grpFrame) {
            dom.grpFrame.style.opacity = '0.4'; dom.grpFrame.style.pointerEvents = 'none';
        }
        // Enable NT button
        dom.btnNt.disabled = false;
        dom.btnNt.style.opacity = '1';
    } else {
        dom.btnAa.classList.add('active'); dom.btnNt.classList.remove('active');
        // Enable frame selector only when viewing AA mode with an NT alignment (not when AA alignment is loaded)
        if (dom.grpFrame) {
            if (state.isAASequence) {
                // AA alignment loaded - disable frame selector
                dom.grpFrame.style.opacity = '0.4'; dom.grpFrame.style.pointerEvents = 'none';
            } else {
                // NT alignment loaded - enable frame selector when switching to AA mode
                dom.grpFrame.style.opacity = '1'; dom.grpFrame.style.pointerEvents = 'auto';
            }
        }
        // Disable NT button if AA alignment was detected (can't reverse translate)
        if (disableNT) {
            dom.btnNt.disabled = true;
            dom.btnNt.style.opacity = '0.5';
            dom.btnNt.title = 'NT mode disabled: amino acid alignment cannot be reverse translated';
        } else {
            dom.btnNt.disabled = false;
            dom.btnNt.style.opacity = '1';
            dom.btnNt.title = '';
        }
    }
    state.selection = null;
    recalc();
}

function recalc() {
    if (dom.btnUndo) {
        dom.btnUndo.disabled = (state.history.length === 0);
        dom.btnUndo.style.opacity = (state.history.length === 0) ? "0.5" : "1";
    }

    if(!state.rawSequences.length) return;

    // Always put reference sequence at the top
    const refSeq = state.rawSequences[state.refIndex];
    const nonRefSequences = state.rawSequences.filter((s, idx) => idx !== state.refIndex);
    
    let allViewSequences;
    if(state.mode === 'NT') {
        const refView = refSeq ? { name: refSeq.name, seq: refSeq.seq } : null;
        const nonRefViews = nonRefSequences.map(s => {
            const v = { name: s.name, seq: s.seq };
            if (s.chainStart != null && s.chainStart >= 0) v.chainStart = s.chainStart;
            if (s.isPdbChain) v.isPdbChain = true;
            if (s.chainLength != null) v.chainLength = s.chainLength;
            if (s.alignedLength != null) v.alignedLength = s.alignedLength;
            return v;
        });
        allViewSequences = refView ? [refView, ...nonRefViews] : nonRefViews;
    } else {
        // AA mode
        if (state.isAASequence) {
            // Sequences are already amino acids, use them directly (preserve chainStart and isPdbChain for PDB chains)
            const refView = refSeq ? { name: refSeq.name, seq: refSeq.seq } : null;
            const nonRefViews = nonRefSequences.map(s => {
                const v = { name: s.name, seq: s.seq };
                if (s.chainStart != null && s.chainStart >= 0) v.chainStart = s.chainStart;
                if (s.isPdbChain) v.isPdbChain = true;
                if (s.chainLength != null) v.chainLength = s.chainLength;
                if (s.alignedLength != null) v.alignedLength = s.alignedLength;
                return v;
            });
            allViewSequences = refView ? [refView, ...nonRefViews] : nonRefViews;
        } else {
            // Sequences are DNA, translate to AA
        const offset = state.frame - 1;
            const refView = refSeq ? {
                name: refSeq.name,
                seq: (() => {
                    const dna = refSeq.seq;
                    const aa = [];
                    for(let i=offset; i<dna.length; i+=3) {
                        if(i+2 >= dna.length) break;
                        const codon = dna.slice(i, i+3).join('');
                        if(codon.includes('-')) aa.push('-');
                        else if (/[^ACGT]/i.test(codon)) aa.push('X');
                        else aa.push(CODON_TABLE[codon] || 'X');
                    }
                    return aa;
                })()
            } : null;
            const nonRefViews = nonRefSequences.map(s => {
            const dna = s.seq;
            const aa = [];
            for(let i=offset; i<dna.length; i+=3) {
                if(i+2 >= dna.length) break;
                const codon = dna.slice(i, i+3).join('');
                if(codon.includes('-')) aa.push('-');
                else if (/[^ACGT]/i.test(codon)) aa.push('X');
                else aa.push(CODON_TABLE[codon] || 'X');
            }
            const v = { name: s.name, seq: aa };
            if (s.chainStart != null && s.chainStart >= 0) v.chainStart = s.chainStart;
            if (s.isPdbChain) v.isPdbChain = true;
            if (s.chainLength != null) v.chainLength = s.chainLength;
            if (s.alignedLength != null) v.alignedLength = s.alignedLength;
            return v;
        });
            allViewSequences = refView ? [refView, ...nonRefViews] : nonRefViews;
        }
    }
    
    state.viewSequences = allViewSequences;
    // Reference is always at index 0 in viewSequences
    state.refIndex = 0;
    
    // Find subtype index in viewSequences (for highlighting and bottom ruler)
    const subtypeName = state.rawSequences[state.subtypeIndex]?.name;
    const subtypeViewIndex = state.viewSequences.findIndex(s => s.name === subtypeName);
    state.subtypeViewIndex = subtypeViewIndex >= 0 ? subtypeViewIndex : -1;

    let max = 0;
    state.viewSequences.forEach(s => max = Math.max(max, s.seq.length));
    state.maxLength = max;
    
    // Use reference sequence for top ruler coordinate mapping
    state.refMap = new Int32Array(max + 1);
    if(state.viewSequences[state.refIndex]) {
        const refSeq = state.viewSequences[state.refIndex].seq;
        let count = 0;
        for(let i=0; i<max; i++) {
            const char = (i < refSeq.length) ? refSeq[i] : '-';
            if(char !== '-') count++;
            state.refMap[i] = count;
        }
    }
    
    

    dom.sizer.style.width = (max * CONFIG.charWidth + 200) + 'px';
    dom.sizer.style.height = (state.viewSequences.length * CONFIG.rowHeight) + 'px';
    
    if(state.tree) {
        const nameToRow = new Map();
        state.viewSequences.forEach((s, i) => nameToRow.set(s.name, i));
        
        let matchedCount = 0;
        
        function computeY(node) {
            if(!node.children || node.children.length === 0) {
                if(node.name && nameToRow.has(node.name)) {
                    node.yRow = nameToRow.get(node.name);
                    node.hidden = false;
                    matchedCount++;
                } else {
                    node.yRow = 0;
                    node.hidden = true;
                }
            } else {
                let sumY = 0, count = 0;
                let minC = Infinity, maxC = -Infinity;
                let allHidden = true;
                
                node.children.forEach(c => {
                    computeY(c);
                    if(!c.hidden) {
                        sumY += c.yRow;
                        if(c.yRow < minC) minC = c.yRow;
                        if(c.yRow > maxC) maxC = c.yRow;
                        count++;
                        allHidden = false;
                    }
                });
                node.hidden = allHidden;
                node.yRow = count ? (minC + maxC) / 2 : 0;
            }
        }
        computeY(state.tree.root);
    }

    render();
}

// --- Interactions ---
function getCoords(e, type) {
    let r = 0, c = 0;
    const rect = (type==='SEQ'?dom.areaSeq:(type==='NAMES'?dom.areaNames:dom.areaRuler)).getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    if(type === 'SEQ') {
        c = Math.floor((x + dom.areaSeq.scrollLeft) / CONFIG.charWidth);
        r = Math.floor((y + dom.areaSeq.scrollTop) / CONFIG.rowHeight);
    } else if (type === 'NAMES') {
        r = Math.floor((y + dom.areaSeq.scrollTop) / CONFIG.rowHeight);
    } else if (type === 'RULER') {
        c = Math.floor((x + dom.areaSeq.scrollLeft) / CONFIG.charWidth);
    }
    return { r, c };
}

function onMouseDown(e, type) {
    dom.areaSeq.focus();
    
    const { r, c } = getCoords(e, type);
    const maxR = Math.max(0, state.viewSequences.length - 1);
    const safeR = Math.min(r, maxR);
    const safeC = Math.max(0, c);

    state.mouse.isDown = true;
    state.mouse.startR = safeR;
    state.mouse.startC = safeC;
    state.mouse.lastHoverC = safeC;

    // Shift Click Logic
    if(e.shiftKey && state.selectionAnchor) {
        state.mouse.target = type;
        const anchor = state.selectionAnchor;
        
        let newR1 = Math.min(anchor.r, safeR);
        let newR2 = Math.max(anchor.r, safeR);
        let newC1 = Math.min(anchor.c, safeC);
        let newC2 = Math.max(anchor.c, safeC);

        if(type === 'NAMES') {
            state.selection = { r1: newR1, r2: newR2, c1: 0, c2: 99999999 };
        } else if (type === 'RULER') {
            state.selection = { r1: 0, r2: maxR, c1: newC1, c2: newC2 };
        } else if (type === 'SEQ') {
            state.selection = { r1: newR1, r2: newR2, c1: newC1, c2: newC2 };
        }
        render();
        return;
    }

    if(type === 'SEQ' && isInsideSelection(r, c) && !e.shiftKey) {
        state.mouse.target = 'MOVE';
        dom.areaSeq.classList.add('grabbing');
    } else if (state.mouse.target === 'RESIZE_TREE') {
        // handled
    } else {
        state.mouse.target = type;
        
        // Set Anchor
        state.selectionAnchor = { r: safeR, c: safeC };

        if(type === 'SEQ') {
            state.selection = { r1: safeR, c1: safeC, r2: safeR, c2: safeC };
        } else if (type === 'NAMES') {
            state.selection = { r1: safeR, r2: safeR, c1: 0, c2: 99999999 }; 
        } else if (type === 'RULER') {
            state.selection = { r1: 0, r2: maxR, c1: safeC, c2: safeC };
        }
    }
    render();
}

function onMouseMove(e) {
    if(!state.mouse.isDown) return;

    if(state.mouse.target === 'RESIZE_TREE') {
        const x = e.clientX;
        const newW = Math.max(20, Math.min(600, x));
        setTreeWidth(newW);
        return;
    }
    
    if(state.mouse.target === 'RESIZE_NAMES') {
        const deltaX = e.clientX - state.mouse.startX;
        const newW = Math.max(100, Math.min(800, state.mouse.startNamesWidth + deltaX));
        setNamesWidth(newW);
        return;
    }
    
    const { r, c } = getCoords(e, 'SEQ');
    const safeR = Math.max(0, Math.min(state.viewSequences.length-1, r));
    const safeC = Math.max(0, c);

    if(state.mouse.target === 'SEQ') {
        state.selection.r1 = Math.min(state.mouse.startR, safeR);
        state.selection.r2 = Math.max(state.mouse.startR, safeR);
        state.selection.c1 = Math.min(state.mouse.startC, safeC);
        state.selection.c2 = Math.max(state.mouse.startC, safeC);
        render();
    } else if(state.mouse.target === 'NAMES') {
        state.selection.r1 = Math.min(state.mouse.startR, safeR);
        state.selection.r2 = Math.max(state.mouse.startR, safeR);
        state.selection.c1 = 0; state.selection.c2 = 99999999;
        render();
    } else if(state.mouse.target === 'RULER') {
        state.selection.c1 = Math.min(state.mouse.startC, safeC);
        state.selection.c2 = Math.max(state.mouse.startC, safeC);
        state.selection.r1 = 0; state.selection.r2 = state.viewSequences.length - 1;
        render();
    } else if(state.mouse.target === 'MOVE') {
        const delta = safeC - state.mouse.lastHoverC;
        if(delta !== 0) {
            if(!state.dragSaved) { saveState(); state.dragSaved = true; }
            attemptMoveSelection(delta);
            state.mouse.lastHoverC = safeC;
        }
    }
}

function onMouseUp() {
    state.mouse.isDown = false;
    state.mouse.target = null;
    state.dragSaved = false;
    dom.areaSeq.classList.remove('grabbing');
}

function isInsideSelection(r, c) {
    const s = state.selection;
    if(!s) return false;
    return r >= s.r1 && r <= s.r2 && c >= s.c1 && c <= s.c2;
}

// --- Editing Logic ---
function onKeyDown(e) {
    if(!state.selection) return;
    if(e.ctrlKey || e.metaKey) return;

    if(e.key === ' ') { e.preventDefault(); saveState(); insertGap(); }
    else if (e.key === 'Backspace' || e.key === 'Delete') { e.preventDefault(); saveState(); handleDeletion(); }
    else if (state.mode === 'NT') {
        const char = e.key.toUpperCase();
        // Allow IUPAC ambigs
        if(/^[ACGTURYMKSWHBVDN-]$/.test(char)) { e.preventDefault(); saveState(); overwriteBlock(char); }
    }
}

function handleDeletion() {
    const { r1, r2, c1, c2 } = state.selection;
    const allRows = state.viewSequences.length;

    if(c1 === 0 && c2 >= 99999) {
        state.rawSequences.splice(r1, r2 - r1 + 1);
        state.selection = null;
        recalc(); return;
    }
    if(r1 === 0 && r2 >= allRows - 1) {
        const count = c2 - c1 + 1;
        state.rawSequences.forEach(s => {
            const dna = s.seq;
            if(state.mode === 'NT') { if(c1 < dna.length) dna.splice(c1, count); }
            else { const off = state.frame - 1; const idx = (c1 * 3) + off; if(idx < dna.length) dna.splice(idx, count * 3); }
        });
        state.selection = null; recalc(); return;
    }
    deleteBlock();
}

function deleteBlock() {
    const { r1, r2, c1, c2 } = state.selection;
    const count = c2 - c1 + 1;
    const safeC2 = (c2 > 99999) ? state.maxLength + 10 : c2;
    const safeCount = safeC2 - c1 + 1;

    for(let r=r1; r<=r2; r++) {
        if(!state.rawSequences[r]) continue;
        const dna = state.rawSequences[r].seq;
        if(state.mode === 'NT') dna.splice(c1, safeCount);
        else {
            const off = state.frame - 1;
            const idx = (c1 * 3) + off;
            if(idx < dna.length) dna.splice(idx, safeCount * 3);
        }
    }
    state.selection = { r1, r2, c1, c2: c1 }; recalc();
}

function insertGap() {
    const { r1, r2, c1 } = state.selection;
    for(let r=r1; r<=r2; r++) {
        if(!state.rawSequences[r]) continue;
        const dna = state.rawSequences[r].seq;
        if(state.mode === 'NT') dna.splice(c1, 0, '-');
        else { const idx = (c1 * 3) + (state.frame - 1); dna.splice(idx, 0, '-', '-', '-'); }
    }
    recalc();
}

function overwriteBlock(char) {
    const { r1, r2, c1, c2 } = state.selection;
    for(let r=r1; r<=r2; r++) {
        if(!state.rawSequences[r]) continue;
        const dna = state.rawSequences[r].seq;
        const effectiveC2 = Math.min(c2, dna.length + 50); 
        for(let c=c1; c<=effectiveC2; c++) {
            if(c < dna.length) dna[c] = char; else dna.push(char);
        }
    }
    recalc();
}

function attemptMoveSelection(dir) {
    if(dir === 0) return;
    const { r1, r2, c1, c2 } = state.selection;
    let canMove = true;
    for(let r=r1; r<=r2; r++) {
        if(!state.rawSequences[r]) continue;
        const dna = state.rawSequences[r].seq;
        let start, end, step;
        if(state.mode === 'NT') { start = c1; end = c2; step = 1; }
        else { const off = state.frame - 1; start = c1*3+off; end = c2*3+off+2; step = 3; }
        const checkEnd = Math.min(end, dna.length - 1);

        if(dir > 0) {
            for(let k=1; k<=step; k++) if(checkEnd + k < dna.length && dna[checkEnd + k] !== '-') { canMove = false; break; }
        } else {
            if(start - step < 0) { canMove = false; break; }
            for(let k=1; k<=step; k++) if(dna[start - k] !== '-') { canMove = false; break; }
        }
        if(!canMove) break;
    }
    if(!canMove) return;

    for(let r=r1; r<=r2; r++) {
        if(!state.rawSequences[r]) continue;
        const dna = state.rawSequences[r].seq;
        let start, end, step;
        if(state.mode === 'NT') { start = c1; end = c2; step = 1; }
        else { const off = state.frame - 1; start = c1*3+off; end = c2*3+off+2; step = 3; }
        const effectiveEnd = Math.min(end, dna.length - 1);

        if(dir > 0) {
            while(dna.length <= effectiveEnd + step) dna.push('-');
            for(let i = effectiveEnd; i >= start; i--) { dna[i+step] = dna[i]; dna[i] = '-'; }
        } else {
            for(let i = start; i <= effectiveEnd; i++) { dna[i-step] = dna[i]; dna[i] = '-'; }
        }
    }
    state.selection.c1 += (dir>0?1:-1); state.selection.c2 += (dir>0?1:-1); recalc();
}

// --- Render ---
function showOverlay(b) { dom.overlay.classList.toggle('active', b); }

function onResize() {
    dom.cvsNames.width = dom.areaNames.clientWidth;
    dom.cvsNames.height = dom.areaNames.clientHeight;
    dom.cvsRuler.width = dom.areaRuler.clientWidth;
    dom.cvsRuler.height = dom.areaRuler.clientHeight;
    dom.cvsSeq.width = dom.areaSeq.clientWidth;
    dom.cvsSeq.height = dom.areaSeq.clientHeight;
    if(state.treeWidth > 0) {
        dom.cvsTree.width = dom.areaTree.clientWidth;
        dom.cvsTree.height = dom.areaTree.clientHeight;
    }
    render();
}

function render() {
    if(!state.viewSequences.length && state.rawSequences.length === 0) {
        // Draw watermark on white background when no alignment is loaded
        const vW = dom.cvsSeq.width, vH = dom.cvsSeq.height;
        ctxSeq.fillStyle = '#ffffff';
        ctxSeq.fillRect(0, 0, vW, vH);
        
        // Draw watermark text - two lines stacked and centered
        ctxSeq.save();
        ctxSeq.fillStyle = '#b0b0b0'; // Darker grey for watermark
        ctxSeq.textAlign = 'center';
        ctxSeq.textBaseline = 'middle';
        ctxSeq.globalAlpha = 0.5; // More visible watermark
        const centerX = vW / 2;
        const centerY = vH / 2;
        
        // Draw two lines of text, stacked and centered
        ctxSeq.font = 'bold 144px Arial, sans-serif';
        const lineHeight = 180; // Spacing between lines
        const startY = centerY - (lineHeight / 2); // Start above center
        
        ctxSeq.fillText('aliViz', centerX, startY);
        ctxSeq.font = 'bold 72px Arial, sans-serif'; // Smaller font for the group name
        ctxSeq.fillText('HIVDiversity Group', centerX, startY + lineHeight);
        
        ctxSeq.restore();
        return;
    }

    const vW = dom.cvsSeq.width, vH = dom.cvsSeq.height;
    const scrollLeft = dom.areaSeq.scrollLeft, scrollTop = dom.areaSeq.scrollTop;

    const startRow = Math.floor(scrollTop / CONFIG.rowHeight);
    const endRow = Math.min(state.viewSequences.length, Math.ceil((scrollTop + vH) / CONFIG.rowHeight));
    
    const startCol = Math.floor(scrollLeft / CONFIG.charWidth);
    const endCol = Math.ceil((scrollLeft + vW) / CONFIG.charWidth);

    // Sequence
    ctxSeq.fillStyle = '#ffffff'; ctxSeq.fillRect(0,0,vW,vH);
    ctxSeq.font = CONFIG.font; ctxSeq.textBaseline = 'middle'; ctxSeq.textAlign = 'center';
    const colors = state.mode === 'NT' ? CONFIG.colors.NT : CONFIG.colors.AA;
    
    // Get the sequence to use for highlighting based on user selection
    let highlightSeq = null;
    if (state.highlightMatches) {
        if (state.highlightMatches === 'founder') {
            // Find founder sequence (consensus_of_ prefix)
            const founderIndex = state.viewSequences.findIndex(s => 
                s.name && s.name.startsWith('consensus_of_')
            );
            if (founderIndex >= 0) {
                highlightSeq = state.viewSequences[founderIndex].seq;
            }
        } else if (state.highlightMatches === 'subtype') {
            // Use subtype sequence
            if (state.subtypeViewIndex >= 0 && state.viewSequences[state.subtypeViewIndex]) {
                highlightSeq = state.viewSequences[state.subtypeViewIndex].seq;
            }
        } else if (state.highlightMatches === 'reference') {
            // Use reference sequence
            if (state.refIndex >= 0 && state.viewSequences[state.refIndex]) {
                highlightSeq = state.viewSequences[state.refIndex].seq;
            }
        }
    }

    // If epitope is selected, only show columns in the epitopeColumns set
    const showColumn = (c) => {
        if (state.epitopeColumns === null) return true; // No epitope selected, show all
        return state.epitopeColumns.has(c);
    };

    for(let r=startRow; r<endRow; r++) {
        const seq = state.viewSequences[r].seq;
        const y = (r * CONFIG.rowHeight) - scrollTop;
        for(let c=startCol; c<endCol; c++) {
            if(c >= seq.length) break;
            
            // Skip columns not in the epitope
            if (!showColumn(c)) continue;
            
            const char = seq[c];
            const x = (c * CONFIG.charWidth) - scrollLeft;
            let fillColor;
            
            // Use light grey for gap characters to distinguish from suppressed columns (white)
            if (char === '-') {
                fillColor = '#e5e7eb'; // Light grey for gaps
            } else {
                fillColor = colors[char] || colors['default'];
                
                if(state.highlightMatches && highlightSeq) {
                    const highlightChar = (c < highlightSeq.length) ? highlightSeq[c] : '-';
                    if(highlightChar !== '-') {
                        if(char === highlightChar) {
                        fillColor = CONFIG.highlightMatchColor;
                        }
                    }
                }
            }

            ctxSeq.fillStyle = fillColor;
            ctxSeq.fillRect(x, y, CONFIG.charWidth, CONFIG.rowHeight);
            if(char !== '-') {
                ctxSeq.fillStyle = '#000';
                ctxSeq.fillText(char, x + CONFIG.charWidth/2, y + CONFIG.rowHeight/2);
            }
        }
    }

    // Selection
    if(state.selection) {
        const { r1, r2, c1, c2 } = state.selection;
        const visC2 = Math.min(c2, state.maxLength + 20);
        const sx = (c1 * CONFIG.charWidth) - scrollLeft;
        const sy = (r1 * CONFIG.rowHeight) - scrollTop;
        const w = Math.max(4, (visC2 - c1 + 1) * CONFIG.charWidth);
        const h = (r2 - r1 + 1) * CONFIG.rowHeight;
        
        ctxSeq.fillStyle = 'rgba(37, 99, 235, 0.2)'; ctxSeq.fillRect(sx, sy, w, h);
        ctxSeq.strokeStyle = 'rgba(37, 99, 235, 0.8)'; ctxSeq.lineWidth = 1; ctxSeq.strokeRect(sx, sy, w, h);
    }

    // Names
    ctxNames.fillStyle = '#fff'; ctxNames.fillRect(0,0,dom.cvsNames.width, dom.cvsNames.height);
    ctxNames.font = CONFIG.labelFont; ctxNames.textBaseline = 'middle'; ctxNames.textAlign = 'left';
    for(let r=startRow; r<endRow; r++) {
        const y = (r * CONFIG.rowHeight) - scrollTop;
        let isSel = state.selection && (r >= state.selection.r1 && r <= state.selection.r2);
        
        // Check if this is the subtype sequence in viewSequences
        const isSubtype = state.viewSequences[r].name === state.rawSequences[state.subtypeIndex]?.name;
        // Check if this is a founder sequence
        const isFounder = state.viewSequences[r].name && state.viewSequences[r].name.startsWith('consensus_of_');
        // Check if this is a PDB chain sequence (3D visualization only)
        const isPdbChain = isPdbChainSequence(state.viewSequences[r]);
        
        // Determine background and text colors based on grouping only
        let bgColor, textColor;
        const seqName = state.viewSequences[r].name;
        const groupId = state.sequenceGroups ? state.sequenceGroups.get(seqName) : undefined;
        
        // Set background color: use group color if grouping exists, otherwise default
        if(r === state.refIndex || isSubtype || isFounder || isPdbChain) {
            bgColor = '#fce7f3'; // Light magenta background for Reference, Subtype, Founder, and PDB chains
        } else if (groupId !== undefined) {
            // Use group color for background (groups sorted alphabetically, use palette index groupId + 1)
            const lightBgIndex = (groupId + 1) % GROUP_LIGHT_BG.length;
            const lightBgColor = GROUP_LIGHT_BG[lightBgIndex];
            bgColor = isSel ? '#eff6ff' : lightBgColor;
        } else {
            // Default background
            bgColor = isSel ? '#eff6ff' : (r%2===0 ? '#f9fafb' : '#fff');
        }
        
        // Set text color: use group color if grouping exists, otherwise default
        if(r === state.refIndex || isSubtype || isFounder || isPdbChain) {
            textColor = '#ff00ff'; // Magenta for Reference, Subtype, Founder, and PDB chains
        } else if (groupId !== undefined) {
            // Use group color for text (groups sorted alphabetically, use palette index groupId + 1)
            textColor = COLOR_PALETTE[(groupId + 1) % COLOR_PALETTE.length];
        } else {
            // Default text color
            textColor = isSel ? '#1e40af' : '#374151';
        }
        
        ctxNames.fillStyle = bgColor;
        ctxNames.fillRect(0, y, dom.cvsNames.width, CONFIG.rowHeight);
        
        if(r === state.refIndex) {
            ctxNames.font = "bold " + CONFIG.labelFont;
        } else if(isSubtype) {
            ctxNames.font = "bold " + CONFIG.labelFont;
        } else if(isFounder) {
            ctxNames.font = "bold " + CONFIG.labelFont;
        } else if(isPdbChain) {
            ctxNames.font = "bold " + CONFIG.labelFont;
        } else {
            ctxNames.font = CONFIG.labelFont;
        }
        
        // Draw sequence name with labels
        ctxNames.fillStyle = textColor;
        let label = isPdbChain ? getPdbChainDisplayLabel(state.viewSequences[r]) : state.viewSequences[r].name;
        if(r === state.refIndex) label += " [Reference]";
        if(isSubtype && state.subtypeIndex < state.rawSequences.length) {
            label += " [Subtype]";
        }
        if(isFounder) {
            label += " [Founder]";
        }
        ctxNames.fillText(label, 10, y + CONFIG.rowHeight/2);
    }
    
    // Update color legend
    updateColorLegend();

    // Ruler
    ctxRuler.fillStyle = '#f3f4f6'; ctxRuler.fillRect(0,0,dom.cvsRuler.width, dom.cvsRuler.height);
    ctxRuler.font = "10px sans-serif"; ctxRuler.textAlign = "center"; 
    
    const h = dom.cvsRuler.height;
    const mid = h / 2;

    ctxRuler.strokeStyle = '#e5e7eb';
    ctxRuler.beginPath(); ctxRuler.moveTo(0, mid); ctxRuler.lineTo(dom.cvsRuler.width, mid); ctxRuler.stroke();

    ctxRuler.strokeStyle = "#9ca3af";

    for(let c=startCol; c<endCol; c++) {
        // Skip columns not in the epitope
        if (!showColumn(c)) continue;
        
        const x = (c * CONFIG.charWidth) - scrollLeft + (CONFIG.charWidth/2);
        let isSel = state.selection && (c >= state.selection.c1 && c <= state.selection.c2);
        
        if(isSel) {
            ctxRuler.fillStyle = "rgba(37, 99, 235, 0.2)";
            ctxRuler.fillRect((c*CONFIG.charWidth)-scrollLeft, 0, CONFIG.charWidth, h);
        }

        // Top ruler: Reference coordinates (for defining epitopes)
        const refIdx = state.refMap[c];
        const prevRefIdx = (c > 0) ? state.refMap[c-1] : 0;
        
        if(refIdx !== prevRefIdx) {
            ctxRuler.fillStyle = "#2563eb"; 
            if(refIdx===1 || refIdx % CONFIG.rulerTickStep === 0) {
                ctxRuler.moveTo(x, 0); ctxRuler.lineTo(x, 15);
                // Position coordinate text slightly lower to avoid overlap with epitope start coords
                ctxRuler.fillText(refIdx, x, mid / 2 + 4);
            } else if(refIdx % (CONFIG.rulerTickStep/2)===0) {
                ctxRuler.moveTo(x, 0); ctxRuler.lineTo(x, 8);
            }
        }
        
        // Show epitope region boundaries on reference ruler
        if (state.selectedEpitope && state.epitopes.length > 0) {
            const epitope = state.epitopes.find(e => e.name === state.selectedEpitope);
            if (epitope) {
                for (const region of epitope.regions) {
                    // Check if this column corresponds to the start or end of a region
                    if (refIdx === region.start && refIdx !== prevRefIdx) {
                        // Start coordinate at the top
                        ctxRuler.fillStyle = "#dc2626"; // Red color for start
                        ctxRuler.font = "9px sans-serif";
                        ctxRuler.textAlign = "center";
                        ctxRuler.fillText(region.start.toString(), x, 10);
                    }
                    if (refIdx === region.end && refIdx !== prevRefIdx) {
                        // End coordinate at the bottom (just above the divider line)
                        ctxRuler.fillStyle = "#dc2626"; // Red color for end
                        ctxRuler.font = "9px sans-serif";
                        ctxRuler.textAlign = "center";
                        ctxRuler.fillText(region.end.toString(), x, mid - 5);
                    }
                }
            }
        }
        
        // Bottom ruler: Alignment positions (every 10th position, counting all positions including gaps)
        const alnIdx = c + 1;
        ctxRuler.fillStyle = "#6b7280";
        if(alnIdx===1 || alnIdx % CONFIG.rulerTickStep === 0) {
            ctxRuler.moveTo(x, mid + 15); ctxRuler.lineTo(x, h);
            ctxRuler.fillText(alnIdx, x, mid + 12);
        } else if(alnIdx % (CONFIG.rulerTickStep/2)===0) {
            ctxRuler.moveTo(x, mid + 22); ctxRuler.lineTo(x, h);
        }
    }
    ctxRuler.stroke();
    
    ctxRuler.fillStyle = "#2563eb"; ctxRuler.font = "9px sans-serif"; ctxRuler.textAlign = "left";
    ctxRuler.fillText("Ref", 2, 12);
    ctxRuler.fillStyle = "#6b7280";
    ctxRuler.fillText("Aln", 2, mid + 12);

    // Tree
    if(state.treeWidth > 0 && state.tree) {
        ctxTree.clearRect(0, 0, dom.cvsTree.width, dom.cvsTree.height);
        ctxTree.save();
        ctxTree.translate(0, -scrollTop);
        ctxTree.strokeStyle = '#374151';
        ctxTree.lineWidth = 1;

        const padding = 15;
        const availableW = dom.cvsTree.width - padding;
        const xScale = state.tree.maxDepth > 0 ? (availableW / state.tree.maxDepth) : 1;

        const drawNode = (node) => {
            if(node.hidden) return;
            const x = (node.xDepth * xScale) + 5;
            const y = (node.yRow * CONFIG.rowHeight) + (CONFIG.rowHeight/2);

            if(node.children && node.children.length > 0) {
                // Internal node - draw branches first
                let minY = Infinity, maxY = -Infinity;
                node.children.forEach(c => {
                    if(c.hidden) return;
                    drawNode(c);
                    const cx = (c.xDepth * xScale) + 5;
                    const cy = (c.yRow * CONFIG.rowHeight) + (CONFIG.rowHeight/2);
                    
                    ctxTree.beginPath();
                    ctxTree.moveTo(x, cy);
                    ctxTree.lineTo(cx, cy);
                    ctxTree.stroke();

                    if(cy < minY) minY = cy;
                    if(cy > maxY) maxY = cy;
                });

                if(minY !== Infinity) {
                    ctxTree.beginPath();
                    ctxTree.moveTo(x, minY);
                    ctxTree.lineTo(x, maxY);
                    ctxTree.stroke();
                }
                
                // Draw circle for internal node
                ctxTree.fillStyle = '#374151';
                ctxTree.beginPath();
                ctxTree.arc(x, y, 3, 0, 2 * Math.PI);
                ctxTree.fill();
            } else {
                // Leaf node - draw dotted line to names
                ctxTree.save();
                ctxTree.setLineDash([2, 4]);
                ctxTree.strokeStyle = '#d1d5db';
                ctxTree.beginPath();
                ctxTree.moveTo(x, y);
                ctxTree.lineTo(dom.cvsTree.width, y);
                ctxTree.stroke();
                ctxTree.restore();
                
                // Draw diamond for leaf node with cluster color if available
                let fillColor = '#374151'; // Default grey
                // Use original names (without cluster suffix) for subtype comparison and cluster lookup
                const delimiter = state.groupDelimiter || '_';
                const clusterPattern = new RegExp(`${delimiter.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}cl-(\\d+|na)$`);
                const originalNodeName = node.name ? node.name.replace(clusterPattern, '') : '';
                const subtypeOriginalName = (state.subtypeIndex >= 0 && state.subtypeIndex < state.rawSequences.length) 
                    ? state.rawSequences[state.subtypeIndex].name.replace(clusterPattern, '') 
                    : '';
                const isSubtype = state.subtypeIndex >= 0 && originalNodeName === subtypeOriginalName;
                
                // Check cluster color first (cluster 0 should be cyan even for subtype)
                if (state.leafClusters && node.name) {
                    // Try lookup with current name first (for MDS clustering after names are updated)
                    // Then try with original name (for hierarchical clustering before Accept is pressed)
                    let clusterId = state.leafClusters.get(node.name);
                    if (clusterId === undefined) {
                        clusterId = state.leafClusters.get(originalNodeName);
                    }
                    if (clusterId !== undefined && clusterId !== null) {
                        if (clusterId === -1) {
                            fillColor = '#9ca3af'; // Grey for noise
                        } else {
                            // Use cluster color palette (cyan for 0, GROUP_COLORS for 1+)
                            fillColor = getClusterColor(clusterId);
                        }
                    } else if (isSubtype) {
                        // Only use red for subtype if not in a cluster
                        fillColor = '#dc2626'; // Red for subtype
                    }
                } else if (isSubtype) {
                    // Only use red for subtype if no cluster information available
                    fillColor = '#dc2626'; // Red for subtype
                }
                
                ctxTree.fillStyle = fillColor;
                drawDiamond(ctxTree, x, y, 10); // Doubled from 5 to 10
            }
        };

        drawNode(state.tree.root);
        
        // Draw vertical lines for hierarchical clustering depths if active
        if (state.hierarchicalActive && state.hierarchicalDepths) {
            const [depth1, depth2, depth3] = state.hierarchicalDepths;
            // Calculate the full height of all sequences in the translated coordinate system
            const totalHeight = state.viewSequences.length * CONFIG.rowHeight;
            // Start from top (y=0 in translated coordinates) and go to bottom
            const startY = 0;
            const endY = totalHeight;
            
            ctxTree.save();
            ctxTree.strokeStyle = '#ef4444'; // Red color for level 1
            ctxTree.lineWidth = 1.5;
            ctxTree.setLineDash([]);
            if (depth1 > 0) {
                const x1 = (depth1 * xScale) + 5;
                ctxTree.beginPath();
                ctxTree.moveTo(x1, startY);
                ctxTree.lineTo(x1, endY);
                ctxTree.stroke();
            }
            
            ctxTree.strokeStyle = '#f59e0b'; // Orange color for level 2
            if (depth2 > depth1) {
                const x2 = (depth2 * xScale) + 5;
                ctxTree.beginPath();
                ctxTree.moveTo(x2, startY);
                ctxTree.lineTo(x2, endY);
                ctxTree.stroke();
            }
            
            ctxTree.strokeStyle = '#10b981'; // Green color for level 3
            if (depth3 > depth2) {
                const x3 = (depth3 * xScale) + 5;
                ctxTree.beginPath();
                ctxTree.moveTo(x3, startY);
                ctxTree.lineTo(x3, endY);
                ctxTree.stroke();
            }
        ctxTree.restore();
    }
        
        ctxTree.restore();
    }
}

// --- PDB 3D Viewer (3Dmol.js: epitope = residue colors, rest = gray) ---
let pdb3dViewerInstance = null;
var pdb3dCurrentStyle = 'cartoon';
var pdb3dCurrentStyleIntrinsic = 'cartoon';
var pdb3dCurrentStyleExtrinsic = 'cartoon';
var pdb3dCurrentStyleSuperficial = 'sphere';
var pdb3dIntrinsicChainIds = [];
var pdb3dExtrinsicChainIds = [];
var pdb3dSuperficialChainIds = [];
var pdb3dSelectedChainIds = [];

const PDB_RESIDUE_TO_ONE = {
    'ALA':'A','ARG':'R','ASN':'N','ASP':'D','CYS':'C','GLN':'Q','GLU':'E','GLY':'G','HIS':'H',
    'ILE':'I','LEU':'L','LYS':'K','MET':'M','PHE':'F','PRO':'P','SER':'S','THR':'T','TRP':'W',
    'TYR':'Y','VAL':'V','SEC':'U','PYL':'O','UNK':'X','MSE':'M','HOH':'','WAT':'','NAG':'','CL':''
};

/** Returns { chains: [ { id, seq } ], flat } — seq per chain and concatenated flat array. */
function parsePdbSequence(pdbText) {
    const lines = (pdbText || '').split(/\r?\n/);
    const byChain = new Map(); // chainId -> [{ resSeq, resName }]
    for (const line of lines) {
        if (line.startsWith('ATOM ') || line.startsWith('HETATM ')) {
            const resName = (line.substring(17, 20) || '').trim();
            const one = PDB_RESIDUE_TO_ONE[resName];
            if (one === '') continue; // skip water/ligand
            const chain = (line.substring(21, 22) || ' ').trim() || 'A';
            const resSeq = parseInt(line.substring(22, 26), 10) || 0;
            if (!byChain.has(chain)) byChain.set(chain, []);
            const arr = byChain.get(chain);
            const last = arr.length ? arr[arr.length - 1] : null;
            if (!last || last.resSeq !== resSeq) arr.push({ resSeq, resName: one || 'X' });
        }
    }
    const chainIds = Array.from(byChain.keys()).sort();
    const chains = [];
    const flat = [];
    for (const c of chainIds) {
        const arr = byChain.get(c).sort((a, b) => a.resSeq - b.resSeq);
        const seq = arr.map(r => r.resName);
        chains.push({ id: c, seq });
        flat.push(...seq);
    }
    return { chains, flat };
}

/** Detect if structure text is CIF (mmCIF). */
function isCifStructure(text) {
    var t = (text || '').trim();
    return t.startsWith('data_') || (t.indexOf('loop_') !== -1 && t.indexOf('_atom_site') !== -1);
}

/** Parse mmCIF _atom_site loop; return same shape as parsePdbSequence: { chains, flat }. */
function parseCifSequence(cifText) {
    var lines = (cifText || '').split(/\r?\n/);
    var byChain = new Map();
    var chainOrder = [];
    var colChain = -1, colSeq = -1, colComp = -1;
    var inAtomSite = false;
    var columns = [];
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        var trimmed = line.trim();
        if (trimmed.startsWith('loop_')) {
            inAtomSite = false;
            columns = [];
            colChain = colSeq = colComp = -1;
            continue;
        }
        if (trimmed.startsWith('_atom_site.')) {
            var name = trimmed.slice(11).split(/\s/)[0];
            columns.push(name);
            if (name === 'label_asym_id' || name === 'auth_asym_id') colChain = columns.length - 1;
            if (name === 'label_seq_id' || name === 'auth_seq_id') colSeq = columns.length - 1;
            if (name === 'label_comp_id' || name === 'auth_comp_id') colComp = columns.length - 1;
            inAtomSite = true;
            continue;
        }
        if (inAtomSite && columns.length > 0 && colChain >= 0 && colSeq >= 0 && colComp >= 0) {
            if (trimmed.startsWith('_') || trimmed === '' || trimmed.startsWith('#')) {
                inAtomSite = false;
                continue;
            }
            var parts = line.split(/\s+/);
            if (parts.length < columns.length) continue;
            var resName = (parts[colComp] || '').trim().slice(0, 3);
            var one = PDB_RESIDUE_TO_ONE[resName];
            if (one === '') continue;
            var chain = (parts[colChain] || 'A').trim() || 'A';
            var resSeq = parseInt(parts[colSeq], 10) || 0;
            if (!byChain.has(chain)) {
                byChain.set(chain, []);
                chainOrder.push(chain);
            }
            var arr = byChain.get(chain);
            var last = arr.length ? arr[arr.length - 1] : null;
            if (!last || last.resSeq !== resSeq) arr.push({ resSeq: resSeq, resName: one || 'X' });
        }
    }
    var chainIds = chainOrder.length ? chainOrder : Array.from(byChain.keys()).sort();
    var chains = [];
    var flat = [];
    for (var c = 0; c < chainIds.length; c++) {
        var id = chainIds[c];
        var arr = (byChain.get(id) || []).sort(function (a, b) { return a.resSeq - b.resSeq; });
        var seq = arr.map(function (r) { return r.resName; });
        chains.push({ id: id, seq: seq });
        flat.push.apply(flat, seq);
    }
    return { chains: chains, flat: flat };
}

/** Get structure code from PDB HEADER or CIF data_/ _entry.id. */
function structureCodeFromContent(text) {
    if (isCifStructure(text)) {
        var lines = (text || '').split(/\r?\n/);
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i].trim();
            if (line.startsWith('data_')) {
                var code = line.slice(5).trim().split(/\s/)[0];
                if (code && code.length >= 4) return code.slice(0, 4).toUpperCase();
            }
            if (line === '_entry.id' && i + 1 < lines.length) {
                var val = lines[i + 1].trim().split(/\s/)[0];
                if (val && val.length >= 4) return val.slice(0, 4).toUpperCase();
            }
        }
        return 'UNKN';
    }
    return pdbCodeFromHeader(text);
}

function parseFastaToSeqs(text) {
    const lines = (text || '').split(/\r?\n/);
    const seqs = [];
    let name = null, buf = [];
    for (const line of lines) {
        const t = line.trim();
        if (!t) continue;
        if (t.startsWith('>')) {
            if (name) seqs.push({ name, seq: buf.join('').toUpperCase().replace(/[^A-Z.-]/g, '').split('') });
            name = t.substring(1).trim();
            buf = [];
        } else {
            buf.push(t.toUpperCase().replace(/[^A-Z.-]/g, ''));
        }
    }
    if (name) seqs.push({ name, seq: buf.join('').toUpperCase().replace(/[^A-Z.-]/g, '').split('') });
    return seqs;
}

/** Smith-Waterman local alignment. Returns { alignedRef, alignedChain, refStart, refEnd } (refStart/refEnd are 0-based in refNoGaps). */
function smithWatermanLocal(refStr, chainStr, gapOpen, gapExtend, matchCost, mismatchCost) {
    const r = refStr.split('');
    const c = chainStr.split('');
    const R = r.length, C = c.length;
    const H = Array(R + 1).fill(0).map(() => Array(C + 1).fill(0));
    const ptr = Array(R + 1).fill(0).map(() => Array(C + 1).fill(0)); // 1=diag, 2=up, 3=left
    let bestScore = 0, bestI = 0, bestJ = 0;
    for (let i = 1; i <= R; i++) {
        for (let j = 1; j <= C; j++) {
            const match = (r[i - 1] === c[j - 1]) ? matchCost : mismatchCost;
            const diag = H[i - 1][j - 1] + match;
            const up = H[i - 1][j] + (ptr[i - 1][j] === 2 ? gapExtend : gapOpen);
            const left = H[i][j - 1] + (ptr[i][j - 1] === 3 ? gapExtend : gapOpen);
            const max = Math.max(0, diag, up, left);
            H[i][j] = max;
            if (max === diag) ptr[i][j] = 1;
            else if (max === up) ptr[i][j] = 2;
            else if (max === left) ptr[i][j] = 3;
            if (max > bestScore) { bestScore = max; bestI = i; bestJ = j; }
        }
    }
    if (bestScore <= 0) return { alignedRef: '', alignedChain: '', refStart: -1, refEnd: -1, chainStart: -1, chainEnd: -1 };
    const outR = [], outC = [];
    let i = bestI, j = bestJ;
    let refStart = R, refEnd = -1;
    let chainStart = Infinity, chainEnd = -1;
    while (i > 0 && j > 0 && H[i][j] > 0) {
        const refIdx = i - 1;
        if (ptr[i][j] === 1) {
            outR.push(r[refIdx]); outC.push(c[j - 1]);
            refStart = Math.min(refStart, refIdx); refEnd = Math.max(refEnd, refIdx);
            chainStart = Math.min(chainStart, j - 1); chainEnd = Math.max(chainEnd, j - 1);
            i--; j--;
        } else if (ptr[i][j] === 2) {
            outR.push(r[refIdx]); outC.push('-');
            refStart = Math.min(refStart, refIdx); refEnd = Math.max(refEnd, refIdx);
            i--;
        } else {
            outR.push('-'); outC.push(c[j - 1]);
            chainStart = Math.min(chainStart, j - 1); chainEnd = Math.max(chainEnd, j - 1);
            j--;
        }
    }
    outR.reverse(); outC.reverse();
    if (chainStart === Infinity) chainStart = -1;
    return { alignedRef: outR.join(''), alignedChain: outC.join(''), refStart: refStart <= refEnd ? refStart : -1, refEnd, chainStart, chainEnd };
}

/** Align one chain to reference using local alignment; returns { row, minCol, maxCol } (row length = refSeqArr.length). */
function alignOneChainToRef(refSeqArr, chainSeq) {
    const refNoGaps = refSeqArr.filter(c => c !== '-' && c !== '.').join('');
    const row = Array(refSeqArr.length).fill('-');
    if (!refNoGaps.length || !chainSeq.length) return { row, minCol: -1, maxCol: -1 };
    const chainStr = (typeof chainSeq === 'string') ? chainSeq : chainSeq.join('');
    const gapOpen = -10, gapExtend = -0.5, matchCost = 1, mismatchCost = -0.7;
    const local = smithWatermanLocal(refNoGaps, chainStr, gapOpen, gapExtend, matchCost, mismatchCost);
    if (local.refStart < 0 || local.refEnd < 0) return { row, minCol: -1, maxCol: -1, chainStart: 0 };
    const { alignedRef, alignedChain, refStart, refEnd, chainStart } = local;
    const outR = alignedRef.split('');
    const outC = alignedChain.split('');
    const refIdxToCol = [];
    let refIdx = 0;
    for (let i = 0; i < refSeqArr.length; i++) {
        if (refSeqArr[i] !== '-' && refSeqArr[i] !== '.') {
            refIdxToCol[refIdx] = i;
            refIdx++;
        }
    }
    let j = 0;
    let minCol = -1, maxCol = -1;
    for (let k = 0; k < outR.length; k++) {
        if (outR[k] !== '-') {
            const col = refIdxToCol[refStart + j];
            if (col !== undefined && outC[k] !== '-') {
                row[col] = outC[k];
                if (minCol < 0) minCol = col;
                maxCol = col;
            }
            j++;
        }
    }
    return { row, minCol, maxCol, chainStart: chainStart >= 0 ? chainStart : 0 };
}

/** 1-based reference coordinate at alignment column col (count of non-gap ref residues up to col inclusive). */
function refCoordAtCol(refSeqArr, col) {
    let c = 0;
    for (let i = 0; i <= col && i < refSeqArr.length; i++) {
        if (refSeqArr[i] !== '-' && refSeqArr[i] !== '.') c++;
    }
    return c;
}

/** Extract 4-character PDB code from HEADER record in PDB file contents (columns 63-66). */
function pdbCodeFromHeader(pdbText) {
    const lines = (pdbText || '').split(/\r?\n/);
    for (const line of lines) {
        if (line.startsWith('HEADER')) {
            const code = (line.substring(62, 66) || '').trim().toUpperCase();
            if (code.length === 4 && /^[A-Z0-9]{4}$/.test(code)) {
                return code;
            }
            const padded = (code + '____').slice(0, 4).replace(/[^A-Z0-9]/g, '_');
            return padded;
        }
    }
    return 'UNKN';
}

/** True if the argument is a PDB chain sequence (name string or seq object with isPdbChain). These are for 3D only; exclude from sort/group/tree. */
function isPdbChainSequence(nameOrSeq) {
    if (nameOrSeq && typeof nameOrSeq === 'object' && nameOrSeq.isPdbChain === true) return true;
    return typeof nameOrSeq === 'string' && /^[A-Za-z0-9]+_Chain_[A-Za-z0-9]+$/.test(nameOrSeq);
}

/** Display label for a PDB chain sequence: "xxxx_Chain_y [PDB_y]" optionally with " (n%)" where n = 100 * alignedLength/chainLength (0-100, no decimals). nameOrSeq can be string or seq object with .name, optional .alignedLength and .chainLength. */
function getPdbChainDisplayLabel(nameOrSeq) {
    var name = (nameOrSeq && typeof nameOrSeq === 'object' && nameOrSeq.name) ? nameOrSeq.name : nameOrSeq;
    if (typeof name !== 'string') return name;
    var m = name.match(/^(.+)_Chain_(.+)$/);
    var base = m ? name + ' [PDB_' + m[2] + ']' : name;
    if (nameOrSeq && typeof nameOrSeq === 'object' && typeof nameOrSeq.chainLength === 'number') {
        if (typeof nameOrSeq.alignedLength === 'number' && nameOrSeq.chainLength > 0) {
            var pct = Math.round(100 * nameOrSeq.alignedLength / nameOrSeq.chainLength);
            pct = Math.min(100, Math.max(0, pct));
            base += ' (' + pct + '%)';
        } else {
            base += ' (' + nameOrSeq.chainLength + ' aa)';
        }
    }
    return base;
}

/** Chain IDs that appear in the sequence panels (from PDB sequence names). Used to restrict 3D viewer to aligned chains only. */
function getPdbChainIdsInState() {
    if (!state.rawSequences) return [];
    return state.rawSequences.filter(function (s) { return isPdbChainSequence(s); }).map(function (s) {
        var m = (s.name || '').match(/^.+_Chain_(.+)$/);
        return m ? m[1] : null;
    }).filter(Boolean);
}

/** Partition PDB chain IDs into intrinsic (alignment % >= 50) and extrinsic (% < 50). Chains without alignedLength/chainLength go to intrinsic. */
function getPdbChainIntrinsicExtrinsicPartition() {
    var intrinsic = [], extrinsic = [];
    if (!state.rawSequences) return { intrinsic: intrinsic, extrinsic: extrinsic };
    state.rawSequences.forEach(function (s) {
        if (!isPdbChainSequence(s)) return;
        var m = (s.name || '').match(/^.+_Chain_(.+)$/);
        if (!m) return;
        var chainId = m[1];
        var pct = 50;
        if (typeof s.alignedLength === 'number' && typeof s.chainLength === 'number' && s.chainLength > 0) {
            pct = Math.round(100 * s.alignedLength / s.chainLength);
            pct = Math.min(100, Math.max(0, pct));
        }
        if (pct >= 50) intrinsic.push(chainId); else extrinsic.push(chainId);
    });
    return { intrinsic: intrinsic, extrinsic: extrinsic };
}

/** Align each PDB chain to reference with local alignment; return array of { name, seq, chainStart, isPdbChain, chainLength, alignedLength } (one per chain). alignedLength = AAs from chain that end up in the panel; chainLength = total AAs in chain. */
function alignChainsToReferenceSequences(refSeqArr, chains, pdbCode) {
    if (!refSeqArr.length) return [];
    const refLen = refSeqArr.length;
    const aligned = [];
    for (const ch of chains) {
        if (!ch.seq || !ch.seq.length) continue;
        const { row, minCol, maxCol, chainStart } = alignOneChainToRef(refSeqArr, ch.seq);
        if (minCol >= 0) {
            const startRefCoord = refCoordAtCol(refSeqArr, minCol);
            const endRefCoord = refCoordAtCol(refSeqArr, maxCol);
            console.log('PDB chain local alignment: chain=', ch.id, 'startRefCoord=', startRefCoord, 'endRefCoord=', endRefCoord, 'chainStart_0based=', chainStart);
            var chainLength = (ch.seq && ch.seq.length) ? ch.seq.length : 0;
            var alignedLength = 0;
            for (var col = minCol; col <= maxCol; col++) {
                var c = row[col];
                if (c !== '-' && c !== '.' && c !== undefined) alignedLength++;
            }
            aligned.push({ id: ch.id, row, minCol, maxCol, chainStart: chainStart >= 0 ? chainStart : 0, chainLength: chainLength, alignedLength: alignedLength });
        }
    }
    aligned.sort((a, b) => a.minCol - b.minCol);
    return aligned.map(a => ({
        name: pdbCode + '_Chain_' + a.id,
        seq: a.row,
        chainStart: a.chainStart,
        isPdbChain: true,
        chainLength: a.chainLength,
        alignedLength: a.alignedLength
    }));
}

function applyStructureContent(text, fileName, format) {
    var isCif = format === 'cif' || isCifStructure(text);
    var chains, flat;
    if (isCif) {
        var parsed = parseCifSequence(text);
        chains = parsed.chains;
        flat = parsed.flat;
    } else {
        var p = parsePdbSequence(text);
        chains = p.chains;
        flat = p.flat;
    }
    if (!flat || !flat.length) {
        alert('No amino acid sequence found in the structure file.');
        return false;
    }
    state.pdbFileContent = text;
    state.pdbFileName = fileName || 'structure.pdb';
    state.pdbFormat = isCif ? 'cif' : 'pdb';
    setMode('AA', state.isAASequence);
    var subtypeName = state.rawSequences[state.subtypeIndex] ? state.rawSequences[state.subtypeIndex].name : null;
    var pdbCode = structureCodeFromContent(text);
    var raw = state.rawSequences.filter(function (s) { return !isPdbChainSequence(s); });
    if (raw.length === 0) {
        var maxLen = Math.max.apply(null, chains.map(function (ch) { return (ch.seq && ch.seq.length) || 0; }));
        var pdbSeqs = chains.map(function (ch) {
            var seq = (ch.seq || []).slice();
            while (seq.length < maxLen) seq.push('-');
            var chainLength = (ch.seq && ch.seq.length) ? ch.seq.length : 0;
            return { name: pdbCode + '_Chain_' + ch.id, seq: seq, isPdbChain: true, chainLength: chainLength };
        });
        state.rawSequences = pdbSeqs.length ? pdbSeqs : [{ name: pdbCode + '_Chain_?', seq: flat, isPdbChain: true, chainLength: (flat && flat.length) ? flat.length : 0 }];
        state.refIndex = 0;
        state.subtypeIndex = 0;
    } else {
        showOverlay(true);
        if (dom.overlayMsg) dom.overlayMsg.textContent = 'Aligning structure chains to reference...';
        if (dom.overlaySub) dom.overlaySub.textContent = '';
        var refSeq = (raw[0] && raw[0].seq) ? raw[0].seq : [];
        var pdbEntries = alignChainsToReferenceSequences(refSeq, chains, pdbCode);
        for (var i = 0; i < pdbEntries.length; i++) {
            raw.splice(1 + i, 0, pdbEntries[i]);
        }
        state.rawSequences = raw;
        state.refIndex = 0;
        var newSubtypeIdx = raw.findIndex(function (s) { return s.name === subtypeName; });
        state.subtypeIndex = newSubtypeIdx >= 0 ? newSubtypeIdx : 0;
        showOverlay(false);
    }
    state.viewSequences = state.rawSequences.slice();
    state.selection = null;
    calculateNamesWidth();
    recalc();
    return true;
}

function loadPdbFile(file) {
    if (!file) return;
    var reader = new FileReader();
    reader.onload = function () {
        var text = reader.result;
        var format = (file.name || '').toLowerCase().endsWith('.cif') ? 'cif' : 'pdb';
        if (applyStructureContent(text, file.name || 'structure.pdb', format)) {
            if (dom.inpPdb) dom.inpPdb.value = '';
        }
    };
    reader.onerror = function () {
        alert('Could not read the structure file.');
        if (dom.inpPdb) dom.inpPdb.value = '';
    };
    reader.readAsText(file);
}

function loadPdbById(code) {
    code = (code || '').trim().toUpperCase().slice(0, 4);
    if (!/^[A-Z0-9]{4}$/.test(code)) return;
    showOverlay(true);
    if (dom.overlayMsg) dom.overlayMsg.textContent = 'Fetching from RCSB PDB...';
    if (dom.overlaySub) dom.overlaySub.textContent = code;
    function tryFormat(ext, format) {
        return fetch('https://files.rcsb.org/download/' + code + ext)
            .then(function (r) { return r.ok ? r.text() : null; })
            .then(function (text) {
                if (text && applyStructureContent(text, code + ext, format)) {
                    if (dom.inpPdbId) dom.inpPdbId.value = code;
                    return true;
                }
                return false;
            });
    }
    tryFormat('.cif', 'cif').then(function (ok) {
        if (ok) { showOverlay(false); return; }
        return tryFormat('.pdb', 'pdb').then(function (ok2) {
            if (ok2) { showOverlay(false); return; }
            if (dom.overlayMsg) dom.overlayMsg.textContent = 'Structure not found.';
            if (dom.overlaySub) dom.overlaySub.textContent = 'Check the PDB ID or try again.';
            setTimeout(function () { showOverlay(false); }, 2000);
        });
    }).catch(function () {
        if (dom.overlayMsg) dom.overlayMsg.textContent = 'Fetch failed.';
        if (dom.overlaySub) dom.overlaySub.textContent = 'Check your connection.';
        setTimeout(function () { showOverlay(false); }, 2000);
    });
}

function closePdbViewer() {
    if (!dom.pdbOverlay) return;
    dom.pdbOverlay.style.display = 'none';
    if (pdb3dViewerInstance && dom.pdbViewerContainer) {
        if (typeof pdb3dViewerInstance.destroy === 'function') pdb3dViewerInstance.destroy();
        else if (typeof pdb3dViewerInstance.dispose === 'function') pdb3dViewerInstance.dispose();
        dom.pdbViewerContainer.innerHTML = '';
        pdb3dViewerInstance = null;
    }
}

/** Make element draggable by its handle. Element must have position: fixed and initial left/top set. */
function makeDraggable(element, handle) {
    if (!element || !handle) return;
    handle.addEventListener('mousedown', function (e) {
        if (e.button !== 0) return;
        e.preventDefault();
        const rect = element.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        const offsetY = e.clientY - rect.top;
        function onMove(ev) {
            element.style.left = (ev.clientX - offsetX) + 'px';
            element.style.top = (ev.clientY - offsetY) + 'px';
        }
        function onUp() {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
        }
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
    });
}

/** Return sorted list of chain IDs that contain at least one amino-acid residue (same logic as sequence extraction). */
function getPdbChainIds(pdbText) {
    const seen = new Set();
    const lines = (pdbText || '').split(/\r?\n/);
    for (const line of lines) {
        if (line.startsWith('ATOM ') || line.startsWith('HETATM ')) {
            const resName = (line.substring(17, 20) || '').trim();
            const one = PDB_RESIDUE_TO_ONE[resName];
            if (one === '') continue; // skip water/ligand so list matches sequence chains
            const ch = (line.substring(21, 22) || ' ').trim() || 'A';
            seen.add(ch);
        }
    }
    return Array.from(seen).sort();
}

/** Return chain IDs from CIF (same order as parseCifSequence). */
function getCifChainIds(cifText) {
    var result = parseCifSequence(cifText);
    return result.chains.map(function (ch) { return ch.id; });
}

/** Return per-chain resSeq lists from CIF (same order as parseCifSequence). */
function getCifChainResSeqLists(cifText) {
    var lines = (cifText || '').split(/\r?\n/);
    var byChain = new Map();
    var chainOrder = [];
    var colChain = -1, colSeq = -1, colComp = -1;
    var inAtomSite = false;
    var columns = [];
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        var trimmed = line.trim();
        if (trimmed.startsWith('loop_')) {
            inAtomSite = false;
            columns = [];
            colChain = colSeq = colComp = -1;
            continue;
        }
        if (trimmed.startsWith('_atom_site.')) {
            var name = trimmed.slice(11).split(/\s/)[0];
            columns.push(name);
            if (name === 'label_asym_id' || name === 'auth_asym_id') colChain = columns.length - 1;
            if (name === 'label_seq_id' || name === 'auth_seq_id') colSeq = columns.length - 1;
            if (name === 'label_comp_id' || name === 'auth_comp_id') colComp = columns.length - 1;
            inAtomSite = true;
            continue;
        }
        if (inAtomSite && columns.length > 0 && colChain >= 0 && colSeq >= 0 && colComp >= 0) {
            if (trimmed.startsWith('_') || trimmed === '' || trimmed.startsWith('#')) {
                inAtomSite = false;
                continue;
            }
            var parts = line.split(/\s+/);
            if (parts.length < columns.length) continue;
            var resName = (parts[colComp] || '').trim().slice(0, 3);
            if (PDB_RESIDUE_TO_ONE[resName] === '') continue;
            var chain = (parts[colChain] || 'A').trim() || 'A';
            var resSeq = parseInt(parts[colSeq], 10) || 0;
            if (!byChain.has(chain)) {
                byChain.set(chain, []);
                chainOrder.push(chain);
            }
            var arr = byChain.get(chain);
            var last = arr.length ? arr[arr.length - 1] : null;
            if (!last || last !== resSeq) arr.push(resSeq);
        }
    }
    var out = new Map();
    for (var c = 0; c < chainOrder.length; c++) {
        var id = chainOrder[c];
        var arr = (byChain.get(id) || []).sort(function (a, b) { return a - b; });
        out.set(id, arr);
    }
    return out;
}

/** Filter CIF _atom_site rows to only include given chain IDs; output valid CIF. */
function filterCifByChains(cifText, chainIds) {
    var set = new Set(chainIds);
    var lines = (cifText || '').split(/\r?\n/);
    var colChain = -1;
    var inAtomSite = false;
    var columns = [];
    var out = [];
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        var trimmed = line.trim();
        if (trimmed.startsWith('loop_')) {
            inAtomSite = false;
            columns = [];
            colChain = -1;
            out.push(line);
            continue;
        }
        if (trimmed.startsWith('_atom_site.')) {
            var name = trimmed.slice(11).split(/\s/)[0];
            columns.push(name);
            if (name === 'label_asym_id' || name === 'auth_asym_id') colChain = columns.length - 1;
            inAtomSite = true;
            out.push(line);
            continue;
        }
        if (inAtomSite && columns.length > 0 && colChain >= 0) {
            if (trimmed.startsWith('_') || trimmed === '' || trimmed.startsWith('#')) {
                inAtomSite = false;
                out.push(line);
                continue;
            }
            var parts = line.split(/\s+/);
            if (parts.length >= columns.length && set.has((parts[colChain] || '').trim())) {
                out.push(line);
            }
            continue;
        }
        out.push(line);
    }
    return out.join('\n');
}

/** Return chain IDs from structure (PDB or CIF). */
function getStructureChainIds(text) {
    return isCifStructure(text) ? getCifChainIds(text) : getPdbChainIds(text);
}

/** Per-chain resSeq lists from structure (PDB or CIF). */
function getStructureChainResSeqLists(text) {
    return isCifStructure(text) ? getCifChainResSeqLists(text) : getPdbChainResSeqLists(text);
}

/** Filter structure to given chains (PDB or CIF). */
function filterStructureByChains(text, chainIds) {
    return isCifStructure(text) ? filterCifByChains(text, chainIds) : filterPdbByChains(text, chainIds);
}

/** Filter PDB text to only include ATOM/HETATM lines for the given chain IDs. */
function filterPdbByChains(pdbText, chainIds) {
    const set = new Set(chainIds);
    const lines = (pdbText || '').split(/\r?\n/);
    const out = [];
    for (const line of lines) {
        if (line.startsWith('ATOM ') || line.startsWith('HETATM ')) {
            const ch = (line.substring(21, 22) || ' ').trim() || 'A';
            if (set.has(ch)) out.push(line);
        } else {
            out.push(line);
        }
    }
    return out.join('\n');
}

/** Color by amino acid (residue): use CONFIG.colors.AA from alignment view. Atom.resn is 3-letter code. */
function pdb3dColorByResidue(atom) {
    const one = (PDB_RESIDUE_TO_ONE[atom.resn] || 'X').toUpperCase();
    const hex = (CONFIG.colors.AA[one] || CONFIG.colors.AA['default'] || '#ffffff').replace(/^#/, '');
    return parseInt(hex, 16);
}

const PDB3D_EPITOPE_GRAY = 0x9e9e9e; // neutral gray for non-epitope residues in sphere mode
let pdb3dShowAAs = false;
let pdb3dAALabels = []; // labels for epitope residues when Show AAs is on

/** Reference coordinate for PDB residue (chainId, resSeq), or null if not in alignment. Uses same row→resSeq mapping as getPdb3dEpitopeResidues (chainStart + residue index in row). */
function getRefCoordForPdbResidue(chainId, resSeq) {
    if (!state.viewSequences || !state.refMap) return null;
    const resSeqLists = getStructureChainResSeqLists(state.pdbFileContent);
    const resSeqs = resSeqLists.get(chainId);
    if (!resSeqs) return null;
    const resSeqNum = parseInt(resSeq, 10);
    for (const view of state.viewSequences) {
        const m = (view.name || '').match(/^[A-Za-z0-9]+_Chain_(.+)$/);
        if (!m || m[1] !== chainId) continue;
        const row = view.seq || [];
        const chainStart = (view.chainStart != null && view.chainStart >= 0) ? view.chainStart : 0;
        for (let col = 0; col < row.length && col < state.refMap.length; col++) {
            if (row[col] === '-' || row[col] === '.') continue;
            const residueIndexInRow = pdbRowResidueIndexAtColumn(row, col);
            const fullChainIndex = chainStart + residueIndexInRow;
            if (fullChainIndex < 0 || fullChainIndex >= resSeqs.length) continue;
            if (resSeqs[fullChainIndex] === resSeqNum) {
                return state.refMap[col];
            }
        }
    }
    return null;
}

/** Per chain, ordered list of resSeq (same order as parsePdbSequence: sorted by resSeq so alignment row index matches). */
function getPdbChainResSeqLists(pdbText) {
    const byChain = new Map(); // chainId -> Set or list of resSeq (we'll sort to match parsePdbSequence)
    const lines = (pdbText || '').split(/\r?\n/);
    for (const line of lines) {
        if (line.startsWith('ATOM ') || line.startsWith('HETATM ')) {
            const resName = (line.substring(17, 20) || '').trim();
            const one = PDB_RESIDUE_TO_ONE[resName];
            if (one === '') continue;
            const ch = (line.substring(21, 22) || ' ').trim() || 'A';
            const resSeq = parseInt(line.substring(22, 26), 10) || 0;
            if (!byChain.has(ch)) byChain.set(ch, []);
            const arr = byChain.get(ch);
            const last = arr.length ? arr[arr.length - 1] : null;
            if (!last || last !== resSeq) arr.push(resSeq);
        }
    }
    // parsePdbSequence sorts each chain by resSeq; alignment row order is that order. Sort so residueIndex matches.
    const out = new Map();
    for (const [ch, arr] of byChain) {
        out.set(ch, arr.slice().sort((a, b) => a - b));
    }
    return out;
}

/** 0-based index of the PDB residue at alignment column col (count of non-gaps in row from 0 to col inclusive, minus 1). */
function pdbRowResidueIndexAtColumn(row, col) {
    let count = 0;
    for (let i = 0; i <= col && i < row.length; i++) {
        if (row[i] !== '-' && row[i] !== '.') count++;
    }
    return count > 0 ? count - 1 : -1;
}

/** Normalize to 1-letter code for comparison (handles 1-letter or 3-letter in view). */
function normToOneLetter(c) {
    if (c == null || c === '-' || c === '.') return null;
    const s = String(c).trim();
    if (s.length === 1) return s.toUpperCase();
    return (PDB_RESIDUE_TO_ONE[s] || '').toUpperCase() || null;
}

/** Residues in the selected epitope and their reference coordinate. Only consider columns where the REFERENCE has a residue (not a gap) AND this is the first column for that ref coord (refMap[col] !== refMap[col-1]). Add every PDB chain residue at those columns (show residues and labels irrespective of match with reference). Same set is used for sphere coloring and labels. */
function getPdb3dEpitopeResidues() {
    if (!state.selectedEpitope || !state.epitopeColumns || state.epitopeColumns.size === 0 || !state.viewSequences || !state.refMap) return null;
    const refView = state.viewSequences[state.refIndex];
    const refSeq = refView && refView.seq ? refView.seq : [];
    const resSeqLists = getStructureChainResSeqLists(state.pdbFileContent);
    const residues = new Set();
    const refCoordByKey = new Map();
    for (const col of state.epitopeColumns) {
        if (col >= refSeq.length || col >= state.refMap.length) continue;
        if (refSeq[col] === '-' || refSeq[col] === '.') continue;
        if (col > 0 && state.refMap[col] === state.refMap[col - 1]) continue;
        const refCoord = state.refMap[col];
        for (const view of state.viewSequences) {
            const name = view.name || '';
            const m = name.match(/^[A-Za-z0-9]+_Chain_(.+)$/);
            if (!m) continue;
            const chainId = m[1];
            const row = view.seq || [];
            if (col >= row.length || row[col] === '-' || row[col] === '.') continue;
            const rowChar = normToOneLetter(row[col]);
            if (rowChar === null || rowChar === '') continue;
            const residueIndex = pdbRowResidueIndexAtColumn(row, col);
            const chainStart = (view.chainStart != null && view.chainStart >= 0) ? view.chainStart : 0;
            const fullChainIndex = chainStart + residueIndex;
            const resSeqs = resSeqLists.get(chainId);
            if (!resSeqs || fullChainIndex < 0 || fullChainIndex >= resSeqs.length) continue;
            const pdbResSeq = resSeqs[fullChainIndex];
            const key = chainId + ':' + pdbResSeq;
            residues.add(key);
            refCoordByKey.set(key, refCoord);
        }
    }
    return residues.size ? { residues, refCoordByKey } : null;
}

/** Return 3Dmol style spec. Sphere: if epitope selected, only color epitope residues (amino colors), others gray. */
function getPdb3dStyleSpec(styleKey, epitopeResidues) {
    const gray = PDB3D_EPITOPE_GRAY;
    let style;
    switch (String(styleKey).toLowerCase()) {
        case 'sphere': {
            const resSet = epitopeResidues && epitopeResidues.residues ? epitopeResidues.residues : (epitopeResidues && epitopeResidues.size ? epitopeResidues : null);
            if (resSet && resSet.size > 0) {
                style = {
                    sphere: {
                        colorfunc: function (atom) {
                            var ch = (atom.chain || ' ').trim() || 'A';
                            var key = ch + ':' + String(atom.resi);
                            return resSet.has(key) ? pdb3dColorByResidue(atom) : gray;
                        }
                    }
                };
            } else {
                style = { sphere: { colorfunc: pdb3dColorByResidue } };
            }
            break;
        }
        case 'stick':
        case 'line':
        case 'trace':
        case 'cross': {
            var resSetOther = epitopeResidues && epitopeResidues.residues ? epitopeResidues.residues : (epitopeResidues && epitopeResidues.size ? epitopeResidues : null);
            var subStyle = styleKey === 'stick' ? 'stick' : styleKey === 'line' ? 'line' : styleKey === 'trace' ? 'trace' : 'cross';
            if (resSetOther && resSetOther.size > 0) {
                style = {};
                style[subStyle] = {
                    colorfunc: function (atom) {
                        var ch = (atom.chain || ' ').trim() || 'A';
                        var key = ch + ':' + String(atom.resi);
                        return resSetOther.has(key) ? pdb3dColorByResidue(atom) : gray;
                    }
                };
            } else {
                style = {};
                style[subStyle] = { colorscheme: 'spectrum' };
            }
            break;
        }
        default: {
            var resSetDefault = epitopeResidues && epitopeResidues.residues ? epitopeResidues.residues : (epitopeResidues && epitopeResidues.size ? epitopeResidues : null);
            if (resSetDefault && resSetDefault.size > 0) {
                style = {
                    cartoon: {
                        colorfunc: function (atom) {
                            var ch = (atom.chain || ' ').trim() || 'A';
                            var key = ch + ':' + String(atom.resi);
                            return resSetDefault.has(key) ? pdb3dColorByResidue(atom) : gray;
                        }
                    }
                };
            } else {
                style = { cartoon: { color: 'spectrum' } };
            }
            break;
        }
    }
    return style;
}

/** Remove all Show AAs labels and add new ones for epitope residues (one-letter + ref coord). Labels use atom position so they move with the model. No-op for Mol* (different API). */
function updatePdb3dAALabels(viewer) {
    if (!viewer) return;
    if (viewer.plugin && typeof viewer.addLabel !== 'function') return;
    pdb3dAALabels.forEach(function(lab) {
        try { viewer.removeLabel(lab); } catch (e) {}
    });
    pdb3dAALabels = [];
    if (!pdb3dShowAAs) return;
    const epitopeData = (state.selectedEpitope && state.epitopeColumns && state.viewSequences) ? getPdb3dEpitopeResidues() : null;
    if (!epitopeData || !epitopeData.residues || epitopeData.residues.size === 0) return;
    if (!viewer.selectedAtoms) return;
    const labelOpts = { backgroundColor: 0x333333, backgroundOpacity: 0.85, fontColor: 0xffffff, fontSize: 12, showBackground: true };
    const refCoordByKey = epitopeData.refCoordByKey || new Map();
    epitopeData.residues.forEach(function(key) {
        const parts = key.split(':');
        const chain = parts[0] || 'A';
        const resi = parseInt(parts[1], 10);
        if (isNaN(resi)) return;
        const atoms = viewer.selectedAtoms({ chain: chain, resi: resi });
        if (!atoms || atoms.length === 0) return;
        const atom = atoms.find(function(a) { return (a.atom || '').trim() === 'CA'; }) || atoms[0];
        const resn = atom.resn || '?';
        const one = (PDB_RESIDUE_TO_ONE[resn] || 'X').toUpperCase();
        const refCoord = refCoordByKey.get(key);
        const refStr = (refCoord !== undefined && refCoord !== null) ? String(refCoord) : '—';
        const text = one + ' ' + refStr;
        const lab = viewer.addLabel(text, { position: atom, fontColor: labelOpts.fontColor, fontSize: labelOpts.fontSize, showBackground: labelOpts.showBackground, backgroundColor: labelOpts.backgroundColor, backgroundOpacity: labelOpts.backgroundOpacity });
        pdb3dAALabels.push(lab);
    });
    viewer.render();
}

/** Re-apply current style to the open 3D viewer (no reload). Call when user changes Intrinsic, Extrinsic or Superficial style dropdown. */
function applyPdb3dStyleToViewer() {
    if (!pdb3dViewerInstance) return;
    var intrinsicSel = document.getElementById('pdb3d-style-intrinsic');
    var extrinsicSel = document.getElementById('pdb3d-style-extrinsic');
    var superficialSel = document.getElementById('pdb3d-style-superficial');
    var styleIntrinsic = (intrinsicSel && intrinsicSel.value) || pdb3dCurrentStyleIntrinsic;
    var styleExtrinsic = (extrinsicSel && extrinsicSel.value) || pdb3dCurrentStyleExtrinsic;
    var styleSuperficial = (superficialSel && superficialSel.value) || pdb3dCurrentStyleSuperficial;
    var epitopeData = (state.selectedEpitope && state.epitopeColumns && state.viewSequences) ? getPdb3dEpitopeResidues() : null;
    var intrinsicSet = pdb3dIntrinsicChainIds.length ? new Set(pdb3dIntrinsicChainIds) : new Set();
    var extrinsicSet = pdb3dExtrinsicChainIds.length ? new Set(pdb3dExtrinsicChainIds) : new Set();
    (pdb3dSelectedChainIds || []).forEach(function (chainId) {
        var styleKey, epitopeForChain;
        if (intrinsicSet.has(chainId)) {
            styleKey = styleIntrinsic;
            epitopeForChain = epitopeData;
        } else if (extrinsicSet.has(chainId)) {
            styleKey = styleExtrinsic;
            epitopeForChain = null;
        } else {
            styleKey = styleSuperficial;
            epitopeForChain = null;
        }
        pdb3dViewerInstance.setStyle({ chain: chainId }, getPdb3dStyleSpec(styleKey, epitopeForChain));
    });
    pdb3dViewerInstance.render();
}

function renderPdb3dWithChains(selectedChainIds, intrinsicChainIds) {
    if (!state.pdbFileContent || !dom.pdbViewerContainer) return;
    var filtered = (selectedChainIds && selectedChainIds.length > 0)
        ? filterStructureByChains(state.pdbFileContent, selectedChainIds)
        : state.pdbFileContent;
    var format = state.pdbFormat || (isCifStructure(state.pdbFileContent) ? 'cif' : 'pdb');
    if (typeof $3Dmol === 'undefined') {
        dom.pdbViewerContainer.innerHTML = '<p style="padding:20px;">3Dmol.js failed to load. Check your connection.</p>';
        return;
    }
    var intrinsicIds = (intrinsicChainIds && intrinsicChainIds.length >= 0) ? intrinsicChainIds : pdb3dIntrinsicChainIds;
    pdb3dSelectedChainIds = (selectedChainIds && selectedChainIds.length > 0) ? selectedChainIds.slice() : [];
    if (pdb3dViewerInstance) {
        try {
            var canvas = pdb3dViewerInstance.canvas || (dom.pdbViewerContainer && dom.pdbViewerContainer.querySelector && dom.pdbViewerContainer.querySelector('canvas'));
            if (canvas) {
                var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    var ext = gl.getExtension && gl.getExtension('WEBGL_lose_context');
                    if (ext && ext.loseContext) ext.loseContext();
                }
            }
        } catch (e) { /* ignore */ }
        if (typeof pdb3dViewerInstance.destroy === 'function') pdb3dViewerInstance.destroy();
        else if (typeof pdb3dViewerInstance.dispose === 'function') pdb3dViewerInstance.dispose();
        pdb3dViewerInstance = null;
    }
    dom.pdbViewerContainer.innerHTML = '';
    var viewer = $3Dmol.createViewer(dom.pdbViewerContainer, { backgroundColor: 'white' });
    pdb3dViewerInstance = viewer;
    viewer.addModel(filtered, format);
    var intrinsicSel = document.getElementById('pdb3d-style-intrinsic');
    var extrinsicSel = document.getElementById('pdb3d-style-extrinsic');
    var superficialSel = document.getElementById('pdb3d-style-superficial');
    var styleIntrinsic = (intrinsicSel && intrinsicSel.value) || pdb3dCurrentStyleIntrinsic;
    var styleExtrinsic = (extrinsicSel && extrinsicSel.value) || pdb3dCurrentStyleExtrinsic;
    var styleSuperficial = (superficialSel && superficialSel.value) || pdb3dCurrentStyleSuperficial;
    var epitopeData = (state.selectedEpitope && state.epitopeColumns && state.viewSequences) ? getPdb3dEpitopeResidues() : null;
    var intrinsicSet = intrinsicIds.length ? new Set(intrinsicIds) : new Set();
    var extrinsicSet = (pdb3dExtrinsicChainIds && pdb3dExtrinsicChainIds.length) ? new Set(pdb3dExtrinsicChainIds) : new Set();
    pdb3dSelectedChainIds.forEach(function (chainId) {
        var styleKey, epitopeForChain;
        if (intrinsicSet.has(chainId)) {
            styleKey = styleIntrinsic;
            epitopeForChain = epitopeData;
        } else if (extrinsicSet.has(chainId)) {
            styleKey = styleExtrinsic;
            epitopeForChain = null;
        } else {
            styleKey = styleSuperficial;
            epitopeForChain = null;
        }
        viewer.setStyle({ chain: chainId }, getPdb3dStyleSpec(styleKey, epitopeForChain));
    });
    viewer.zoomTo();
    viewer.render();

    var hoverEl = document.createElement('div');
    hoverEl.id = 'pdb3d-hover-info';
    hoverEl.setAttribute('style', 'position:absolute;bottom:10px;left:10px;padding:6px 10px;font-size:12px;font-family:monospace;background:rgba(0,0,0,0.75);color:#fff;border-radius:4px;pointer-events:none;z-index:5;max-width:90%;');
    dom.pdbViewerContainer.appendChild(hoverEl);

    var clickPopup = document.createElement('div');
    clickPopup.id = 'pdb3d-click-popup';
    clickPopup.setAttribute('style', 'display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);min-width:280px;max-width:90%;max-height:85%;background:#fff;border:1px solid #d1d5db;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.2);z-index:20;overflow:hidden;flex-direction:column;');
    var clickPopupHeading = document.createElement('div');
    clickPopupHeading.setAttribute('style', 'padding:12px 36px 12px 14px;font-size:13px;font-family:monospace;font-weight:600;color:#111;word-break:break-word;cursor:move;flex-shrink:0;border-bottom:1px solid #e5e7eb;');
    var clickPopupLogoContainer = document.createElement('div');
    clickPopupLogoContainer.setAttribute('style', 'padding:10px;overflow:auto;flex:1;min-height:0;');
    var clickPopupClose = document.createElement('button');
    clickPopupClose.setAttribute('type', 'button');
    clickPopupClose.setAttribute('style', 'position:absolute;top:6px;right:6px;width:24px;height:24px;padding:0;border:none;background:#f3f4f6;color:#6b7280;font-size:16px;line-height:1;cursor:pointer;border-radius:4px;');
    clickPopupClose.textContent = '\u00D7';
    clickPopupClose.title = 'Close';
    clickPopupClose.onclick = function () { clickPopup.style.display = 'none'; };
    clickPopup.appendChild(clickPopupHeading);
    clickPopup.appendChild(clickPopupLogoContainer);
    clickPopup.appendChild(clickPopupClose);
    dom.pdbViewerContainer.appendChild(clickPopup);
    (function makePopupDraggable() {
        var container = dom.pdbViewerContainer;
        clickPopupHeading.addEventListener('mousedown', function (e) {
            if (e.button !== 0) return;
            e.preventDefault();
            var popupRect = clickPopup.getBoundingClientRect();
            var contRect = container.getBoundingClientRect();
            var style = clickPopup.style;
            if (style.transform) {
                var leftPx = popupRect.left - contRect.left + container.scrollLeft;
                var topPx = popupRect.top - contRect.top + container.scrollTop;
                style.left = leftPx + 'px';
                style.top = topPx + 'px';
                style.transform = 'none';
            }
            var offsetX = e.clientX - popupRect.left;
            var offsetY = e.clientY - popupRect.top;
            function onMove(ev) {
                var cr = container.getBoundingClientRect();
                var newLeft = ev.clientX - cr.left - offsetX + container.scrollLeft;
                var newTop = ev.clientY - cr.top - offsetY + container.scrollTop;
                clickPopup.style.left = Math.max(0, newLeft) + 'px';
                clickPopup.style.top = Math.max(0, newTop) + 'px';
            }
            function onUp() {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
            }
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        });
    })();

    function formatResidue(atom) {
        if (!atom) return '';
        var ch = (atom.chain || ' ').trim() || 'A';
        var resn = (atom.resn || '').trim() || '?';
        var one = (PDB_RESIDUE_TO_ONE[resn] || 'X').toUpperCase();
        return one + ' ' + resn + ' ' + ch + ' ' + atom.resi;
    }
    function showClickPopup(msg, clearLogo) {
        clickPopupHeading.textContent = msg;
        if (clearLogo !== false) clickPopupLogoContainer.innerHTML = '';
        clickPopup.style.display = 'flex';
    }
    function showRegionLogoSelector(epitope, region, onOk) {
        var selectorOverlay = document.createElement('div');
        selectorOverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10003;';
        var selectorModal = document.createElement('div');
        selectorModal.style.cssText = 'background: white; padding: 20px; border-radius: 8px; min-width: 300px;';
        var title = document.createElement('h3');
        title.textContent = 'Select Escape Start Sequence';
        title.style.margin = '0 0 15px 0';
        selectorModal.appendChild(title);
        var select = document.createElement('select');
        select.style.cssText = 'width: 100%; padding: 8px; margin-bottom: 15px; font-size: 14px;';
        var hasReference = state.refIndex >= 0 && state.refIndex < state.rawSequences.length;
        var hasSubtype = state.subtypeIndex >= 0 && state.subtypeIndex < state.rawSequences.length;
        var founderIndex = state.rawSequences.findIndex(function (seq) { return seq.name && seq.name.startsWith('consensus_of_'); });
        var hasFounder = founderIndex !== -1;
        var pdbChains = state.rawSequences.filter(function (seq) { return isPdbChainSequence(seq); });
        if (hasReference) {
            var o = document.createElement('option');
            o.value = 'reference';
            o.textContent = 'Reference';
            select.appendChild(o);
        }
        if (hasSubtype) {
            o = document.createElement('option');
            o.value = 'subtype';
            o.textContent = 'Subtype';
            select.appendChild(o);
        }
        if (hasFounder) {
            o = document.createElement('option');
            o.value = 'founder';
            o.textContent = 'Founder';
            o.selected = true;
            select.appendChild(o);
        }
        pdbChains.forEach(function (seq) {
            o = document.createElement('option');
            o.value = seq.name;
            o.textContent = getPdbChainDisplayLabel(seq);
            select.appendChild(o);
        });
        o = document.createElement('option');
        o.value = 'none';
        o.textContent = 'None';
        select.appendChild(o);
        selectorModal.appendChild(select);
        var buttonDiv = document.createElement('div');
        buttonDiv.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end;';
        var cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.style.cssText = 'padding: 8px 16px; border: 1px solid #ccc; background: white; cursor: pointer;';
        cancelBtn.onclick = function () { selectorOverlay.remove(); };
        buttonDiv.appendChild(cancelBtn);
        var okBtn = document.createElement('button');
        okBtn.textContent = 'OK';
        okBtn.style.cssText = 'padding: 8px 16px; border: 1px solid #2563eb; background: #2563eb; color: white; cursor: pointer;';
        okBtn.onclick = function () {
            var selectedType = select.value;
            selectorOverlay.remove();
            var bottomSeq = null, bottomIndex = -1, bottomLabel = '';
            if (selectedType === 'reference' && hasReference) {
                bottomIndex = state.refIndex;
                bottomSeq = state.rawSequences[bottomIndex];
                bottomLabel = 'Reference (' + bottomSeq.name + ')';
            } else if (selectedType === 'subtype' && hasSubtype) {
                bottomIndex = state.subtypeIndex;
                bottomSeq = state.rawSequences[bottomIndex];
                bottomLabel = 'Subtype (' + bottomSeq.name + ')';
            } else if (selectedType === 'founder' && hasFounder) {
                bottomIndex = founderIndex;
                bottomSeq = state.rawSequences[bottomIndex];
                bottomLabel = 'Founder (' + bottomSeq.name + ')';
            } else if (selectedType === 'none') {
                var maxLength = Math.max.apply(null, state.rawSequences.map(function (seq) { return seq.seq ? seq.seq.length : 0; }));
                bottomSeq = { name: 'None', seq: '.'.repeat(maxLength) };
                bottomIndex = -1;
                bottomLabel = null;
            } else {
                var pdbIdx = state.rawSequences.findIndex(function (s) { return s.name === selectedType; });
                if (pdbIdx !== -1 && isPdbChainSequence(state.rawSequences[pdbIdx])) {
                    bottomIndex = pdbIdx;
                    bottomSeq = state.rawSequences[pdbIdx];
                    bottomLabel = getPdbChainDisplayLabel(bottomSeq);
                }
            }
            if (bottomSeq) {
                var groupIds = Array.from(state.groupNames.keys()).sort(function (a, b) { return a - b; });
                if (groupIds.length > 0) onOk(bottomSeq, bottomIndex, bottomLabel, groupIds);
            }
        };
        buttonDiv.appendChild(okBtn);
        selectorModal.appendChild(buttonDiv);
        selectorOverlay.appendChild(selectorModal);
        document.body.appendChild(selectorOverlay);
    }
    function attachHoverAndClick() {
        try {
            viewer.setHoverable({}, true,
                function (atom, viewer, event, container) {
                    hoverEl.textContent = atom ? formatResidue(atom) : '';
                },
                function (atom) {
                    hoverEl.textContent = '';
                }
            );
        } catch (e) { /* 3Dmol version may not support setHoverable */ }
        try {
            viewer.setClickable({}, true, function (atom, viewer, event, container) {
                if (!atom) return;
                var info = formatResidue(atom);
                var msg;
                if (!state.selectedEpitope || !state.epitopes || state.epitopes.length === 0) {
                    msg = info + ' — No epitope selected. Load epitopes and use Select Epitope to choose one.';
                    console.log('[PDB 3D click]', msg);
                    showClickPopup(msg);
                    return;
                }
                var ch = (atom.chain || ' ').trim() || 'A';
                var refCoord = getRefCoordForPdbResidue(ch, atom.resi);
                if (refCoord === null || refCoord === undefined) {
                    msg = info + ' — Residue not in alignment (or could not map to reference).';
                    console.log('[PDB 3D click]', msg);
                    showClickPopup(msg);
                    return;
                }
                var epitope = state.epitopes.find(function (e) { return e.name === state.selectedEpitope; });
                if (!epitope || !epitope.regions || epitope.regions.length === 0) {
                    msg = info + ' — Ref coord ' + refCoord + ' (no regions defined for selected epitope).';
                    console.log('[PDB 3D click]', msg);
                    showClickPopup(msg);
                    return;
                }
                var region = null;
                for (var i = 0; i < epitope.regions.length; i++) {
                    var r = epitope.regions[i];
                    if (refCoord >= r.start && refCoord <= r.end) {
                        region = r;
                        break;
                    }
                }
                if (region) {
                    msg = info + ' — Epitope region: ' + region.start + ' - ' + region.end;
                    console.log('[PDB 3D click]', msg);
                    showClickPopup(msg);
                    if (state.sequenceGroups && state.groupNames && state.groupNames.size > 0) {
                        showRegionLogoSelector(epitope, region, function (bottomSeq, bottomIndex, bottomLabel, groupIds) {
                            var epitopeRegion = { name: epitope.name, regions: [region] };
                            var powerValue = 1.0;
                            var sliderContainer = document.createElement('div');
                            sliderContainer.style.cssText = 'margin-bottom:10px;padding:8px;background:#f5f5f5;border-radius:4px;';
                            var sliderLabel = document.createElement('label');
                            sliderLabel.textContent = 'Power: ';
                            sliderLabel.style.cssText = 'margin-right:8px;font-size:12px;';
                            var slider = document.createElement('input');
                            slider.type = 'range';
                            slider.min = '0';
                            slider.max = '2';
                            slider.step = '0.05';
                            slider.value = '1.0';
                            slider.style.cssText = 'width:120px;margin-right:6px;vertical-align:middle;';
                            var sliderValue = document.createElement('span');
                            sliderValue.textContent = '1.00';
                            sliderValue.style.cssText = 'font-size:12px;';
                            function renderRegionLogo() {
                                var oldSvg = clickPopupLogoContainer.querySelector('svg');
                                if (oldSvg) oldSvg.remove();
                                var svg = generateSequenceLogo(epitopeRegion, bottomSeq, groupIds, bottomIndex, bottomLabel, powerValue);
                                clickPopupLogoContainer.appendChild(svg);
                            }
                            slider.addEventListener('input', function (e) {
                                powerValue = parseFloat(e.target.value);
                                sliderValue.textContent = powerValue.toFixed(2);
                                renderRegionLogo();
                            });
                            sliderContainer.appendChild(sliderLabel);
                            sliderContainer.appendChild(slider);
                            sliderContainer.appendChild(sliderValue);
                            clickPopupLogoContainer.innerHTML = '';
                            clickPopupLogoContainer.appendChild(sliderContainer);
                            renderRegionLogo();
                        });
                    } else {
                        clickPopupLogoContainer.textContent = 'Group sequences to see region logo.';
                    }
                } else {
                    msg = info + ' — Ref coord ' + refCoord + ' not in any epitope region.';
                    console.log('[PDB 3D click]', msg);
                    showClickPopup(msg);
                }
            });
        } catch (e) { /* 3Dmol version may not support setClickable */ }
        viewer.render();
    }
    attachHoverAndClick();
    requestAnimationFrame(function () { attachHoverAndClick(); });
    updatePdb3dAALabels(viewer);
}

function openPdbViewerFromState() {
    if (!state.pdbFileContent || !dom.pdbOverlay || !dom.pdbViewerContainer) {
        alert('Load a PDB file first (use Load PDB).');
        return;
    }
    closePdbViewer();
    if (dom.pdbTitle) dom.pdbTitle.textContent = state.pdbFileName || 'PDB 3D Structure';
    dom.pdbOverlay.style.display = 'flex';

    var allStructureChainIds = getStructureChainIds(state.pdbFileContent);
    var partition = getPdbChainIntrinsicExtrinsicPartition();
    var intrinsicIds = partition.intrinsic || [];
    var extrinsicIds = partition.extrinsic || [];
    var panelChainSet = new Set(intrinsicIds.concat(extrinsicIds));
    var superficialIds = allStructureChainIds.filter(function (id) { return !panelChainSet.has(id); });
    pdb3dIntrinsicChainIds = intrinsicIds.slice();
    pdb3dExtrinsicChainIds = extrinsicIds.slice();
    pdb3dSuperficialChainIds = superficialIds.slice();
    var checkboxes = {};
    var allChainIds = intrinsicIds.slice();
    extrinsicIds.forEach(function (id) {
        if (allChainIds.indexOf(id) < 0) allChainIds.push(id);
    });
    superficialIds.forEach(function (id) {
        if (allChainIds.indexOf(id) < 0) allChainIds.push(id);
    });

    function getSelected() {
        return allChainIds.filter(function (id) { return checkboxes[id] && checkboxes[id].checked; });
    }
    function updateView() {
        renderPdb3dWithChains(getSelected(), pdb3dIntrinsicChainIds);
    }

    var intrinsicStyleSelect = document.getElementById('pdb3d-style-intrinsic');
    var extrinsicStyleSelect = document.getElementById('pdb3d-style-extrinsic');
    var superficialStyleSelect = document.getElementById('pdb3d-style-superficial');
    if (intrinsicStyleSelect) {
        intrinsicStyleSelect.value = pdb3dCurrentStyleIntrinsic;
        intrinsicStyleSelect.onchange = function () {
            pdb3dCurrentStyleIntrinsic = this.value;
            applyPdb3dStyleToViewer();
        };
    }
    if (extrinsicStyleSelect) {
        extrinsicStyleSelect.value = pdb3dCurrentStyleExtrinsic;
        extrinsicStyleSelect.onchange = function () {
            pdb3dCurrentStyleExtrinsic = this.value;
            applyPdb3dStyleToViewer();
        };
    }
    if (superficialStyleSelect) {
        superficialStyleSelect.value = pdb3dCurrentStyleSuperficial;
        superficialStyleSelect.onchange = function () {
            pdb3dCurrentStyleSuperficial = this.value;
            applyPdb3dStyleToViewer();
        };
    }

    var intrinsicListEl = document.getElementById('pdb3d-intrinsic-chains');
    var extrinsicListEl = document.getElementById('pdb3d-extrinsic-chains');
    var superficialListEl = document.getElementById('pdb3d-superficial-chains');
    var btnIntrinsicAll = document.getElementById('pdb3d-intrinsic-all');
    var btnIntrinsicNone = document.getElementById('pdb3d-intrinsic-none');
    var btnExtrinsicAll = document.getElementById('pdb3d-extrinsic-all');
    var btnExtrinsicNone = document.getElementById('pdb3d-extrinsic-none');
    var btnSuperficialAll = document.getElementById('pdb3d-superficial-all');
    var btnSuperficialNone = document.getElementById('pdb3d-superficial-none');

    function addChainCheckbox(container, id) {
        if (!container) return;
        var label = document.createElement('label');
        label.style.cssText = 'display: inline-flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;';
        var cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = true;
        cb.dataset.chain = id;
        cb.addEventListener('change', updateView);
        checkboxes[id] = cb;
        label.appendChild(cb);
        label.appendChild(document.createTextNode(id));
        container.appendChild(label);
    }

    if (intrinsicListEl) {
        intrinsicListEl.innerHTML = '';
        intrinsicIds.forEach(function (id) { addChainCheckbox(intrinsicListEl, id); });
    }
    if (extrinsicListEl) {
        extrinsicListEl.innerHTML = '';
        extrinsicIds.forEach(function (id) { addChainCheckbox(extrinsicListEl, id); });
    }
    if (superficialListEl) {
        superficialListEl.innerHTML = '';
        superficialIds.forEach(function (id) { addChainCheckbox(superficialListEl, id); });
    }
    if (btnIntrinsicAll) btnIntrinsicAll.onclick = function () { intrinsicIds.forEach(function (id) { if (checkboxes[id]) checkboxes[id].checked = true; }); updateView(); };
    if (btnIntrinsicNone) btnIntrinsicNone.onclick = function () { intrinsicIds.forEach(function (id) { if (checkboxes[id]) checkboxes[id].checked = false; }); updateView(); };
    if (btnExtrinsicAll) btnExtrinsicAll.onclick = function () { extrinsicIds.forEach(function (id) { if (checkboxes[id]) checkboxes[id].checked = true; }); updateView(); };
    if (btnExtrinsicNone) btnExtrinsicNone.onclick = function () { extrinsicIds.forEach(function (id) { if (checkboxes[id]) checkboxes[id].checked = false; }); updateView(); };
    if (btnSuperficialAll) btnSuperficialAll.onclick = function () { superficialIds.forEach(function (id) { if (checkboxes[id]) checkboxes[id].checked = true; }); updateView(); };
    if (btnSuperficialNone) btnSuperficialNone.onclick = function () { superficialIds.forEach(function (id) { if (checkboxes[id]) checkboxes[id].checked = false; }); updateView(); };

    updateView();

    var win = document.getElementById('pdb3d-window');
    var titleBar = document.getElementById('pdb3d-title-bar');
    if (win && titleBar) makeDraggable(win, titleBar);
}

// --- Sequence Logo Generation ---
function showSequenceLogo() {
    if (!state.selectedEpitope) {
        alert("Please select an epitope first.");
        return;
    }
    
    if (!state.sequenceGroups || state.groupNames.size === 0) {
        alert("Please group sequences first.");
        return;
    }
    
    // Find the epitope
    const epitope = state.epitopes.find(e => e.name === state.selectedEpitope);
    if (!epitope) {
        alert(`Epitope "${state.selectedEpitope}" not found.`);
        return;
    }
    
    // Show popup to select bottom sequence (Reference, Subtype, or Founder)
    const selectorOverlay = document.createElement('div');
    selectorOverlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000;';
    
    const selectorModal = document.createElement('div');
    selectorModal.style.cssText = 'background: white; padding: 20px; border-radius: 8px; min-width: 300px;';
    
    const title = document.createElement('h3');
    title.textContent = 'Select Escape Start Sequence';
    title.style.margin = '0 0 15px 0';
    selectorModal.appendChild(title);
    
    const select = document.createElement('select');
    select.style.cssText = 'width: 100%; padding: 8px; margin-bottom: 15px; font-size: 14px;';
    
    // Check which sequences are available
    const hasReference = state.refIndex >= 0 && state.refIndex < state.rawSequences.length;
    const hasSubtype = state.subtypeIndex >= 0 && state.subtypeIndex < state.rawSequences.length;
    const founderIndex = state.rawSequences.findIndex(seq => 
        seq.name && seq.name.startsWith('consensus_of_')
    );
    const hasFounder = founderIndex !== -1;
    const pdbChains = state.rawSequences.filter(seq => isPdbChainSequence(seq));
    
    if (hasReference) {
        const opt = document.createElement('option');
        opt.value = 'reference';
        opt.textContent = 'Reference';
        select.appendChild(opt);
    }
    
    if (hasSubtype) {
        const opt = document.createElement('option');
        opt.value = 'subtype';
        opt.textContent = 'Subtype';
        select.appendChild(opt);
    }
    
    if (hasFounder) {
        const opt = document.createElement('option');
        opt.value = 'founder';
        opt.textContent = 'Founder';
        opt.selected = true; // Default to founder
        select.appendChild(opt);
    }
    
    pdbChains.forEach(seq => {
        const opt = document.createElement('option');
        opt.value = seq.name;
        opt.textContent = getPdbChainDisplayLabel(seq);
        select.appendChild(opt);
    });
    
    // Always add None option
    const optNone = document.createElement('option');
    optNone.value = 'none';
    optNone.textContent = 'None';
    select.appendChild(optNone);
    
    if (!hasReference && !hasSubtype && !hasFounder && pdbChains.length === 0) {
        // Even if no other sequences, AllGaps is always available
    }
    
    selectorModal.appendChild(select);
    
    const buttonDiv = document.createElement('div');
    buttonDiv.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end;';
    
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.cssText = 'padding: 8px 16px; border: 1px solid #ccc; background: white; cursor: pointer;';
    cancelBtn.onclick = () => selectorOverlay.remove();
    buttonDiv.appendChild(cancelBtn);
    
    const okBtn = document.createElement('button');
    okBtn.textContent = 'OK';
    okBtn.style.cssText = 'padding: 8px 16px; border: 1px solid #2563eb; background: #2563eb; color: white; cursor: pointer;';
    okBtn.onclick = () => {
        const selectedType = select.value;
        selectorOverlay.remove();
        
        // Find the selected sequence
        let bottomSeq = null;
        let bottomIndex = -1;
        let bottomLabel = '';
        
        if (selectedType === 'reference' && hasReference) {
            bottomIndex = state.refIndex;
            bottomSeq = state.rawSequences[bottomIndex];
            bottomLabel = `Reference (${bottomSeq.name})`;
        } else if (selectedType === 'subtype' && hasSubtype) {
            bottomIndex = state.subtypeIndex;
            bottomSeq = state.rawSequences[bottomIndex];
            bottomLabel = `Subtype (${bottomSeq.name})`;
        } else if (selectedType === 'founder' && hasFounder) {
            bottomIndex = founderIndex;
            bottomSeq = state.rawSequences[bottomIndex];
            bottomLabel = `Founder (${bottomSeq.name})`;
        } else if (selectedType === 'none') {
            // Create a sequence consisting entirely of dots
            // Use the length of the reference sequence or the longest sequence
            const maxLength = Math.max(...state.rawSequences.map(seq => seq.seq ? seq.seq.length : 0));
            bottomSeq = {
                name: 'None',
                seq: '.'.repeat(maxLength)
            };
            bottomIndex = -1; // Not a real sequence index
            bottomLabel = null; // No label for None option
        } else {
            const pdbIdx = state.rawSequences.findIndex(s => s.name === selectedType);
            if (pdbIdx !== -1 && isPdbChainSequence(state.rawSequences[pdbIdx])) {
                bottomIndex = pdbIdx;
                bottomSeq = state.rawSequences[pdbIdx];
                bottomLabel = getPdbChainDisplayLabel(bottomSeq);
            }
        }
        
        if (!bottomSeq) {
            alert("Selected sequence not found.");
            return;
        }
        
        // Get all unique group IDs (sorted)
        const groupIds = Array.from(state.groupNames.keys()).sort((a, b) => a - b);
        if (groupIds.length === 0) {
            alert("No groups found.");
            return;
        }
        
        // Show in a modal
        const overlay = document.createElement('div');
        overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 10000; pointer-events: none;';
        
        const modal = document.createElement('div');
        modal.style.cssText = 'background: white; padding: 20px; border-radius: 8px; max-width: 90vw; max-height: 90vh; overflow: auto; pointer-events: auto;';
        
        // Get file name and epitope name from state (needed for export)
        const fileName = state.currentFileName || dom.file?.files?.[0]?.name || 'Unknown';
        const epitopeName = epitope.name; // Capture epitope name for export closure
        
        // Power transformation slider
        let powerValue = 1.0; // Initialize to 1 (no transformation)
        const sliderContainer = document.createElement('div');
        sliderContainer.style.cssText = 'margin-bottom: 15px; padding: 10px; background: #f5f5f5; border-radius: 4px;';
        
        const sliderLabel = document.createElement('label');
        sliderLabel.textContent = 'Power Transform: ';
        sliderLabel.style.cssText = 'display: inline-block; margin-right: 10px; font-weight: bold;';
        
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '0';
        slider.max = '2';
        slider.step = '0.05';
        slider.value = '1.0';
        slider.style.cssText = 'width: 200px; margin-right: 10px;';
        
        const sliderValue = document.createElement('span');
        sliderValue.textContent = '1.00';
        sliderValue.style.cssText = 'display: inline-block; min-width: 50px; font-weight: bold;';
        
        slider.addEventListener('input', (e) => {
            powerValue = parseFloat(e.target.value);
            sliderValue.textContent = powerValue.toFixed(2);
            // Regenerate logo with new power value
            const oldSvg = modal.querySelector('svg');
            if (oldSvg) oldSvg.remove();
            const newSvg = generateSequenceLogo(epitope, bottomSeq, groupIds, bottomIndex, bottomLabel, powerValue);
            modal.insertBefore(newSvg, sliderContainer.nextSibling);
        });
        
        sliderContainer.appendChild(sliderLabel);
        sliderContainer.appendChild(slider);
        sliderContainer.appendChild(sliderValue);
        modal.appendChild(sliderContainer);
        
        // Generate the logo with initial power value
        const svg = generateSequenceLogo(epitope, bottomSeq, groupIds, bottomIndex, bottomLabel, powerValue);
        modal.appendChild(svg);
        
        // Create button container
        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;';
        
        // Export SVG button - get current SVG from modal
        const exportSvgBtn = document.createElement('button');
        exportSvgBtn.textContent = 'Export SVG';
        exportSvgBtn.style.cssText = 'padding: 8px 16px; border: 1px solid #2563eb; background: #2563eb; color: white; cursor: pointer; border-radius: 4px;';
        exportSvgBtn.onclick = () => {
            const currentSvg = modal.querySelector('svg');
            if (currentSvg) exportLogoAsSVG(currentSvg, epitopeName, fileName);
        };
        
        // Export PDF button - get current SVG from modal
        const exportPdfBtn = document.createElement('button');
        exportPdfBtn.textContent = 'Export PDF';
        exportPdfBtn.style.cssText = 'padding: 8px 16px; border: 1px solid #2563eb; background: #2563eb; color: white; cursor: pointer; border-radius: 4px;';
        exportPdfBtn.onclick = () => {
            const currentSvg = modal.querySelector('svg');
            if (currentSvg) exportLogoAsPDF(currentSvg, epitopeName, fileName);
        };
        
        // Export PNG button - get current SVG from modal
        const exportPngBtn = document.createElement('button');
        exportPngBtn.textContent = 'Export PNG';
        exportPngBtn.style.cssText = 'padding: 8px 16px; border: 1px solid #2563eb; background: #2563eb; color: white; cursor: pointer; border-radius: 4px;';
        exportPngBtn.onclick = () => {
            const currentSvg = modal.querySelector('svg');
            if (currentSvg) exportLogoAsPNG(currentSvg, epitopeName, fileName);
        };
        
        // Close button
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close';
        closeBtn.style.cssText = 'padding: 8px 16px; border: 1px solid #ccc; background: white; cursor: pointer; border-radius: 4px;';
        closeBtn.onclick = () => overlay.remove();
        
        buttonContainer.appendChild(exportSvgBtn);
        buttonContainer.appendChild(exportPdfBtn);
        buttonContainer.appendChild(exportPngBtn);
        buttonContainer.appendChild(closeBtn);
        modal.appendChild(buttonContainer);
        
        overlay.appendChild(modal);
        overlay.onclick = (e) => {
            if (e.target === overlay) overlay.remove();
        };
        document.body.appendChild(overlay);
    };
    buttonDiv.appendChild(okBtn);
    
    selectorModal.appendChild(buttonDiv);
    selectorOverlay.appendChild(selectorModal);
    document.body.appendChild(selectorOverlay);
}

function generateSequenceLogo(epitope, bottomSeq, groupIds, bottomIndex, bottomLabel, powerTransform = 1.0) {
    // Amino acid color mapping
    const aaColors = {
        'D': '#e74c3c', 'E': '#e74c3c', // Red - acidic
        'K': '#3498db', 'R': '#3498db', 'H': '#3498db', // Blue - basic
        'S': '#2ecc71', 'N': '#2ecc71', 'T': '#2ecc71', 'G': '#2ecc71', 'Q': '#2ecc71', // Green - polar
        'F': '#f39c12', 'A': '#f39c12', 'P': '#f39c12', 'I': '#f39c12', 
        'L': '#f39c12', 'V': '#f39c12', 'M': '#f39c12', 'W': '#f39c12', 'Y': '#f39c12', // Orange - hydrophobic
        'C': '#95a5a6', // Gray
        '-': '#bdc3c7' // Light gray for gaps
    };
    
    // Get reference sequence for coordinate mapping
    const refSeq = state.viewSequences[state.refIndex]?.seq;
    if (!refSeq || !state.refMap) {
        alert("Reference sequence or coordinate map not available.");
        return document.createElement('div');
    }
    
    // For each region, get alignment columns where ref has a residue and ref coord is in [start,end] (no trailing/leading gaps)
    const regionColumnRanges = [];
    const allColumns = new Set();
    const coordToCol = new Map(); // Map from reference coordinate to alignment column(s)
    
    for (const region of epitope.regions) {
        const cols = getAlignmentColumnsForRefRegion(region);
        if (cols.length === 0) continue;
        const startCol = Math.min.apply(null, cols);
        const endCol = Math.max.apply(null, cols);
        regionColumnRanges.push({ start: startCol, end: endCol, region: region, columnCount: cols.length });
        for (let i = 0; i < cols.length; i++) {
            const col = cols[i];
            allColumns.add(col);
            const coord = state.refMap[col];
            if (!coordToCol.has(coord)) {
                coordToCol.set(coord, []);
            }
            coordToCol.get(coord).push(col);
        }
    }
    
    // Create sorted list of unique coordinates that appear in the selected columns
    const positions = Array.from(new Set(Array.from(allColumns).map(col => state.refMap[col]))).sort((a, b) => a - b);
    
    // Create sorted list of all selected alignment columns
    const sortedColumns = Array.from(allColumns).sort((a, b) => a - b);
    
    // Get bottom sequence amino acids for all selected columns
    // Store by coordinate for compatibility, but we'll access by column when drawing
    const bottomAAs = new Map();
    for (const col of allColumns) {
        const coord = state.refMap[col];
        if (col < bottomSeq.seq.length) {
            const aa = bottomSeq.seq[col];
            if (aa !== '-') {
                // Store by coordinate (may overwrite if same coord appears in multiple columns)
                bottomAAs.set(coord, aa);
            }
        }
    }
    
    // Calculate frequencies for each group
    const groupFrequencies = [];
    for (const groupId of groupIds) {
        const groupValue = state.groupNames.get(groupId);
        const frequencies = new Map(); // coord -> Map(aa -> count)
        
        // Get all sequences in this group
        const groupSeqs = [];
        for (let i = 0; i < state.rawSequences.length; i++) {
            const seq = state.rawSequences[i];
            if (i === bottomIndex) continue; // Skip bottom sequence
            if (seq.name && state.sequenceGroups.get(seq.name) === groupId) {
                groupSeqs.push(seq);
            }
        }
        
        // Count amino acids at each alignment column (only those different from bottom sequence)
        // Store frequencies per column, not per coordinate, to handle gaps correctly
        const columnFrequencies = new Map(); // col -> Map(aa -> count)
        
        for (const col of allColumns) {
            const freqMap = new Map();
            
            // Get bottom AA for this specific alignment column
            let bottomAA = null;
            let bottomIsGap = false;
            if (col < bottomSeq.seq.length) {
                const aa = bottomSeq.seq[col];
                if (aa === '-') {
                    bottomIsGap = true;
                } else {
                    bottomAA = aa;
                }
            }
            
            // Count variants at this alignment column (only if different from bottom)
            // Include gaps as variants (represented by nabla character)
            for (const seq of groupSeqs) {
                if (col < seq.seq.length) {
                    const aa = seq.seq[col];
                    if (aa === '-') {
                        // Gap is a variant if bottom sequence doesn't have a gap
                        if (!bottomIsGap) {
                            freqMap.set('∇', (freqMap.get('∇') || 0) + 1);
                        }
                    } else {
                        // Amino acid is a variant if different from bottom (or if bottom is a gap)
                        if (bottomIsGap || aa !== bottomAA) {
                            freqMap.set(aa, (freqMap.get(aa) || 0) + 1);
                        }
                    }
                }
            }
            
            // Only store if there are variants at this column
            if (freqMap.size > 0) {
                columnFrequencies.set(col, freqMap);
            }
        }
        
        // Convert column frequencies to coordinate-based frequencies for display
        // (group columns by coordinate for the logo display)
        for (const col of allColumns) {
            const coord = state.refMap[col];
            if (!frequencies.has(coord)) {
                frequencies.set(coord, new Map());
            }
            const coordFreqMap = frequencies.get(coord);
            
            // If this column has variants, add them to the coordinate frequency map
            if (columnFrequencies.has(col)) {
                const colFreqMap = columnFrequencies.get(col);
                for (const [aa, count] of colFreqMap.entries()) {
                    coordFreqMap.set(aa, (coordFreqMap.get(aa) || 0) + count);
                }
            }
        }
        
        groupFrequencies.push({
            groupId,
            groupValue,
            frequencies, // Keep for compatibility
            columnFrequencies, // Per-column frequencies for accurate display
            count: groupSeqs.length
        });
    }
    
    // SVG parameters
    const charWidth = 18;
    const baseFontSize = 16;
    const baseHeight = baseFontSize; // Base height matches font size
    const capHeightRatio = 0.68; // Typical cap-height to font-size ratio for Courier New monospace font (baseline to top of capital letters)
    const logoHeight = charWidth * 1.0; // Bottom logo height equals the character width (18px)
    const groupLogoHeight = logoHeight * 3; // Group logo height is 3x larger to show rare mutations (90px)
    const padding_horizontal = 40; // Horizontal padding (left and right)
    const padding_vertical = 40;   // Vertical padding (top and bottom)
    
    // Calculate required label width based on all labels
    // Estimate text width: approximately 6-7 pixels per character for 12px font
    const labelFontSize = 12;
    const pixelsPerChar = 7; // Approximate pixels per character for 12px font
    let maxLabelWidth = 0;
    
    // Check bottom label
    if (bottomLabel) {
        const bottomLabelWidth = bottomLabel.length * pixelsPerChar;
        maxLabelWidth = Math.max(maxLabelWidth, bottomLabelWidth);
    }
    
    // Check group labels
    for (const groupData of groupFrequencies) {
        const groupLabel = `${groupData.groupValue} (${groupData.count})`;
        const groupLabelWidth = groupLabel.length * pixelsPerChar;
        maxLabelWidth = Math.max(maxLabelWidth, groupLabelWidth);
    }
    
    // Set leftLabelWidth with some padding (add 20px for spacing)
    const leftLabelWidth = Math.max(150, maxLabelWidth + 20); // Minimum 150px, or calculated width + padding
    const regionGap = 3; // Reduced gap between regions to be more proportional to cell width
    
    // Calculate SVG dimensions
    const numGroups = groupFrequencies.length;
    const numLogos = numGroups + 1; // Groups + bottom sequence
    const svgWidth = sortedColumns.length * charWidth + (regionColumnRanges.length - 1) * regionGap + padding_horizontal * 2 + leftLabelWidth;
    
    // Get file name from state or file input
    const fileName = state.currentFileName || dom.file?.files?.[0]?.name || 'Unknown';
    
    // Calculate available width for titles (SVG width minus padding and margins)
    const availableWidth = svgWidth - (padding_horizontal + 10) * 2; // Left padding + margin, and right padding
    
    // Calculate power percentage (distance from 1)
    const powerPercentage = ((powerTransform - 1) * 100);
    const absPowerPercentage = Math.abs(powerPercentage).toFixed(0);
    
    // Build bias text
    let biasText;
    if (Math.abs(powerPercentage) < 0.5) {
        // Effectively zero (within rounding)
        biasText = 'with zero frequency bias';
    } else if (powerPercentage < 0) {
        // Negative bias (towards rare bases)
        biasText = `with ${absPowerPercentage}% frequency bias towards rare bases`;
    } else {
        // Positive bias (towards abundant bases)
        biasText = `with ${absPowerPercentage}% frequency bias towards abundant bases`;
    }
    
    // Build title based on start sequence selection
    let titleText;
    if (bottomLabel && bottomLabel !== 'None') {
        // Extract sequence type from label (e.g., "Reference (V806_...)" -> "Reference", "Founder (consensus_of_...)" -> "Founder")
        const sequenceType = bottomLabel.split(' ')[0];
        titleText = `Logogram for ${epitope.name}, showing escape from ${sequenceType}, ${biasText}`;
    } else {
        // None option - omit the middle part
        titleText = `Logogram for ${epitope.name}, ${biasText}`;
    }
    
    // Calculate font sizes for both title lines before creating SVG
    // Use temporary SVG elements to measure text width
    const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    tempSvg.style.position = 'absolute';
    tempSvg.style.visibility = 'hidden';
    tempSvg.style.width = '0';
    tempSvg.style.height = '0';
    document.body.appendChild(tempSvg);
    
    // Find appropriate font size for first line that fits the width
    let fontSize = 18; // Start with default size
    const tempText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    tempText.setAttribute('font-family', 'sans-serif');
    tempText.setAttribute('font-weight', 'bold');
    tempText.textContent = titleText;
    tempSvg.appendChild(tempText);
    
    // Try different font sizes until text fits
    while (fontSize > 8) { // Minimum font size of 8px
        tempText.setAttribute('font-size', fontSize.toString());
        const textWidth = tempText.getBBox().width;
        if (textWidth <= availableWidth) {
            break;
        }
        fontSize -= 0.5; // Reduce by 0.5px increments
    }
    
    // Find appropriate font size for second line that fits the width
    const alignmentText = `Alignment: ${fileName}`;
    let fontSize2 = fontSize; // Start with same size as first line
    const tempText2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    tempText2.setAttribute('font-family', 'sans-serif');
    tempText2.setAttribute('font-weight', 'bold');
    tempText2.textContent = alignmentText;
    tempSvg.appendChild(tempText2);
    
    // Try different font sizes until text fits
    while (fontSize2 > 8) { // Minimum font size of 8px
        tempText2.setAttribute('font-size', fontSize2.toString());
        const textWidth2 = tempText2.getBBox().width;
        if (textWidth2 <= availableWidth) {
            break;
        }
        fontSize2 -= 0.5; // Reduce by 0.5px increments
    }
    
    document.body.removeChild(tempSvg);
    
    // Calculate title height with actual font sizes
    const titleHeight = fontSize + 5 + fontSize2 + 15; // First line + spacing (5px) + second line + bottom margin (15px)
    
    // Height = title + (number of group logos * groupLogoHeight) + bottom logo height + padding top and bottom
    const svgHeight = titleHeight + (numGroups * groupLogoHeight) + logoHeight + padding_vertical * 2;
    
    // Create SVG element
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', svgWidth);
    svg.setAttribute('height', svgHeight);
    svg.style.border = '1px solid #ccc';
    svg.style.background = 'white';
    
    // First title line: "Logogram for <epitope>, showing escape from <start sequence>, with <power percentage> bias"
    const titleLine1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    titleLine1.setAttribute('x', padding_horizontal + 10); // Align with logo labels
    titleLine1.setAttribute('y', padding_vertical + fontSize); // Adjust Y position based on font size
    titleLine1.setAttribute('font-family', 'sans-serif');
    titleLine1.setAttribute('font-size', fontSize.toString());
    titleLine1.setAttribute('font-weight', 'bold');
    titleLine1.setAttribute('fill', '#000');
    titleLine1.textContent = titleText;
    svg.appendChild(titleLine1);
    
    // Second title line: "Alignment: <file name>"
    const titleLine2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    titleLine2.setAttribute('x', padding_horizontal + 10); // Align with logo labels
    titleLine2.setAttribute('y', padding_vertical + fontSize + 5 + fontSize2); // First line + spacing (5px) + second line font size
    titleLine2.setAttribute('font-family', 'sans-serif');
    titleLine2.setAttribute('font-size', fontSize2.toString());
    titleLine2.setAttribute('font-weight', 'bold');
    titleLine2.setAttribute('fill', '#000');
    titleLine2.textContent = alignmentText;
    svg.appendChild(titleLine2);
    
    // Draw horizontal separators: at top of uppermost logo and at bottom of each logo
    const separatorColor = '#d0d0d0'; // Lighter grey for all separators
    
    // Top separator (at top of uppermost logo, where the next group's baseline would be)
    if (groupFrequencies.length > 0) {
        // Topmost logo is at rowIdx = groupFrequencies.length - 1
        // The separator should be at the top of this logo, which is where rowIdx = groupFrequencies.length's baseline would be
        // That baseline would be at: svgHeight - padding_vertical - logoHeight - (groupFrequencies.length * groupLogoHeight)
        const topSeparatorY = svgHeight - padding_vertical - logoHeight - (groupFrequencies.length * groupLogoHeight);
        const topSeparator = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        topSeparator.setAttribute('x1', padding_horizontal + leftLabelWidth);
        topSeparator.setAttribute('y1', topSeparatorY);
        topSeparator.setAttribute('x2', svgWidth - padding_horizontal);
        topSeparator.setAttribute('y2', topSeparatorY);
        topSeparator.setAttribute('stroke', separatorColor);
        topSeparator.setAttribute('stroke-width', '1');
        svg.appendChild(topSeparator);
    }
    
    // Bottom separator for each logo (at the bottom of each logo row)
    // Bottom logo bottom: svgHeight - padding_vertical - logoHeight
    // Each group logo bottom: svgHeight - padding_vertical - logoHeight - (rowIdx * groupLogoHeight)
    // Draw separators from bottom to top
    // i=0: bottom logo separator
    // i=1: first group logo bottom separator (rowIdx=0) - use same calculation as yBase
    // i=2: second group logo bottom separator (rowIdx=1) - use same calculation as yBase
    for (let i = 0; i <= groupFrequencies.length; i++) {
        const separatorY = i === 0 
            ? svgHeight - padding_vertical  // Bottom logo separator at the very bottom
            : svgHeight - padding_vertical - logoHeight - ((i - 1) * groupLogoHeight);  // Group logo separators (i=1 for rowIdx=0, i=2 for rowIdx=1)
        const separator = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        separator.setAttribute('x1', padding_horizontal + leftLabelWidth);
        separator.setAttribute('y1', separatorY);
        separator.setAttribute('x2', svgWidth - padding_horizontal);
        separator.setAttribute('y2', separatorY);
        separator.setAttribute('stroke', separatorColor);
        separator.setAttribute('stroke-width', '1');
        svg.appendChild(separator);
    }
    
    // Add top boundary line at the top of the topmost logo (where the next group's baseline would be)
    if (groupFrequencies.length > 0) {
        // Topmost logo is at rowIdx = groupFrequencies.length - 1
        // The separator should be at the top of this logo, which is where rowIdx = groupFrequencies.length's baseline would be
        // That baseline would be at: svgHeight - padding_vertical - logoHeight - (groupFrequencies.length * groupLogoHeight)
        const topSeparatorY = svgHeight - padding_vertical - logoHeight - (groupFrequencies.length * groupLogoHeight);
        const topBoundary = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        topBoundary.setAttribute('x1', padding_horizontal + leftLabelWidth);
        topBoundary.setAttribute('y1', topSeparatorY);
        topBoundary.setAttribute('x2', svgWidth - padding_horizontal);
        topBoundary.setAttribute('y2', topSeparatorY);
        topBoundary.setAttribute('stroke', separatorColor);
        topBoundary.setAttribute('stroke-width', '1');
        svg.appendChild(topBoundary);
    }
    
    // Additional horizontal line at the very bottom of the bottom logo (after coordinate labels)
    const bottomLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    bottomLine.setAttribute('x1', padding_horizontal + leftLabelWidth);
    bottomLine.setAttribute('y1', svgHeight - padding_vertical);
    bottomLine.setAttribute('x2', svgWidth - padding_horizontal);
    bottomLine.setAttribute('y2', svgHeight - padding_vertical);
    bottomLine.setAttribute('stroke', separatorColor);
    bottomLine.setAttribute('stroke-width', '1');
    svg.appendChild(bottomLine);
    
    // Draw vertical lines: before first region, between regions, and after last region
    let xOffset = padding_horizontal + leftLabelWidth;
    
    // Draw line before first region
    const startLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    startLine.setAttribute('x1', xOffset);
    startLine.setAttribute('y1', titleHeight + padding_vertical); // Start after title
    startLine.setAttribute('x2', xOffset);
    startLine.setAttribute('y2', svgHeight - padding_vertical);
    startLine.setAttribute('stroke', separatorColor);
    startLine.setAttribute('stroke-width', '2');
    svg.appendChild(startLine);
    
    // Draw lines between regions (use columnCount = actual drawn columns per region, not column index span)
    for (let i = 0; i < regionColumnRanges.length - 1; i++) {
        const currentRange = regionColumnRanges[i];
        const regionColumnCount = currentRange.columnCount != null ? currentRange.columnCount : (currentRange.end - currentRange.start + 1);
        xOffset += regionColumnCount * charWidth;
        
        // Draw vertical line (lighter grey)
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', xOffset);
        line.setAttribute('y1', titleHeight + padding_vertical); // Start after title
        line.setAttribute('x2', xOffset);
        line.setAttribute('y2', svgHeight - padding_vertical);
        line.setAttribute('stroke', separatorColor);
        line.setAttribute('stroke-width', '2');
        svg.appendChild(line);
        
        xOffset += regionGap;
    }
    
    // Draw line after last region
    // Calculate end position: add positions in last region
    if (epitope.regions.length > 0) {
        const lastRange = regionColumnRanges[regionColumnRanges.length - 1];
        const endX = padding_horizontal + leftLabelWidth + sortedColumns.length * charWidth + (regionColumnRanges.length - 1) * regionGap;
        
        const endLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        endLine.setAttribute('x1', endX);
        endLine.setAttribute('y1', titleHeight + padding_vertical); // Start after title
        endLine.setAttribute('x2', endX);
        endLine.setAttribute('y2', svgHeight - padding_vertical);
        endLine.setAttribute('stroke', separatorColor);
        endLine.setAttribute('stroke-width', '2');
        svg.appendChild(endLine);
    }
    
    // Create a set of start and end coordinates for each region
    const regionBoundaryCoords = new Set();
    for (const region of epitope.regions) {
        regionBoundaryCoords.add(region.start);
        regionBoundaryCoords.add(region.end);
    }
    
    // Draw bottom sequence row
    // Bottom logo starts at svgHeight - padding_vertical - logoHeight
    const bottomLogoY = svgHeight - padding_vertical;  // Bottom logo characters align with bottom separator
    xOffset = padding_horizontal + leftLabelWidth;
    let currentRegionRangeIdx = 0;
    
    // Iterate through all selected alignment columns (not just coordinates)
    for (let i = 0; i < sortedColumns.length; i++) {
        const col = sortedColumns[i];
        const coord = state.refMap[col];
        
        // Check if we need to add gap for new region
        if (currentRegionRangeIdx < regionColumnRanges.length - 1) {
            const currentRange = regionColumnRanges[currentRegionRangeIdx];
            const nextRange = regionColumnRanges[currentRegionRangeIdx + 1];
            if (col > currentRange.end && col === nextRange.start) {
                xOffset += regionGap;
                currentRegionRangeIdx++;
            }
        }
        
        // Get amino acid from bottom sequence at this alignment column
        let bottomAA = null;
        let isGap = false;
        let isDot = false;
        if (col < bottomSeq.seq.length) {
            const aa = bottomSeq.seq[col];
            if (aa === '-') {
                isGap = true;
            } else if (aa === '.') {
                isDot = true;
            } else {
                bottomAA = aa;
            }
        }
        
        // Draw bottom sequence character (amino acid, gap, or dot)
        // Position text so its bottom aligns with the separator line below (same approach as group logos)
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', xOffset + charWidth / 2);
        // Position at bottomLogoY (same as separator position) with text-after-edge alignment
        const textY = bottomLogoY;
        text.setAttribute('y', textY);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('dominant-baseline', 'alphabetic'); // Use alphabetic baseline like labels
        text.setAttribute('font-family', 'Courier New, Courier, monospace'); // Fixed-width font for consistent character alignment
        text.setAttribute('font-size', '16');
        text.setAttribute('font-weight', 'bold');
        if (isGap) {
            text.setAttribute('fill', '#808080'); // Grey for gaps
            text.textContent = '∇'; // Nabla character for gaps
        } else if (isDot) {
            text.setAttribute('fill', '#808080'); // Grey for dots (None option)
            text.textContent = '.'; // Dot character
        } else if (bottomAA) {
            text.setAttribute('fill', aaColors[bottomAA] || '#000');
            text.textContent = bottomAA;
        }
        if (isGap || isDot || bottomAA) {
            svg.appendChild(text);
        }
        
        // Position label - only for start and end coordinates of each region, rotated vertically
        // Check if this column corresponds to a region boundary coordinate
        let isBoundary = false;
        let boundaryCoord = null;
        for (const range of regionColumnRanges) {
            if (col === range.start && state.refMap[col] === range.region.start) {
                isBoundary = true;
                boundaryCoord = range.region.start;
                break;
            }
            if (col === range.end && state.refMap[col] === range.region.end) {
                isBoundary = true;
                boundaryCoord = range.region.end;
                break;
            }
        }
        
        if (isBoundary && boundaryCoord !== null) {
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            const labelX = xOffset + charWidth / 2;
            const labelY = svgHeight - padding_vertical + 20;
            label.setAttribute('x', labelX);
            label.setAttribute('y', labelY);
            label.setAttribute('text-anchor', 'middle');
            label.setAttribute('dominant-baseline', 'middle');
            label.setAttribute('font-family', 'sans-serif');
            label.setAttribute('font-size', '10');
            label.setAttribute('fill', '#666');
            // Rotate text 90 degrees clockwise around the center point (reads top to bottom)
            label.setAttribute('transform', `rotate(90 ${labelX} ${labelY})`);
            label.textContent = boundaryCoord.toString();
            svg.appendChild(label);
        }
        
        xOffset += charWidth;
    }
    
    // Draw group rows (first group just above bottom, second group above first, etc.)
    for (let rowIdx = 0; rowIdx < groupFrequencies.length; rowIdx++) {
        const groupData = groupFrequencies[rowIdx];
        // First group (rowIdx=0) is just above bottom logo, second group (rowIdx=1) is above first, etc.
        // Calculate yBase: yBase should align with the bottom separator line for this logo row
        // Separator i=1 (first group bottom) is at: svgHeight - padding_vertical - logoHeight - (1 * groupLogoHeight)
        // Separator i=2 (second group bottom) is at: svgHeight - padding_vertical - logoHeight - (2 * groupLogoHeight)
        // For rowIdx=0, yBase should match separator i=1: svgHeight - padding_vertical - logoHeight - (1 * groupLogoHeight)
        // For rowIdx=1, yBase should match separator i=2: svgHeight - padding_vertical - logoHeight - (2 * groupLogoHeight)
        // yBase should align with separator i=(rowIdx+1)
        // Separator i=1 is at: svgHeight - padding_vertical - logoHeight - (1 * groupLogoHeight)
        // Separator i=2 is at: svgHeight - padding_vertical - logoHeight - (2 * groupLogoHeight)
        // yBase should match separator i=(rowIdx+1)
        // Separator i=1 (rowIdx=0) is at: svgHeight - padding_vertical - logoHeight - (1 * groupLogoHeight)
        // Separator i=1 (rowIdx=0) is at: svgHeight - padding_vertical - logoHeight - (0 * groupLogoHeight) = svgHeight - padding_vertical - logoHeight
        // Separator i=2 (rowIdx=1) is at: svgHeight - padding_vertical - logoHeight - (1 * groupLogoHeight)
        // So yBase = svgHeight - padding_vertical - logoHeight - (rowIdx * groupLogoHeight)
        const yBase = svgHeight - padding_vertical - logoHeight - (rowIdx * groupLogoHeight);
        
        xOffset = padding_horizontal + leftLabelWidth;
        currentRegionRangeIdx = 0;
        
        // Iterate through all selected alignment columns (same as bottom row)
        for (let i = 0; i < sortedColumns.length; i++) {
            const col = sortedColumns[i];
            const coord = state.refMap[col];
            
            // Check if we need to add gap for new region
            if (currentRegionRangeIdx < regionColumnRanges.length - 1) {
                const currentRange = regionColumnRanges[currentRegionRangeIdx];
                const nextRange = regionColumnRanges[currentRegionRangeIdx + 1];
                if (col > currentRange.end && col === nextRange.start) {
                    xOffset += regionGap;
                    currentRegionRangeIdx++;
                }
            }
            
            // Get frequencies for this specific alignment column (not by coordinate)
            // This ensures we compare against the correct bottom sequence position even with gaps
            const colFreqMap = groupData.columnFrequencies.get(col);
            if (colFreqMap && colFreqMap.size > 0) {
                // Calculate frequencies relative to total group size (within-group frequencies)
                const totalGroupSize = groupData.count;
                
                // Sort amino acids by frequency (descending)
                const sortedAAs = Array.from(colFreqMap.entries())
                    .sort((a, b) => b[1] - a[1]);
                
                // Calculate raw frequencies for variants
                const rawFrequencies = sortedAAs.map(([aa, count]) => count / totalGroupSize);
                
                // Calculate the sum of variant frequencies
                const variantSum = rawFrequencies.reduce((a, b) => a + b, 0);
                
                // The difference from 1 is the frequency of the bottom sequence character
                const bottomFreq = 1 - variantSum;
                
                // Create complete frequency list including bottom sequence
                const allFrequencies = [...rawFrequencies, bottomFreq];
                
                // Apply power transformation if powerTransform !== 1.0
                let frequencies = rawFrequencies;
                if (powerTransform !== 1.0) {
                    // Transform all frequencies (variants + bottom)
                    const transformed = allFrequencies.map(f => Math.pow(f, powerTransform));
                    const sum = transformed.reduce((a, b) => a + b, 0);
                    const transformedNormalized = transformed.map(f => f / sum);
                    // Discard the transformed bottom frequency (last element), keep only variants
                    frequencies = transformedNormalized.slice(0, -1);
                }
                
                // Draw amino acids stacked by frequency (from bottom to top, no gaps)
                // Start from the bottom (yBase) and stack upward
                let yCurrentBottom = yBase; // Current bottom position for stacking
                for (let i = 0; i < sortedAAs.length; i++) {
                    const [aa, count] = sortedAAs[i];
                    // Use transformed frequency
                    const frequency = frequencies[i];
                    // Height proportional to within-group frequency, multiplied by 3 for better visibility of rare mutations
                    const charHeight = baseHeight * frequency * 3;
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    const centerX = xOffset + charWidth / 2;
                    
                    // Position the text so its bottom edge is at yCurrentBottom
                    text.setAttribute('x', centerX);
                    text.setAttribute('y', yCurrentBottom);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'alphabetic'); // Use alphabetic baseline like labels
                    text.setAttribute('font-family', 'Courier New, Courier, monospace'); // Fixed-width font for consistent character alignment
                    text.setAttribute('font-size', baseFontSize.toString());
                    text.setAttribute('font-weight', 'bold');
                    // Handle gaps (nabla character) with grey color
                    if (aa === '∇') {
                        text.setAttribute('fill', '#808080'); // Grey for gaps
                    } else {
                        text.setAttribute('fill', aaColors[aa] || '#000');
                    }
                    
                    // Scale vertically from the baseline
                    // Transform: translate to baseline point, scale upward, translate back
                    const scaleY = charHeight / baseHeight;
                    text.setAttribute('transform', `translate(${centerX}, ${yCurrentBottom}) scale(1, ${scaleY}) translate(${-centerX}, ${-yCurrentBottom})`);
                    text.textContent = aa;
                    svg.appendChild(text);
                    
                    // Position next character's baseline = previous character's baseline + previous character's visual height
                    // Previous character's baseline is at yCurrentBottom
                    // Previous character's visual height (cap-height) is approximately capHeightRatio * charHeight
                    // For sans-serif fonts, cap-height (baseline to top of capitals) is typically 0.68-0.72 of font size
                    // Using 0.72 as a good middle ground for sans-serif fonts
                    yCurrentBottom = yCurrentBottom - capHeightRatio * charHeight;
                }
            }
            
            xOffset += charWidth;
        }
        
        // Row label with color coding (shifted left out of logo area)
        // Align label bottom with logo bottom (yBase)
        const rowLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        rowLabel.setAttribute('x', padding_horizontal + 10);
        rowLabel.setAttribute('y', yBase);
        rowLabel.setAttribute('text-anchor', 'start');
        rowLabel.setAttribute('dominant-baseline', 'text-after-edge'); // Align bottom of text with yBase
        rowLabel.setAttribute('font-family', 'sans-serif');
        rowLabel.setAttribute('font-size', '12');
        rowLabel.setAttribute('font-weight', 'bold');
        // Use the same color as assigned to the group in the legend
        const groupId = groupData.groupId;
        // Groups sorted alphabetically, use COLOR_PALETTE starting from index 1
        const labelColor = COLOR_PALETTE[(groupId + 1) % COLOR_PALETTE.length];
        rowLabel.setAttribute('fill', labelColor);
        rowLabel.textContent = `${groupData.groupValue} (${groupData.count})`;
        svg.appendChild(rowLabel);
    }
    
    // Bottom row label (colored based on sequence type: Cyan for Reference, Magenta for Subtype, Yellow for Founder)
    // Align label bottom with logo bottom (same y as bottom logo characters)
    // Only show label if bottomLabel is not null (None option has no label)
    if (bottomLabel) {
        const bottomLabelEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        bottomLabelEl.setAttribute('x', padding_horizontal + 10);
        bottomLabelEl.setAttribute('y', bottomLogoY); // Align with bottom of bottom logo (same as separator)
        bottomLabelEl.setAttribute('text-anchor', 'start');
        bottomLabelEl.setAttribute('dominant-baseline', 'text-after-edge'); // Align bottom of text with logo bottom
        bottomLabelEl.setAttribute('font-family', 'sans-serif');
        bottomLabelEl.setAttribute('font-size', '12');
        bottomLabelEl.setAttribute('font-weight', 'bold');
        // Use magenta for all special sequences (Reference, Subtype, Founder)
        bottomLabelEl.setAttribute('fill', '#ff00ff'); // Magenta
        bottomLabelEl.textContent = bottomLabel;
        svg.appendChild(bottomLabelEl);
    }
    
    return svg;
}

// Export functions for sequence logo
function exportLogoAsSVG(svgElement, epitopeName, fileName) {
    // Clone the SVG to avoid modifying the original
    const clonedSvg = svgElement.cloneNode(true);
    
    // Get SVG as string
    const serializer = new XMLSerializer();
    const svgString = serializer.serializeToString(clonedSvg);
    
    // Create blob and download
    const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    
    // Create filename: escape_from_<epitope name>_<file name>.svg
    const baseFileName = fileName.replace(/\.[^/.]+$/, ''); // Remove extension
    // Sanitize filename (remove special characters that might cause issues)
    const sanitizedEpitope = epitopeName.replace(/[^a-zA-Z0-9_-]/g, '_');
    const sanitizedFile = baseFileName.replace(/[^a-zA-Z0-9_-]/g, '_');
    link.download = `escape_from_${sanitizedEpitope}_${sanitizedFile}.svg`;
    link.click();
    
    URL.revokeObjectURL(url);
}

function exportLogoAsPDF(svgElement, epitopeName, fileName) {
    // Check if html2pdf is available
    if (typeof html2pdf === 'undefined') {
        alert('PDF export library not loaded. Please ensure html2pdf.js is available.');
        return;
    }
    
    try {
        // Clone the SVG to avoid modifying the original
        const clonedSvg = svgElement.cloneNode(true);
        
        // Get SVG dimensions
        const svgWidth = svgElement.width.baseVal.value;
        const svgHeight = svgElement.height.baseVal.value;
        
        // Create filename: escape_from_<epitope name>_<file name>.pdf
        const baseFileName = fileName.replace(/\.[^/.]+$/, ''); // Remove extension
        // Sanitize filename
        const sanitizedEpitope = epitopeName.replace(/[^a-zA-Z0-9_-]/g, '_');
        const sanitizedFile = baseFileName.replace(/[^a-zA-Z0-9_-]/g, '_');
        const pdfFileName = `escape_from_${sanitizedEpitope}_${sanitizedFile}.pdf`;
        
        // Configure html2pdf options
        // Convert pixels to points (1px = 0.75pt at 96 DPI)
        const pdfWidth = svgWidth * 0.75;
        const pdfHeight = svgHeight * 0.75;
        
        const opt = {
            margin: [0, 0, 0, 0],
            filename: pdfFileName,
            image: { type: 'svg', quality: 1.0 },
            html2canvas: { 
                scale: 2,
                useCORS: true,
                logging: false,
                width: svgWidth,
                height: svgHeight
            },
            jsPDF: { 
                unit: 'pt', 
                format: [pdfWidth, pdfHeight], // Custom format to match SVG exactly
                orientation: pdfWidth > pdfHeight ? 'landscape' : 'portrait'
            }
        };
        
        // Convert SVG to PDF using html2pdf
        // Get the PDF and manually ensure single page
        html2pdf().set(opt).from(clonedSvg).toPdf().get('pdf').then((pdf) => {
            // Remove any pages beyond the first
            const totalPages = pdf.internal.getNumberOfPages();
            if (totalPages > 1) {
                // Delete extra pages
                for (let i = totalPages; i > 1; i--) {
                    pdf.deletePage(i);
                }
            }
            pdf.save(pdfFileName);
        });
    } catch (error) {
        console.error('Error exporting PDF:', error);
        alert('Error exporting PDF: ' + error.message + '. Please try downloading as SVG instead.');
    }
}

function exportLogoAsPNG(svgElement, epitopeName, fileName) {
    try {
        // Clone the SVG to avoid modifying the original
        const clonedSvg = svgElement.cloneNode(true);
        
        // Get SVG dimensions
        const svgWidth = svgElement.width.baseVal.value;
        const svgHeight = svgElement.height.baseVal.value;
        
        // Create filename: escape_from_<epitope name>_<file name>.png
        const baseFileName = fileName.replace(/\.[^/.]+$/, ''); // Remove extension
        // Sanitize filename
        const sanitizedEpitope = epitopeName.replace(/[^a-zA-Z0-9_-]/g, '_');
        const sanitizedFile = baseFileName.replace(/[^a-zA-Z0-9_-]/g, '_');
        const pngFileName = `escape_from_${sanitizedEpitope}_${sanitizedFile}.png`;
        
        // Convert SVG to string
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(clonedSvg);
        
        // Create image from SVG data URL
        const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
        const svgUrl = URL.createObjectURL(svgBlob);
        
        const img = new Image();
        img.onload = () => {
            // Create canvas with SVG dimensions
            const canvas = document.createElement('canvas');
            canvas.width = svgWidth;
            canvas.height = svgHeight;
            
            // Draw image on canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            
            // Convert canvas to PNG
            canvas.toBlob((blob) => {
                if (blob) {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = pngFileName;
                    link.click();
                    URL.revokeObjectURL(url);
                } else {
                    alert('Error: Failed to create PNG image.');
                }
                URL.revokeObjectURL(svgUrl);
            }, 'image/png');
        };
        
        img.onerror = () => {
            alert('Error: Failed to load SVG image for PNG conversion.');
            URL.revokeObjectURL(svgUrl);
        };
        
        img.src = svgUrl;
    } catch (error) {
        console.error('Error exporting PNG:', error);
        alert('Error exporting PNG: ' + error.message + '. Please try downloading as SVG instead.');
    }
}

// Initialize legend dragging
initLegendDragging();

init();
</script>
</body>
</html>
